{"createdTime":1759342496999,"shownInTree":["задания/секция-1.-javascript/практика-№1.-простая-веб-страница-с-html.html","задания/секция-1.-javascript/практика-№2.-использование-git,-github.html","задания/секция-1.-javascript/практика-№3.-вывод-информации-о-себе-в-консоль..html","задания/секция-1.-javascript/практика-№4.-преобразование-типов.html","задания/секция-1.-javascript/практика-№5.-использование-ветвления..html","задания/секция-1.-javascript/практика-№6.-вывод-таблицы-умножения-с-помощью-цикла-for.html","задания/секция-1.-javascript/практика-№7.-функции-для-работы-с-строками.html","задания/секция-1.-javascript/практика-№8.-ssr-сервер-с-динамической-генерацией-страниц.html","задания/секция-1.-javascript/практика-№9.-csr-с-гидратацией.-интерактивный-счётчик.html","задания/секция-2.-react/практика-№10.-интерактивный-счётчик-с-изменением-темы.html","задания/секция-2.-react/практика-№11.-игра-кликер.html","лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html","лекции/секция-1.-javascript/тема-№2.-основы-javascript.html","лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html","лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html","лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html","лекции/секция-1.-javascript/тема-№6.-git,-github.html","лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html","лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html","лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html","лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html","лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html","лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html","лекции/секция-2.-react/тема-№13.-основы-react.html","лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html","лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html","лекции/секция-2.-react/тема-№16.-события-и-ref-в-react.html","лекции/секция-2.-react/тема-№17.-hooks-в-react.html","лекции/секция-2.-react/тема-№18.-routers-в-react.html","лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html","лекции/секция-2.-react/тема-№20.-основы-typescript.html","материалы/заготовки-под-практики/react-project.zip","материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html","материалы/подтемы/секция-1.-javascript/тема-№1/основные-платформы-мобильных-приложений.html","материалы/подтемы/секция-1.-javascript/тема-№1/основные-технологии-для-разработки-мобильных-приложений.html","материалы/подтемы/секция-1.-javascript/тема-№1/основные-типы-мобильных-приложений.html","материалы/подтемы/секция-1.-javascript/тема-№2/базовое-понимание-синтаксиса-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№2/переменные-в-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№2/правила-наименования-переменных-в-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№2/что-такое-javascript,-история-появления.html","материалы/подтемы/секция-1.-javascript/тема-№3/базовая-работа-с-элементами-веб-страницы-через-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№3/основные-понятия-веб-страницы.html","материалы/подтемы/секция-1.-javascript/тема-№3/самое-простое-использование-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№3/создание-своей-html-страницы.html","материалы/подтемы/секция-1.-javascript/тема-№4/примитивные-типы-данных-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№4/установка-и-базовое-использование-node.js.html","материалы/подтемы/секция-1.-javascript/тема-№4/что-такое-node.js.html","материалы/подтемы/секция-1.-javascript/тема-№5/арифметические-операторы-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№5/логические-операторы-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№5/операторы-присваивания-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№5/операторы-работы-с-битами.html","материалы/подтемы/секция-1.-javascript/тема-№5/операторы-сравнения-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№5/определение-оператора-и-операнда.html","материалы/подтемы/секция-1.-javascript/тема-№5/приоритет-операторов-и-ассоциативность.html","материалы/подтемы/секция-1.-javascript/тема-№6/базовые-команды-git.html","материалы/подтемы/секция-1.-javascript/тема-№6/основные-понятия-git.html","материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-ветками-git.html","материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-удалёнными-репозиториями.html","материалы/подтемы/секция-1.-javascript/тема-№6/рекомендации-по-использованию-git.html","материалы/подтемы/секция-1.-javascript/тема-№6/файл-.gitignore.html","материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-git.html","материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-github.html","материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`else`.html","материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`if`.html","материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`switch`.html","материалы/подтемы/секция-1.-javascript/тема-№7/сравнение-`if`-и-`switch`.html","материалы/подтемы/секция-1.-javascript/тема-№7/тернарный-оператор.html","материалы/подтемы/секция-1.-javascript/тема-№7/цепочки-`else-if`.html","материалы/подтемы/секция-1.-javascript/тема-№7/что-такое-ветвление.html","материалы/подтемы/секция-1.-javascript/тема-№8/прерывание-и-пропуск-итераций.html","материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`do...while`.html","материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...in`-—-перебор-ключей-объекта.html","материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...of`-—-перебор-значений-итерируемых-объектов.html","материалы/подтемы/секция-1.-javascript/тема-№8/цикл-for.html","материалы/подтемы/секция-1.-javascript/тема-№8/цикл-while.html","материалы/подтемы/секция-1.-javascript/тема-№8/циклы-и-производительность.html","материалы/подтемы/секция-1.-javascript/тема-№8/что-такое-цикл.html","материалы/подтемы/секция-1.-javascript/тема-№9/возвращаемое-значение.html","материалы/подтемы/секция-1.-javascript/тема-№9/объявление-функции-(function-declaration).html","материалы/подтемы/секция-1.-javascript/тема-№9/параметры-и-аргументы.html","материалы/подтемы/секция-1.-javascript/тема-№9/рекурсия.html","материалы/подтемы/секция-1.-javascript/тема-№9/стрелочные-функции-(arrow-function).html","материалы/подтемы/секция-1.-javascript/тема-№9/функциональное-выражение-(function-expression).html","материалы/подтемы/секция-1.-javascript/тема-№9/что-такое-функция.html","материалы/подтемы/секция-1.-javascript/тема-№10/блочная-область-видимости.html","материалы/подтемы/секция-1.-javascript/тема-№10/вложенность-областей-видимости.html","материалы/подтемы/секция-1.-javascript/тема-№10/глобальная-область-видимости.html","материалы/подтемы/секция-1.-javascript/тема-№10/замыкания.html","материалы/подтемы/секция-1.-javascript/тема-№10/каррированные-функции.html","материалы/подтемы/секция-1.-javascript/тема-№10/практические-последствия-(var).html","материалы/подтемы/секция-1.-javascript/тема-№10/функциональная-область-видимости.html","материалы/подтемы/секция-1.-javascript/тема-№10/что-такое-область-видимости.html","материалы/подтемы/секция-1.-javascript/тема-№11/вложенные-структуры.html","материалы/подтемы/секция-1.-javascript/тема-№11/конструктор-массива-array.html","материалы/подтемы/секция-1.-javascript/тема-№11/массивы.html","материалы/подтемы/секция-1.-javascript/тема-№11/объекты.html","материалы/подтемы/секция-1.-javascript/тема-№11/оператор-rest.html","материалы/подтемы/секция-1.-javascript/тема-№11/практические-рекомендации-по-массивам-и-объектам.html","материалы/подтемы/секция-1.-javascript/тема-№11/преобразование-типов-(массивы-и-объекты)-через-json.html","материалы/подтемы/секция-1.-javascript/тема-№11/распаковка-(spread).html","материалы/подтемы/секция-1.-javascript/тема-№12/вкратце-о-rest.html","материалы/подтемы/секция-1.-javascript/тема-№12/гидратация.html","материалы/подтемы/секция-1.-javascript/тема-№12/маршрутизация-в-nodejs.html","материалы/подтемы/секция-1.-javascript/тема-№12/основы-сервера-на-nodejs.html","материалы/подтемы/секция-1.-javascript/тема-№12/отправка-файлов-с-сервера.html","материалы/подтемы/секция-1.-javascript/тема-№12/разница-между-web-1.0-и-web-2.0-в-контексте-nodejs.html","материалы/подтемы/секция-1.-javascript/тема-№12/web-1.0-(статический-веб).html","материалы/подтемы/секция-1.-javascript/тема-№12/web-2.0-(интерактивный-веб).html","материалы/подтемы/секция-2.-react/тема-№13/компоненты.html","материалы/подтемы/секция-2.-react/тема-№13/создание-и-запуск-react-проекта.html","материалы/подтемы/секция-2.-react/тема-№13/типичная-структура-react-приложения.html","материалы/подтемы/секция-2.-react/тема-№13/что-такое-react.html","материалы/подтемы/секция-2.-react/тема-№13/create-react-app-(cra).html","материалы/подтемы/секция-2.-react/тема-№13/jsx.html","материалы/подтемы/секция-2.-react/тема-№13/vite.html","материалы/подтемы/секция-2.-react/тема-№14/аудио-и-видео.html","материалы/подтемы/секция-2.-react/тема-№14/изображения.html","материалы/подтемы/секция-2.-react/тема-№14/импорт-функций-и-переменных-js.html","материалы/подтемы/секция-2.-react/тема-№14/как-react-обрабатывает-импорт-файлов.html","материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html","материалы/подтемы/секция-2.-react/тема-№14/практические-ошибки-и-как-их-избежать.html","материалы/подтемы/секция-2.-react/тема-№14/работа-со-стилями-и-файлами.html","материалы/подтемы/секция-2.-react/тема-№14/что-делать-с-файлами-в-папке-public.html","материалы/подтемы/секция-2.-react/тема-№14/шрифты.html","материалы/подтемы/секция-2.-react/тема-№14/env-файлы.html","материалы/подтемы/секция-2.-react/тема-№14/json-файлы.html","материалы/подтемы/секция-2.-react/тема-№14/svg.html","материалы/подтемы/секция-2.-react/тема-№15/передача-данных-через-props.html","материалы/подтемы/секция-2.-react/тема-№15/передача-функций-как-props.html","материалы/подтемы/секция-2.-react/тема-№15/состояние-и-хук-usestate.html","материалы/подтемы/секция-2.-react/тема-№15/хранение-данных-между-сессиями.html","материалы/подтемы/секция-2.-react/тема-№15/cookies-в-react-приложениях.html","материалы/подтемы/секция-2.-react/тема-№15/localstorage-и-sessionstorage.html","материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-хранения-значений.html","материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-dom-элементов.html","материалы/подтемы/секция-2.-react/тема-№16/когда-использовать-ref,-а-когда-—-state.html","материалы/подтемы/секция-2.-react/тема-№16/контролируемые-компоненты.html","материалы/подтемы/секция-2.-react/тема-№16/неконтролируемые-компоненты.html","материалы/подтемы/секция-2.-react/тема-№16/обработка-событий-в-react.html","материалы/подтемы/секция-2.-react/тема-№16/ограничения-и-рекомендации.html","материалы/подтемы/секция-2.-react/тема-№16/работа-с-формами.html","материалы/подтемы/секция-2.-react/тема-№16/что-такое-ref.html","материалы/подтемы/секция-2.-react/тема-№16/onchange.html","материалы/подтемы/секция-2.-react/тема-№16/onclick.html","материалы/подтемы/секция-2.-react/тема-№16/onfocus-и-onblur.html","материалы/подтемы/секция-2.-react/тема-№16/onsubmit.html","материалы/подтемы/секция-2.-react/тема-№17/пользовательские-hooks.html","материалы/подтемы/секция-2.-react/тема-№17/правила-использования-hooks.html","материалы/подтемы/секция-2.-react/тема-№17/что-такое-hooks.html","материалы/подтемы/секция-2.-react/тема-№17/usecontext.html","материалы/подтемы/секция-2.-react/тема-№17/useeffect.html","материалы/подтемы/секция-2.-react/тема-№18/вложенные-маршруты.html","материалы/подтемы/секция-2.-react/тема-№18/загрузка-данных-в-маршрутах.html","материалы/подтемы/секция-2.-react/тема-№18/обработка-несуществующих-маршрутов.html","материалы/подтемы/секция-2.-react/тема-№18/основные-компоненты-react-router.html","материалы/подтемы/секция-2.-react/тема-№18/параметры-маршрута.html","материалы/подтемы/секция-2.-react/тема-№18/программная-навигация.html","материалы/подтемы/секция-2.-react/тема-№18/что-такое-маршрутизация.html","материалы/подтемы/секция-2.-react/тема-№18/react-router-—-основная-библиотека.html","материалы/подтемы/секция-2.-react/тема-№19/асинхронность-и-react.html","материалы/подтемы/секция-2.-react/тема-№19/коллбэки.html","материалы/подтемы/секция-2.-react/тема-№19/промисы-(promise).html","материалы/подтемы/секция-2.-react/тема-№19/разница-между-await-и-then().html","материалы/подтемы/секция-2.-react/тема-№19/что-такое-асинхронность.html","материалы/подтемы/секция-2.-react/тема-№19/async-и-await.html","материалы/подтемы/секция-2.-react/тема-№20/базовые-типы-в-typescript.html","материалы/подтемы/секция-2.-react/тема-№20/настройка-проекта-с-typescript.html","материалы/подтемы/секция-2.-react/тема-№20/что-такое-typescript.html","материалы/файлы/pasted-image-20240923235323.png","материалы/файлы/pasted-image-20240923235323.html","материалы/файлы/pasted-image-20240928221620.png","материалы/файлы/pasted-image-20240928221620.html","материалы/файлы/pasted-image-20240928222139.png","материалы/файлы/pasted-image-20240928222139.html","материалы/файлы/pasted-image-20240928222237.png","материалы/файлы/pasted-image-20240928222237.html","материалы/файлы/pasted-image-20250912205946.png","материалы/файлы/pasted-image-20250912205946.html","материалы/файлы/pasted-image-20250912212732.png","материалы/файлы/pasted-image-20250912212732.html","материалы/файлы/pasted-image-20250912212810.png","материалы/файлы/pasted-image-20250912212810.html","материалы/файлы/pasted-image-20250912212840.png","материалы/файлы/pasted-image-20250912212840.html","материалы/файлы/pasted-image-20250912214611.png","материалы/файлы/pasted-image-20250912214611.html","материалы/файлы/pasted-image-20250912214624.png","материалы/файлы/pasted-image-20250912214624.html","материалы/файлы/pasted-image-20250912214643.png","материалы/файлы/pasted-image-20250912214643.html","материалы/файлы/pasted-image-20250912214649.png","материалы/файлы/pasted-image-20250912214649.html","материалы/файлы/pasted-image-20250912214653.png","материалы/файлы/pasted-image-20250912214653.html","материалы/файлы/pasted-image-20250917202240.png","материалы/файлы/pasted-image-20250917202240.html","материалы/файлы/pasted-image-20260207130627.png","материалы/файлы/pasted-image-20260207130627.html","материалы/файлы/qrcod_72k5.png","материалы/файлы/qrcod_72k5.html","index.html"],"attachments":["материалы/файлы/pasted-image-20240923235323.png","материалы/файлы/pasted-image-20240928221620.png","материалы/файлы/pasted-image-20240928222139.png","материалы/файлы/pasted-image-20240928222237.png","материалы/файлы/pasted-image-20250912205946.png","материалы/файлы/pasted-image-20250912212732.png","материалы/файлы/pasted-image-20250912212810.png","материалы/файлы/pasted-image-20250912212840.png","материалы/файлы/pasted-image-20250912214611.png","материалы/файлы/pasted-image-20250912214624.png","материалы/файлы/pasted-image-20250912214643.png","материалы/файлы/pasted-image-20250912214649.png","материалы/файлы/pasted-image-20250912214653.png","материалы/файлы/pasted-image-20250917202240.png","материалы/файлы/qrcod_72k5.png","site-lib/scripts/graph-wasm.wasm","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/scripts/graph-wasm.js","site-lib/scripts/graph-render-worker.js","site-lib/media/favicon.png","site-lib/styles/obsidian.css","site-lib/styles/global-variable-styles.css","site-lib/styles/main-styles.css","site-lib/rss.xml","материалы/заготовки-под-практики/react-project.zip","site-lib/fonts/c504db5c06caaf7cdfba.woff2","site-lib/fonts/01dcbad1bac635f9c9cd.woff2","материалы/файлы/pasted-image-20260207130627.png"],"allFiles":["задания/секция-2.-react/практика-№11.-игра-кликер.html","материалы/файлы/pasted-image-20260207130627.png","материалы/файлы/pasted-image-20260207130627.html","лекции/секция-2.-react/тема-№20.-основы-typescript.html","материалы/подтемы/секция-2.-react/тема-№20/что-такое-typescript.html","материалы/подтемы/секция-2.-react/тема-№20/базовые-типы-в-typescript.html","материалы/подтемы/секция-2.-react/тема-№20/настройка-проекта-с-typescript.html","лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html","материалы/подтемы/секция-2.-react/тема-№19/асинхронность-и-react.html","материалы/подтемы/секция-2.-react/тема-№19/разница-между-await-и-then().html","материалы/подтемы/секция-2.-react/тема-№19/async-и-await.html","материалы/подтемы/секция-2.-react/тема-№19/промисы-(promise).html","материалы/подтемы/секция-2.-react/тема-№19/коллбэки.html","материалы/подтемы/секция-2.-react/тема-№19/что-такое-асинхронность.html","лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html","лекции/секция-2.-react/тема-№16.-события-и-ref-в-react.html","лекции/секция-2.-react/тема-№18.-routers-в-react.html","материалы/подтемы/секция-2.-react/тема-№18/загрузка-данных-в-маршрутах.html","материалы/подтемы/секция-2.-react/тема-№18/обработка-несуществующих-маршрутов.html","материалы/подтемы/секция-2.-react/тема-№18/программная-навигация.html","материалы/подтемы/секция-2.-react/тема-№18/вложенные-маршруты.html","материалы/подтемы/секция-2.-react/тема-№18/параметры-маршрута.html","материалы/подтемы/секция-2.-react/тема-№18/основные-компоненты-react-router.html","материалы/подтемы/секция-2.-react/тема-№18/react-router-—-основная-библиотека.html","материалы/подтемы/секция-2.-react/тема-№18/что-такое-маршрутизация.html","материалы/подтемы/секция-2.-react/тема-№17/пользовательские-hooks.html","материалы/подтемы/секция-2.-react/тема-№17/usecontext.html","материалы/подтемы/секция-2.-react/тема-№17/useeffect.html","материалы/подтемы/секция-2.-react/тема-№17/правила-использования-hooks.html","материалы/подтемы/секция-2.-react/тема-№17/что-такое-hooks.html","лекции/секция-2.-react/тема-№17.-hooks-в-react.html","материалы/подтемы/секция-2.-react/тема-№16/когда-использовать-ref,-а-когда-—-state.html","материалы/подтемы/секция-2.-react/тема-№16/неконтролируемые-компоненты.html","материалы/подтемы/секция-2.-react/тема-№16/контролируемые-компоненты.html","материалы/подтемы/секция-2.-react/тема-№16/работа-с-формами.html","материалы/подтемы/секция-2.-react/тема-№16/ограничения-и-рекомендации.html","материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-хранения-значений.html","материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-dom-элементов.html","материалы/подтемы/секция-2.-react/тема-№16/что-такое-ref.html","материалы/подтемы/секция-2.-react/тема-№16/onfocus-и-onblur.html","материалы/подтемы/секция-2.-react/тема-№16/onsubmit.html","материалы/подтемы/секция-2.-react/тема-№16/onchange.html","материалы/подтемы/секция-2.-react/тема-№16/onclick.html","материалы/подтемы/секция-2.-react/тема-№16/обработка-событий-в-react.html","задания/секция-2.-react/практика-№10.-интерактивный-счётчик-с-изменением-темы.html","материалы/заготовки-под-практики/react-project.zip","лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html","материалы/подтемы/секция-2.-react/тема-№14/практические-ошибки-и-как-их-избежать.html","материалы/подтемы/секция-2.-react/тема-№14/импорт-функций-и-переменных-js.html","материалы/подтемы/секция-2.-react/тема-№14/работа-со-стилями-и-файлами.html","материалы/подтемы/секция-2.-react/тема-№14/что-делать-с-файлами-в-папке-public.html","материалы/подтемы/секция-2.-react/тема-№14/env-файлы.html","материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html","материалы/подтемы/секция-2.-react/тема-№14/json-файлы.html","материалы/подтемы/секция-2.-react/тема-№14/аудио-и-видео.html","материалы/подтемы/секция-2.-react/тема-№14/шрифты.html","материалы/подтемы/секция-2.-react/тема-№14/svg.html","материалы/подтемы/секция-2.-react/тема-№14/изображения.html","материалы/подтемы/секция-2.-react/тема-№14/как-react-обрабатывает-импорт-файлов.html","лекции/секция-2.-react/тема-№13.-основы-react.html","материалы/подтемы/секция-2.-react/тема-№15/cookies-в-react-приложениях.html","материалы/подтемы/секция-2.-react/тема-№15/localstorage-и-sessionstorage.html","материалы/подтемы/секция-2.-react/тема-№15/хранение-данных-между-сессиями.html","материалы/подтемы/секция-2.-react/тема-№15/передача-данных-через-props.html","материалы/подтемы/секция-2.-react/тема-№15/передача-функций-как-props.html","материалы/подтемы/секция-2.-react/тема-№15/состояние-и-хук-usestate.html","материалы/подтемы/секция-2.-react/тема-№13/типичная-структура-react-приложения.html","материалы/подтемы/секция-2.-react/тема-№13/vite.html","материалы/подтемы/секция-2.-react/тема-№13/create-react-app-(cra).html","материалы/подтемы/секция-2.-react/тема-№13/создание-и-запуск-react-проекта.html","материалы/подтемы/секция-2.-react/тема-№13/компоненты.html","материалы/подтемы/секция-2.-react/тема-№13/jsx.html","материалы/подтемы/секция-2.-react/тема-№13/что-такое-react.html","материалы/файлы/pasted-image-20240923235323.png","материалы/файлы/pasted-image-20240923235323.html","материалы/файлы/pasted-image-20250912212732.png","материалы/файлы/pasted-image-20250912212732.html","материалы/файлы/pasted-image-20250912205946.png","материалы/файлы/pasted-image-20250912205946.html","материалы/файлы/pasted-image-20240928222139.png","материалы/файлы/pasted-image-20240928222139.html","материалы/файлы/pasted-image-20250912214624.png","материалы/файлы/pasted-image-20250912214624.html","материалы/файлы/qrcod_72k5.png","материалы/файлы/qrcod_72k5.html","материалы/файлы/pasted-image-20250912214643.png","материалы/файлы/pasted-image-20250912214643.html","материалы/файлы/pasted-image-20250917202240.png","материалы/файлы/pasted-image-20250917202240.html","материалы/файлы/pasted-image-20240928221620.png","материалы/файлы/pasted-image-20240928221620.html","материалы/файлы/pasted-image-20250912214611.png","материалы/файлы/pasted-image-20250912214611.html","материалы/подтемы/секция-1.-javascript/тема-№4/примитивные-типы-данных-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№1/основные-платформы-мобильных-приложений.html","материалы/подтемы/секция-1.-javascript/тема-№3/основные-понятия-веб-страницы.html","материалы/подтемы/секция-1.-javascript/тема-№1/основные-типы-мобильных-приложений.html","материалы/подтемы/секция-1.-javascript/тема-№1/основные-технологии-для-разработки-мобильных-приложений.html","материалы/подтемы/секция-1.-javascript/тема-№3/создание-своей-html-страницы.html","материалы/подтемы/секция-1.-javascript/тема-№2/переменные-в-javascript.html","материалы/файлы/pasted-image-20250912212840.png","материалы/файлы/pasted-image-20250912212840.html","материалы/подтемы/секция-1.-javascript/тема-№2/что-такое-javascript,-история-появления.html","задания/секция-1.-javascript/практика-№9.-csr-с-гидратацией.-интерактивный-счётчик.html","материалы/подтемы/секция-1.-javascript/тема-№5/приоритет-операторов-и-ассоциативность.html","материалы/подтемы/секция-1.-javascript/тема-№5/операторы-работы-с-битами.html","материалы/подтемы/секция-1.-javascript/тема-№11/массивы.html","материалы/подтемы/секция-1.-javascript/тема-№12/гидратация.html","материалы/подтемы/секция-1.-javascript/тема-№5/операторы-присваивания-javascript.html","задания/секция-1.-javascript/практика-№8.-ssr-сервер-с-динамической-генерацией-страниц.html","материалы/подтемы/секция-1.-javascript/тема-№5/логические-операторы-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№6/основные-понятия-git.html","материалы/подтемы/секция-1.-javascript/тема-№12/разница-между-web-1.0-и-web-2.0-в-контексте-nodejs.html","материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`switch`.html","материалы/подтемы/секция-1.-javascript/тема-№6/базовые-команды-git.html","материалы/подтемы/секция-1.-javascript/тема-№4/что-такое-node.js.html","материалы/подтемы/секция-1.-javascript/тема-№11/объекты.html","материалы/подтемы/секция-1.-javascript/тема-№5/операторы-сравнения-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№10/замыкания.html","материалы/подтемы/секция-1.-javascript/тема-№7/сравнение-`if`-и-`switch`.html","материалы/подтемы/секция-1.-javascript/тема-№12/отправка-файлов-с-сервера.html","материалы/подтемы/секция-1.-javascript/тема-№3/базовая-работа-с-элементами-веб-страницы-через-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№2/правила-наименования-переменных-в-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№11/практические-рекомендации-по-массивам-и-объектам.html","материалы/подтемы/секция-1.-javascript/тема-№6/рекомендации-по-использованию-git.html","материалы/подтемы/секция-1.-javascript/тема-№5/арифметические-операторы-javascript.html","материалы/файлы/pasted-image-20250912212810.png","материалы/файлы/pasted-image-20250912212810.html","материалы/файлы/pasted-image-20250912214649.png","материалы/файлы/pasted-image-20250912214649.html","материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-ветками-git.html","материалы/подтемы/секция-1.-javascript/тема-№4/установка-и-базовое-использование-node.js.html","материалы/подтемы/секция-1.-javascript/тема-№7/цепочки-`else-if`.html","материалы/подтемы/секция-1.-javascript/тема-№12/маршрутизация-в-nodejs.html","материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-удалёнными-репозиториями.html","материалы/подтемы/секция-1.-javascript/тема-№11/вложенные-структуры.html","материалы/файлы/pasted-image-20250912214653.png","материалы/файлы/pasted-image-20250912214653.html","материалы/подтемы/секция-1.-javascript/тема-№8/циклы-и-производительность.html","материалы/подтемы/секция-1.-javascript/тема-№10/практические-последствия-(var).html","материалы/подтемы/секция-1.-javascript/тема-№11/оператор-rest.html","материалы/подтемы/секция-1.-javascript/тема-№7/тернарный-оператор.html","материалы/подтемы/секция-1.-javascript/тема-№8/прерывание-и-пропуск-итераций.html","материалы/подтемы/секция-1.-javascript/тема-№12/основы-сервера-на-nodejs.html","материалы/подтемы/секция-1.-javascript/тема-№2/базовое-понимание-синтаксиса-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№11/преобразование-типов-(массивы-и-объекты)-через-json.html","материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-git.html","материалы/подтемы/секция-1.-javascript/тема-№11/распаковка-(spread).html","задания/секция-1.-javascript/практика-№1.-простая-веб-страница-с-html.html","материалы/подтемы/секция-1.-javascript/тема-№9/рекурсия.html","материалы/подтемы/секция-1.-javascript/тема-№12/web-2.0-(интерактивный-веб).html","задания/секция-1.-javascript/практика-№7.-функции-для-работы-с-строками.html","материалы/подтемы/секция-1.-javascript/тема-№10/каррированные-функции.html","материалы/подтемы/секция-1.-javascript/тема-№3/самое-простое-использование-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№8/цикл-while.html","материалы/подтемы/секция-1.-javascript/тема-№11/конструктор-массива-array.html","материалы/подтемы/секция-1.-javascript/тема-№9/возвращаемое-значение.html","задания/секция-1.-javascript/практика-№5.-использование-ветвления..html","материалы/подтемы/секция-1.-javascript/тема-№9/стрелочные-функции-(arrow-function).html","материалы/подтемы/секция-1.-javascript/тема-№10/глобальная-область-видимости.html","материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...of`-—-перебор-значений-итерируемых-объектов.html","материалы/подтемы/секция-1.-javascript/тема-№10/вложенность-областей-видимости.html","материалы/подтемы/секция-1.-javascript/тема-№10/функциональная-область-видимости.html","материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...in`-—-перебор-ключей-объекта.html","материалы/подтемы/секция-1.-javascript/тема-№10/блочная-область-видимости.html","материалы/подтемы/секция-1.-javascript/тема-№9/функциональное-выражение-(function-expression).html","материалы/подтемы/секция-1.-javascript/тема-№9/параметры-и-аргументы.html","материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`if`.html","материалы/подтемы/секция-1.-javascript/тема-№12/web-1.0-(статический-веб).html","материалы/подтемы/секция-1.-javascript/тема-№6/файл-.gitignore.html","материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-github.html","материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`do...while`.html","материалы/подтемы/секция-1.-javascript/тема-№9/что-такое-функция.html","материалы/подтемы/секция-1.-javascript/тема-№8/цикл-for.html","материалы/подтемы/секция-1.-javascript/тема-№12/вкратце-о-rest.html","задания/секция-1.-javascript/практика-№4.-преобразование-типов.html","материалы/подтемы/секция-1.-javascript/тема-№9/объявление-функции-(function-declaration).html","материалы/подтемы/секция-1.-javascript/тема-№7/что-такое-ветвление.html","задания/секция-1.-javascript/практика-№3.-вывод-информации-о-себе-в-консоль..html","материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`else`.html","материалы/подтемы/секция-1.-javascript/тема-№8/что-такое-цикл.html","материалы/подтемы/секция-1.-javascript/тема-№10/что-такое-область-видимости.html","лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html","лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html","лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html","задания/секция-1.-javascript/практика-№2.-использование-git,-github.html","задания/секция-1.-javascript/практика-№6.-вывод-таблицы-умножения-с-помощью-цикла-for.html","лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html","лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html","лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html","лекции/секция-1.-javascript/тема-№6.-git,-github.html","лекции/секция-1.-javascript/тема-№2.-основы-javascript.html","лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№5/определение-оператора-и-операнда.html","лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html","лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html","материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html","материалы/файлы/pasted-image-20240928222237.png","материалы/файлы/pasted-image-20240928222237.html","лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html","index.html","site-lib/scripts/graph-wasm.wasm","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/fonts/c504db5c06caaf7cdfba.woff2","site-lib/fonts/01dcbad1bac635f9c9cd.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/scripts/graph-wasm.js","site-lib/scripts/graph-render-worker.js","site-lib/media/favicon.png","site-lib/styles/obsidian.css","site-lib/styles/global-variable-styles.css","site-lib/styles/main-styles.css"],"webpages":{"задания/секция-1.-javascript/практика-№1.-простая-веб-страница-с-html.html":{"title":"Практика №1. Простая веб-страница с HTML","icon":"","description":"В рамках этого задания вам необходимо добавить логику при нажатиях на кнопку к существующей веб-странице.Задания обязано быть сделано в собственной директории используя изначальный шаблон html файла из ресурсов index.html (может быть модернизирован) и внешний js файл в той же папке (создается самостоятельно).index.html&lt;!DOCTYPE html&gt;\n&lt;html lang=\"ru\"&gt;\n&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Изучаем JS в рамках html страницы&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt; Эта страница содержит JS код который выполняется на стороне клиента. &lt;br/&gt; &lt;button id=\"button-1\"&gt; Эта кнопка выводит сообщение в консоль &lt;/button&gt; &lt;button id=\"button-2\"&gt; Эта кнопка выводит оповещение в браузере &lt;/button&gt; &lt;br/&gt; &lt;button id=\"button-3\"&gt; Эта кнопка меняет цвет фона на красный &lt;/button&gt; &lt;button id=\"button-4\"&gt; Эта кнопка меняет цвет фона на белый &lt;/button&gt; &lt;br/&gt; &lt;textarea id=\"text-1\"&gt; &lt;/textarea&gt; &lt;br/&gt; &lt;button id=\"button-5\"&gt; Сложить число выше с числом 6 &lt;/button&gt; &lt;div id=\"answer\"&gt; ТУТ БУДЕТ ОТВЕТ &lt;/div&gt; &lt;/body&gt;\n&lt;/html&gt;\nНеобходимо добавить логику для кнопок:\nПервые две кнопки должны выводить информацию в консоль и в качестве оповещения в браузере.\nКнопки 3-4 должны менять цвет фона в соответствии с текстом кнопки\nКнопка 5 должна получить текст из текстового поля text-1, получить число из строки при помощи функции parseFloat, и проверить на NaN при помощи функции isNaN. Если это число - сложить с числом 6 и записать ответ в div с id answer.\nВам необходимо добавить дополнительное поле ввода для 5 кнопки.\nВ итоге пользователь должен вписать два числа в два поля и в итоге получить ответ сложениях этих двух чисел.На выполнение выделяется 1 практическая пара.\nГрадация баллов после дедлайна:\n1 пара: 50%\n2 пара: 0%\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Общее описание","level":2,"id":"Общее_описание_0"},{"heading":"Ресурсы","level":2,"id":"Ресурсы_0"},{"heading":"Техническое задание","level":2,"id":"Техническое_задание_0"},{"heading":"Дополнительная часть","level":2,"id":"Дополнительная_часть_0"},{"heading":"Время на выполнение","level":2,"id":"Время_на_выполнение_0"},{"heading":"Баллы","level":2,"id":"Баллы_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"задания/секция-1.-javascript/практика-№1.-простая-веб-страница-с-html.html","pathToRoot":"../..","attachments":[],"createdTime":1760434739260,"modifiedTime":1760434739260,"sourceSize":3318,"sourcePath":"Задания/Секция 1. JavaScript/Практика №1. Простая веб-страница с HTML.md","exportPath":"задания/секция-1.-javascript/практика-№1.-простая-веб-страница-с-html.html","showInTree":true,"treeOrder":2,"backlinks":["лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html"],"type":"markdown"},"задания/секция-1.-javascript/практика-№2.-использование-git,-github.html":{"title":"Практика №2. Использование git, github","icon":"","description":"В рамках этого задания вам необходимо загрузить код \"Практика №1\" в github организацию в виде нового репозитория.(пусто)Регистрируйтесь на <a data-tooltip-position=\"top\" aria-label=\"https://github.com\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com\" target=\"_self\">GitHub</a>, затем отправьте почту в <a data-tooltip-position=\"top\" aria-label=\"https://forms.yandex.ru/u/68c460fe90fa7b550e338c06\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://forms.yandex.ru/u/68c460fe90fa7b550e338c06\" target=\"_self\">яндекс формы</a>.\nВам должно будет прийти письмо с приглашением на вступление (Проверяйте указанную почту и/или оповещения в GitHub).Необходимо создать ПРИВАТНЫЙ репозиторий ВНУТРИ ОРГАНИЗАЦИИ.\nНазвание по следующему шаблону:\nГРУППА_ФАМИЛИЯ_НАЗВАНИЕ-ЗАДАНИЯ\nНапример:\nIS231-1_Ivanov_task1.На выполнение выделяется 1 практическая пара.\nГрадация баллов после дедлайна:\n1 пара: 0%\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Общее описание","level":2,"id":"Общее_описание_0"},{"heading":"Ресурсы","level":2,"id":"Ресурсы_0"},{"heading":"Техническое задание","level":2,"id":"Техническое_задание_0"},{"heading":"Время на выполнение","level":2,"id":"Время_на_выполнение_0"},{"heading":"Баллы","level":2,"id":"Баллы_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"задания/секция-1.-javascript/практика-№2.-использование-git,-github.html","pathToRoot":"../..","attachments":[],"createdTime":1760434713010,"modifiedTime":1760434713010,"sourceSize":1422,"sourcePath":"Задания/Секция 1. JavaScript/Практика №2. Использование git, github.md","exportPath":"задания/секция-1.-javascript/практика-№2.-использование-git,-github.html","showInTree":true,"treeOrder":3,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown"},"задания/секция-1.-javascript/практика-№3.-вывод-информации-о-себе-в-консоль..html":{"title":"Практика №3. Вывод информации о себе в консоль.","icon":"","description":"В рамках этого задания вам необходимо создать скрипт task3.js, который должен запускаться при помощи NodeJs.Задание обязано быть опубликовано в новом приватном репозитории организации GitHub с названием Группа_Фамилия_task-3-7.(пусто)Вам необходимо создать следующие переменные:\nгод рождения\nваш возраст\nваше имя\nработаете ли вы?\nВам необходимо вывести в консоль значения переменных и их типов данных.\nВы должны поменять значение возраста и вывести в консоль новый возраст.Используйте нужные ключевые слова и типы данных, при проверке вам необходимо обосновать выбор.На выполнение выделяется 1 практическая пара.\nГрадация баллов после дедлайна:\n1 пара: 50%\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Общее описание","level":2,"id":"Общее_описание_0"},{"heading":"Ресурсы","level":2,"id":"Ресурсы_0"},{"heading":"Техническое задание","level":2,"id":"Техническое_задание_0"},{"heading":"Время на выполнение","level":2,"id":"Время_на_выполнение_0"},{"heading":"Баллы","level":2,"id":"Баллы_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"задания/секция-1.-javascript/практика-№3.-вывод-информации-о-себе-в-консоль..html","pathToRoot":"../..","attachments":[],"createdTime":1760434716277,"modifiedTime":1760434716277,"sourceSize":1588,"sourcePath":"Задания/Секция 1. JavaScript/Практика №3. Вывод информации о себе в консоль..md","exportPath":"задания/секция-1.-javascript/практика-№3.-вывод-информации-о-себе-в-консоль..html","showInTree":true,"treeOrder":4,"backlinks":["лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html"],"type":"markdown"},"задания/секция-1.-javascript/практика-№4.-преобразование-типов.html":{"title":"Практика №4. Преобразование типов","icon":"","description":"В рамках этого задания вам необходимо модернизировать скрипт task4.js, который должен запускаться при помощи Node.js. Задание обязано быть опубликовано в существующем приватном репозитории организации GitHub с названием Группа_Фамилия_task-3-7.task4.jsconst booleanValue = false;\nconst numberValue = 20.20;\nconst stringValue = \"30\"; // Менять код ниже\nВам необходимо преобразовать значения переменных следующим образом: booleanValue — преобразовать в строку. numberValue — преобразовать в целое число, округлив в меньшую сторону (вниз). stringValue — преобразовать в число (числовой тип). После преобразования выведите в консоль исходное и преобразованное значение каждой переменной, а также тип данных каждого результата (используйте typeof). На выполнение выделяется 1 практическая пара.\nГрадация баллов после дедлайна: 1 пара: 0%\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Общее описание","level":2,"id":"Общее_описание_0"},{"heading":"Ресурсы","level":2,"id":"Ресурсы_0"},{"heading":"Техническое задание","level":2,"id":"Техническое_задание_0"},{"heading":"Время на выполнение","level":2,"id":"Время_на_выполнение_0"},{"heading":"Баллы","level":2,"id":"Баллы_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"задания/секция-1.-javascript/практика-№4.-преобразование-типов.html","pathToRoot":"../..","attachments":[],"createdTime":1760434721018,"modifiedTime":1760434721018,"sourceSize":1845,"sourcePath":"Задания/Секция 1. JavaScript/Практика №4. Преобразование типов.md","exportPath":"задания/секция-1.-javascript/практика-№4.-преобразование-типов.html","showInTree":true,"treeOrder":5,"backlinks":["лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html"],"type":"markdown"},"задания/секция-1.-javascript/практика-№5.-использование-ветвления..html":{"title":"Практика №5. Использование ветвления.","icon":"","description":"В рамках этого задания вам необходимо модернизировать скрипт task5.js, который должен запускаться при помощи Node.js. Задание обязано быть опубликовано в существующем приватном репозитории организации GitHub с названием Группа_Фамилия_task-3-7.task5.jsconst lower = -20;\nconst upper = 100;\nconst threshold = 30;\nlet a = Math.floor(Math.random() * (upper-lower+1)) + lower; // Пока не обращаем внимания, тут будет случайное число от -20 до 100\nlet greek = Math.floor(Math.random() * 11); // от 0 до 10 console.log(\"Текущее значение переменной a - \"+a); // Менять код ниже // Менять код ниже\nНеобходимо выполнить все три части. Для каждой части необходимо использовать разные методы ветвления.Создайте переменную partOne. partOne должен принять значение в зависимости от условия:\nЕсли a меньше threshold - это полный диапазон чисел от lower к upper (например в этом примере это должно быть число 120)\nЕсли a больше - это произведение a и threshold\nЕсли они равны - то это должна быть строчка \"Вам невероятно повезло!\"\nВо всех случаях необходимо вывести в консоль следующее:\nНовое значение partOne\nПо какому условию оно прошло\nКакая вероятность того что оно могло попасть в это условие\nВывести в консоль значение greek в греческой записи (1 - I, 2 - II, 5 - V)Вывести в консоль является ли значение a четным или нечетным.На выполнение выделяется 2 практических пары.\nГрадация баллов после дедлайна: 1 пара: 50%\n2 пара: 25%\n3 пара: 0%\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Общее описание","level":2,"id":"Общее_описание_0"},{"heading":"Ресурсы","level":2,"id":"Ресурсы_0"},{"heading":"Техническое задание","level":2,"id":"Техническое_задание_0"},{"heading":"Часть 1","level":3,"id":"Часть_1_0"},{"heading":"Часть 2","level":3,"id":"Часть_2_0"},{"heading":"Часть 3","level":3,"id":"Часть_3_0"},{"heading":"Время на выполнение","level":2,"id":"Время_на_выполнение_0"},{"heading":"Баллы","level":2,"id":"Баллы_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"задания/секция-1.-javascript/практика-№5.-использование-ветвления..html","pathToRoot":"../..","attachments":[],"createdTime":1760434733614,"modifiedTime":1760434733614,"sourceSize":2824,"sourcePath":"Задания/Секция 1. JavaScript/Практика №5. Использование ветвления..md","exportPath":"задания/секция-1.-javascript/практика-№5.-использование-ветвления..html","showInTree":true,"treeOrder":6,"backlinks":["лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"type":"markdown"},"задания/секция-1.-javascript/практика-№6.-вывод-таблицы-умножения-с-помощью-цикла-for.html":{"title":"Практика №6. Вывод таблицы умножения с помощью цикла for","icon":"","description":"В рамках этого задания вам необходимо создать скрипт task6.js, который должен запускаться при помощи Node.js. Задание обязано быть опубликовано в существующем приватном репозитории организации GitHub с названием Группа_Фамилия_task-3-7.(Пусто)Необходимо вывести в консоль таблицу умножения от 1х0 до 20х20. Формат произвольный, но таблицы должны быть с правильными отступами (т.е. числа должны отцентрованны по правому краю), а сами таблицы должны быть удобными для чтения.На выполнение выделяется 2 практических пары.\nГрадация баллов после дедлайна: 1 пара: 50%\n2 пара: 25%\n3 пара: 0%\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Общее описание","level":2,"id":"Общее_описание_0"},{"heading":"Ресурсы","level":2,"id":"Ресурсы_0"},{"heading":"Техническое задание","level":2,"id":"Техническое_задание_0"},{"heading":"Время на выполнение","level":2,"id":"Время_на_выполнение_0"},{"heading":"Баллы","level":2,"id":"Баллы_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"задания/секция-1.-javascript/практика-№6.-вывод-таблицы-умножения-с-помощью-цикла-for.html","pathToRoot":"../..","attachments":[],"createdTime":1760434712687,"modifiedTime":1760434712687,"sourceSize":1416,"sourcePath":"Задания/Секция 1. JavaScript/Практика №6. Вывод таблицы умножения с помощью цикла for.md","exportPath":"задания/секция-1.-javascript/практика-№6.-вывод-таблицы-умножения-с-помощью-цикла-for.html","showInTree":true,"treeOrder":7,"backlinks":["лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html"],"type":"markdown"},"задания/секция-1.-javascript/практика-№7.-функции-для-работы-с-строками.html":{"title":"Практика №7. Функции для работы с строками","icon":"","description":"В рамках этого задания вам необходимо создать модифицировать скрипт task7.js, который должен запускаться при помощи Node.js. Задание обязано быть опубликовано в существующем приватном репозитории организации GitHub с названием Группа_Фамилия_task-3-7.task7.js// Объявления функций\nconsole.log(\"Тут объявляются функции\")\n// ...\n// Тестирование функций\nconsole.log(\"Вызов функций\") console.log(\"Функция &lt;название функции&gt;\")\n// ...\nconsole.log(\"Функция &lt;название функции&gt;\")\n// ...\nВам необходимо объявить и реализовать три функции. Каждая функция должна иметь правильный JS нейминг и вызываться минимум три раза с разными параметрами.На вход подается строка, вернутся должна развернутая строка. (то есть в обратную сторону).\nЕсли на вход придет палиндром (необходимо игнорировать пробелы и регистр символов) - вывести сообщение в консоль об этом и вернуть исходную строку.\nпалиндром - число, буквосочетание, слово или текст, одинаково читающееся в обоих направлениях. Примеры: \"101\", \"Лёша на полке клопа нашёл\", \"Казак\".\nНа вход подается строка, вернутся должно число. Число - это количество гласных в строке (учитывайте оба регистра), латиница и кириллица.Создайте функции которая принимает пароль в качестве аргумента и возвращает&nbsp;true, если он соответствует следующим требованиям:\nДлина не менее 8 символов\nСодержит как минимум одну строчную, одну прописную букву и одну цифру\nНа выполнение выделяется 2 практических пары.\nГрадация баллов после дедлайна: 1 пара: 50%\n2 пара: 25%\n3 пара: 0%\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Общее описание","level":2,"id":"Общее_описание_0"},{"heading":"Ресурсы","level":2,"id":"Ресурсы_0"},{"heading":"Техническое задание","level":2,"id":"Техническое_задание_0"},{"heading":"Функция 1","level":3,"id":"Функция_1_0"},{"heading":"Функция 2","level":3,"id":"Функция_2_0"},{"heading":"Функция 3","level":3,"id":"Функция_3_0"},{"heading":"Время на выполнение","level":2,"id":"Время_на_выполнение_0"},{"heading":"Баллы","level":2,"id":"Баллы_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"задания/секция-1.-javascript/практика-№7.-функции-для-работы-с-строками.html","pathToRoot":"../..","attachments":[],"createdTime":1760434736816,"modifiedTime":1760434736816,"sourceSize":3090,"sourcePath":"Задания/Секция 1. JavaScript/Практика №7. Функции для работы с строками.md","exportPath":"задания/секция-1.-javascript/практика-№7.-функции-для-работы-с-строками.html","showInTree":true,"treeOrder":8,"backlinks":["лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"type":"markdown"},"задания/секция-1.-javascript/практика-№8.-ssr-сервер-с-динамической-генерацией-страниц.html":{"title":"Практика №8. SSR-сервер с динамической генерацией страниц","icon":"","description":"В рамках этого задания вам необходимо создать сервер на NodeJS, который реализует Server-Side Rendering (SSR) — динамическую генерацию HTML-страниц на основе данных, хранящихся в памяти. Сервер должен отдавать полностью готовые HTML-страницы при запросах к корневому пути / и к динамическому пути /task/:id, без использования клиентского JavaScript для рендеринга. Все данные формируются на сервере, ответы содержат структурированный HTML с встроенными стилями и ссылками. Никаких внешних библиотек — только встроенные модули NodeJS: http, path.Задание обязано быть опубликовано в новом приватном репозитории организации GitHub с названием Группа_Фамилия_task-8.(пусто)Создайте HTTP-сервер на NodeJS, который:\nGET / — отдаёт главную страницу со списком всех задач GET /task/:id — отдаёт страницу одной задачи, где :id — целое число (например, /task/2)\nconst tasks = [ { id: 1, title: 'Выучить JavaScript', completed: false }, { id: 2, title: 'Создать Todo-приложение', completed: true }, { id: 3, title: 'Настроить сервер', completed: false }\n]; Заголовком &lt;h1&gt;Мои задачи&lt;/h1&gt;\nСписком задач в &lt;ul&gt; — каждый элемент &lt;li&gt; содержит название задачи\nДля задач с completed: true — добавлять класс completed в &lt;li&gt;\nВнутренним стилем в &lt;head&gt;: .completed { text-decoration: line-through; color: #999; } Пустым &lt;script&gt;&lt;/script&gt; в конце &lt;body&gt; (для имитации гидратации)\nКорректным &lt;!DOCTYPE html&gt; и мета-тегом кодировки\nContent-Type: text/html Заголовком &lt;h1&gt;Задача #&lt;id&gt;&lt;/h1&gt;\nДанными задачи: &lt;p&gt;&lt;strong&gt;Название:&lt;/strong&gt; &lt;span&gt;...&lt;/span&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Статус:&lt;/strong&gt; &lt;span&gt;Выполнена&lt;/span&gt;&lt;/p&gt; или &lt;p&gt;&lt;strong&gt;Статус:&lt;/strong&gt; &lt;span&gt;Не выполнена&lt;/span&gt;&lt;/p&gt; Кнопкой «Назад» с ссылкой на /\nКорректным &lt;!DOCTYPE html&gt; и мета-тегом кодировки\nContent-Type: text/html Если :id не существует в массиве — отдаётся страница 404 с содержимым: &lt;h1&gt;404&lt;/h1&gt;\n&lt;p&gt;Задача с таким ID не найдена.&lt;/p&gt; Если :id — не число или пустой — отдаётся 404\nДля всех остальных путей (например, /about, /api/users) — отдаётся 404\nНе используйте fs.readFileSync() — только асинхронные методы (fs.readFile() не требуется, так как данные в памяти) Используйте только встроенные модули: http, path\nНикаких внешних библиотек (Express, etc.)\nНикакого клиентского рендеринга — все HTML генерируется на сервере\nНикаких fetch() или innerHTML — страницы должны быть полностью готовы при приходе запроса\nУстанавливайте правильный Content-Type для всех ответов\nОбработка путей — через req.url и строковую манипуляцию (split(), startsWith(), parseInt())\nСервер должен слушать порт 3000\nЗапрос: GET /\nОтвет: &lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Задачи&lt;/title&gt; &lt;style&gt; .completed { text-decoration: line-through; color: #999; } &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt; &lt;h1&gt;Мои задачи&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Выучить JavaScript&lt;/li&gt; &lt;li class=\"completed\"&gt;Создать Todo-приложение&lt;/li&gt; &lt;li&gt;Настроить сервер&lt;/li&gt; &lt;/ul&gt; &lt;script&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nЗапрос: GET /task/2\nОтвет: &lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Задача #2&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt; &lt;h1&gt;Задача #2&lt;/h1&gt; &lt;p&gt;&lt;strong&gt;Название:&lt;/strong&gt; &lt;span&gt;Создать Todo-приложение&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Статус:&lt;/strong&gt; &lt;span&gt;Выполнена&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=\"/\"&gt;← Назад&lt;/a&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nЗапрос: GET /task/999\nОтвет: &lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;404&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt; &lt;h1&gt;404&lt;/h1&gt; &lt;p&gt;Задача с таким ID не найдена.&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nНа выполнение выделяется 3 практических пары.\nГрадация баллов после дедлайна: 1 пара: 50% 2 пара: 25% 3 пара: 0% ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Общее описание","level":2,"id":"Общее_описание_0"},{"heading":"Ресурсы","level":2,"id":"Ресурсы_0"},{"heading":"Техническое задание","level":2,"id":"Техническое_задание_0"},{"heading":"1. Обрабатывает два маршрута:","level":3,"id":"1._Обрабатывает_два_маршрута_0"},{"heading":"2. Использует фиксированный массив задач:","level":3,"id":"2._Использует_фиксированный_массив_задач_0"},{"heading":"3. Для / должен отдавать HTML-страницу с:","level":3,"id":"3._Для_`/`_должен_отдавать_HTML-страницу_с_0"},{"heading":"4. Для /task/:id должен отдавать HTML-страницу с:","level":3,"id":"4._Для_`/task/id`_должен_отдавать_HTML-страницу_с_0"},{"heading":"5. Обработка ошибок:","level":3,"id":"5._Обработка_ошибок_0"},{"heading":"6. Технические требования:","level":3,"id":"6._Технические_требования_0"},{"heading":"7. Примеры ответов:","level":3,"id":"7._Примеры_ответов_0"},{"heading":"Время на выполнение","level":2,"id":"Время_на_выполнение_0"},{"heading":"Баллы","level":2,"id":"Баллы_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"задания/секция-1.-javascript/практика-№8.-ssr-сервер-с-динамической-генерацией-страниц.html","pathToRoot":"../..","attachments":[],"createdTime":1760434757997,"modifiedTime":1760434757997,"sourceSize":6334,"sourcePath":"Задания/Секция 1. JavaScript/Практика №8. SSR-сервер с динамической генерацией страниц.md","exportPath":"задания/секция-1.-javascript/практика-№8.-ssr-сервер-с-динамической-генерацией-страниц.html","showInTree":true,"treeOrder":9,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown"},"лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html":{"title":"Тема №1. Как создаются мобильные приложения","icon":"","description":"Вводная тема, посвящённая базовым понятиям разработки мобильных приложений. <a data-href=\"Основные платформы мобильных приложений\" href=\"материалы/подтемы/секция-1.-javascript/тема-№1/основные-платформы-мобильных-приложений.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Основные платформы мобильных приложений</a>\n<br><a data-href=\"Основные типы мобильных приложений\" href=\"материалы/подтемы/секция-1.-javascript/тема-№1/основные-типы-мобильных-приложений.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Основные типы мобильных приложений</a>\n<br><a data-href=\"Основные технологии для разработки мобильных приложений\" href=\"материалы/подтемы/секция-1.-javascript/тема-№1/основные-технологии-для-разработки-мобильных-приложений.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Основные технологии для разработки мобильных приложений</a>\n(Пусто)<br><a data-href=\"Тема №2. Основы JavaScript\" href=\"лекции/секция-1.-javascript/тема-№2.-основы-javascript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №2. Основы JavaScript</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№1/основные-платформы-мобильных-приложений.html","материалы/подтемы/секция-1.-javascript/тема-№1/основные-типы-мобильных-приложений.html","материалы/подтемы/секция-1.-javascript/тема-№1/основные-технологии-для-разработки-мобильных-приложений.html","лекции/секция-1.-javascript/тема-№2.-основы-javascript.html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html","pathToRoot":"../..","attachments":[],"createdTime":1760434687739,"modifiedTime":1760434687739,"sourceSize":608,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №1. Как создаются мобильные приложения.md","exportPath":"лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html","showInTree":true,"treeOrder":15,"backlinks":["index.html"],"type":"markdown"},"лекции/секция-1.-javascript/тема-№2.-основы-javascript.html":{"title":"Тема №2. Основы JavaScript","icon":"","description":"В этой теме вы познакомитесь с основами JavaScript — языком, лежащим в основе интерактивности современных веб- и мобильных приложений. Рассмотрите историю появления языка, его ключевые характеристики и области применения. Вы узнаете, как устроен простейший код на JavaScript, изучите базовые элементы синтаксиса, а также детально разберёте переменные — их объявление и правила именования. Всё это — фундамент для дальнейшего изучения разработки мобильных приложений на JavaScript-основах.\n<a data-href=\"Что такое JavaScript, история появления\" href=\"материалы/подтемы/секция-1.-javascript/тема-№2/что-такое-javascript,-история-появления.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Что такое JavaScript, история появления</a>\n<br><a data-href=\"Базовое понимание синтаксиса JavaScript\" href=\"материалы/подтемы/секция-1.-javascript/тема-№2/базовое-понимание-синтаксиса-javascript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Базовое понимание синтаксиса JavaScript</a>\n(Пусто)<br><a data-href=\"Тема №3. Использование JavaScript в браузере\" href=\"лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №3. Использование JavaScript в браузере</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№2/что-такое-javascript,-история-появления.html","материалы/подтемы/секция-1.-javascript/тема-№2/базовое-понимание-синтаксиса-javascript.html","лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-1.-javascript/тема-№2.-основы-javascript.html","pathToRoot":"../..","attachments":[],"createdTime":1760434708376,"modifiedTime":1760434708376,"sourceSize":1252,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №2. Основы JavaScript.md","exportPath":"лекции/секция-1.-javascript/тема-№2.-основы-javascript.html","showInTree":true,"treeOrder":16,"backlinks":["лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html"],"type":"markdown"},"лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html":{"title":"Тема №3. Использование JavaScript в браузере","icon":"","description":"В этой теме вы познакомитесь с практическим применением JavaScript в контексте веб-страниц: научитесь использовать консоль разработчика для тестирования кода, поймёте структуру HTML и роль DOM, освоите базовые способы взаимодействия с элементами страницы через JavaScript — получение, изменение содержимого и стилей. Вы создадите первую HTML-страницу с подключённым JavaScript, изучите корректные способы интеграции скриптов и назначения обработчиков событий, избегая устаревших практик.\n<a data-href=\"Самое простое использование JavaScript\" href=\"материалы/подтемы/секция-1.-javascript/тема-№3/самое-простое-использование-javascript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Самое простое использование JavaScript</a>\n<br><a data-href=\"Основные понятия веб страницы\" href=\"материалы/подтемы/секция-1.-javascript/тема-№3/основные-понятия-веб-страницы.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Основные понятия веб страницы</a>\n<br><a data-href=\"Базовая работа с элементами веб страницы через JavaScript\" href=\"материалы/подтемы/секция-1.-javascript/тема-№3/базовая-работа-с-элементами-веб-страницы-через-javascript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Базовая работа с элементами веб страницы через JavaScript</a>\n<br><a data-href=\"Создание своей HTML страницы\" href=\"материалы/подтемы/секция-1.-javascript/тема-№3/создание-своей-html-страницы.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Создание своей HTML страницы</a> <br><a data-href=\"Практика №1. Простая веб-страница с HTML\" href=\"задания/секция-1.-javascript/практика-№1.-простая-веб-страница-с-html.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Практика №1. Простая веб-страница с HTML</a>\n<br><a data-href=\"Тема №4. Node.JS, примитивные типы данных JavaScript\" href=\"лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №4. Node.JS, примитивные типы данных JavaScript</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№3/самое-простое-использование-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№3/основные-понятия-веб-страницы.html","материалы/подтемы/секция-1.-javascript/тема-№3/базовая-работа-с-элементами-веб-страницы-через-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№3/создание-своей-html-страницы.html","задания/секция-1.-javascript/практика-№1.-простая-веб-страница-с-html.html","лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html","pathToRoot":"../..","attachments":[],"createdTime":1760434713832,"modifiedTime":1760434713832,"sourceSize":1462,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №3. Использование JavaScript в браузере.md","exportPath":"лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html","showInTree":true,"treeOrder":17,"backlinks":["лекции/секция-1.-javascript/тема-№2.-основы-javascript.html"],"type":"markdown"},"лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html":{"title":"Тема №4. Node.JS, примитивные типы данных JavaScript","icon":"","description":"В этой теме вы познакомитесь с Node.js — средой выполнения JavaScript вне браузера, и углубитесь в изучение примитивных типов данных JavaScript — фундаментальных строительных блоков любого приложения. Вы узнаете, как Node.js расширяет возможности JavaScript для серверной разработки, и научитесь работать с основными типами: числа, строки, логические значения, null, undefined, symbol и bigint. Это знание необходимо для дальнейшего понимания структур данных, функций и работы с API в мобильных приложениях, использующих JavaScript/TypeScript.\n<a data-href=\"Что такое Node.js\" href=\"материалы/подтемы/секция-1.-javascript/тема-№4/что-такое-node.js.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Что такое Node.js</a>\n<br><a data-href=\"Установка и базовое использование Node.js\" href=\"материалы/подтемы/секция-1.-javascript/тема-№4/установка-и-базовое-использование-node.js.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Установка и базовое использование Node.js</a>\n<br><a data-href=\"Примитивные типы данных JavaScript\" href=\"материалы/подтемы/секция-1.-javascript/тема-№4/примитивные-типы-данных-javascript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Примитивные типы данных JavaScript</a> <br><a data-href=\"Практика №3. Вывод информации о себе в консоль.\" href=\"задания/секция-1.-javascript/практика-№3.-вывод-информации-о-себе-в-консоль..html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Практика №3. Вывод информации о себе в консоль.</a>\n<br><a data-href=\"Практика №4. Преобразование типов\" href=\"задания/секция-1.-javascript/практика-№4.-преобразование-типов.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Практика №4. Преобразование типов</a>\n<br><a data-href=\"Тема №5. Операторы и операции в JavaScript\" href=\"лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №5. Операторы и операции в JavaScript</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№4/что-такое-node.js.html","материалы/подтемы/секция-1.-javascript/тема-№4/установка-и-базовое-использование-node.js.html","материалы/подтемы/секция-1.-javascript/тема-№4/примитивные-типы-данных-javascript.html","задания/секция-1.-javascript/практика-№3.-вывод-информации-о-себе-в-консоль..html","задания/секция-1.-javascript/практика-№4.-преобразование-типов.html","лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html","pathToRoot":"../..","attachments":[],"createdTime":1760434713938,"modifiedTime":1760434713938,"sourceSize":1463,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №4. Node.JS, примитивные типы данных JavaScript.md","exportPath":"лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html","showInTree":true,"treeOrder":18,"backlinks":["лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html"],"type":"markdown"},"лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html":{"title":"Тема №5. Операторы и операции в JavaScript","icon":"","description":"В этой теме вы изучите основные операторы и операции языка JavaScript, которые позволяют выполнять вычисления, сравнивать значения, управлять логикой программы и изменять данные. Понимание операторов — база для написания условий, циклов и обработки данных в мобильных приложениях. Особое внимание уделено особенностям JavaScript: неявному приведению типов, различиям между строгим и нестрогим сравнением, а также операторам присваивания и распространения.\n<a data-href=\"Определение оператора и операнда\" href=\"материалы/подтемы/секция-1.-javascript/тема-№5/определение-оператора-и-операнда.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Определение оператора и операнда</a>\n<br><a data-href=\"Арифметические операторы JavaScript\" href=\"материалы/подтемы/секция-1.-javascript/тема-№5/арифметические-операторы-javascript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Арифметические операторы JavaScript</a>\n<br><a data-href=\"Операторы сравнения JavaScript\" href=\"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-сравнения-javascript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Операторы сравнения JavaScript</a>\n<br><a data-href=\"Логические операторы JavaScript\" href=\"материалы/подтемы/секция-1.-javascript/тема-№5/логические-операторы-javascript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Логические операторы JavaScript</a>\n<br><a data-href=\"Операторы присваивания JavaScript\" href=\"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-присваивания-javascript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Операторы присваивания JavaScript</a>\n<br><a data-href=\"Операторы работы с битами\" href=\"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-работы-с-битами.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Операторы работы с битами</a>\n<br><a data-href=\"Приоритет операторов и ассоциативность\" href=\"материалы/подтемы/секция-1.-javascript/тема-№5/приоритет-операторов-и-ассоциативность.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Приоритет операторов и ассоциативность</a>\n(Пусто)<br><a data-href=\"Тема №6. Git, GitHub\" href=\"лекции/секция-1.-javascript/тема-№6.-git,-github.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №6. Git, GitHub</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№5/определение-оператора-и-операнда.html","материалы/подтемы/секция-1.-javascript/тема-№5/арифметические-операторы-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№5/операторы-сравнения-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№5/логические-операторы-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№5/операторы-присваивания-javascript.html","материалы/подтемы/секция-1.-javascript/тема-№5/операторы-работы-с-битами.html","материалы/подтемы/секция-1.-javascript/тема-№5/приоритет-операторов-и-ассоциативность.html","лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html","pathToRoot":"../..","attachments":[],"createdTime":1760434713552,"modifiedTime":1760434713552,"sourceSize":1455,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №5. Операторы и операции в JavaScript.md","exportPath":"лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html","showInTree":true,"treeOrder":19,"backlinks":["лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html"],"type":"markdown"},"лекции/секция-1.-javascript/тема-№6.-git,-github.html":{"title":"Тема №6. Git, GitHub","icon":"","description":"В этой теме вы познакомитесь с системой контроля версий Git и платформой GitHub — основными инструментами для управления кодом в командной разработке. Изучите базовые команды для отслеживания изменений, создания коммитов и взаимодействия с удалённым репозиторием. Это необходимо для совместной работы над мобильными приложениями, а также для хранения и публикации вашего кода.\n<a data-href=\"Что такое Git\" href=\"материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-git.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Что такое Git</a>\n<br><a data-href=\"Основные понятия Git\" href=\"материалы/подтемы/секция-1.-javascript/тема-№6/основные-понятия-git.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Основные понятия Git</a>\n<br><a data-href=\"Базовые команды Git\" href=\"материалы/подтемы/секция-1.-javascript/тема-№6/базовые-команды-git.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Базовые команды Git</a>\n<br><a data-href=\"Работа с ветками Git\" href=\"материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-ветками-git.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Работа с ветками Git</a>\n<br><a data-href=\"Что такое GitHub\" href=\"материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-github.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Что такое GitHub</a>\n<br><a data-href=\"Работа с удалёнными репозиториями\" href=\"материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-удалёнными-репозиториями.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Работа с удалёнными репозиториями</a>\n<br><a data-href=\"Файл .gitignore\" href=\"материалы/подтемы/секция-1.-javascript/тема-№6/файл-.gitignore.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Файл .gitignore</a>\n<br><a data-href=\"Рекомендации по использованию Git\" href=\"материалы/подтемы/секция-1.-javascript/тема-№6/рекомендации-по-использованию-git.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Рекомендации по использованию Git</a> <br><a data-href=\"Практика №2. Использование git, github\" href=\"задания/секция-1.-javascript/практика-№2.-использование-git,-github.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Практика №2. Использование git, github</a>\n<br><a data-href=\"Тема №7. Ветвление в JavaScript\" href=\"лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №7. Ветвление в JavaScript</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-git.html","материалы/подтемы/секция-1.-javascript/тема-№6/основные-понятия-git.html","материалы/подтемы/секция-1.-javascript/тема-№6/базовые-команды-git.html","материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-ветками-git.html","материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-github.html","материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-удалёнными-репозиториями.html","материалы/подтемы/секция-1.-javascript/тема-№6/файл-.gitignore.html","материалы/подтемы/секция-1.-javascript/тема-№6/рекомендации-по-использованию-git.html","задания/секция-1.-javascript/практика-№2.-использование-git,-github.html","лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-1.-javascript/тема-№6.-git,-github.html","pathToRoot":"../..","attachments":[],"createdTime":1760434710137,"modifiedTime":1760434710137,"sourceSize":1299,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №6. Git, GitHub.md","exportPath":"лекции/секция-1.-javascript/тема-№6.-git,-github.html","showInTree":true,"treeOrder":20,"backlinks":["лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html"],"type":"markdown"},"лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html":{"title":"Тема №7. Ветвление в JavaScript","icon":"","description":"В этой теме вы изучите механизмы ветвления в JavaScript — основу логического управления потоком выполнения программы. Вы научитесь использовать условные конструкции для принятия решений на основе данных, что критически важно для реализации интерактивности.\n<a data-href=\"Что такое ветвление\" href=\"материалы/подтемы/секция-1.-javascript/тема-№7/что-такое-ветвление.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Что такое ветвление</a>\n<br><a data-href=\"Оператор `if`\" href=\"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`if`.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Оператор `if`</a>\n<br><a data-href=\"Оператор `else`\" href=\"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`else`.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Оператор `else`</a>\n<br><a data-href=\"Цепочки `else if`\" href=\"материалы/подтемы/секция-1.-javascript/тема-№7/цепочки-`else-if`.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Цепочки `else if`</a>\n<br><a data-href=\"Тернарный оператор\" href=\"материалы/подтемы/секция-1.-javascript/тема-№7/тернарный-оператор.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тернарный оператор</a>\n<br><a data-href=\"Оператор `switch`\" href=\"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`switch`.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Оператор `switch`</a>\n<br><a data-href=\"Сравнение `if` и `switch`\" href=\"материалы/подтемы/секция-1.-javascript/тема-№7/сравнение-`if`-и-`switch`.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Сравнение `if` и `switch`</a> <br><a data-href=\"Практика №5. Использование ветвления.\" href=\"задания/секция-1.-javascript/практика-№5.-использование-ветвления..html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Практика №5. Использование ветвления.</a>\n<br><a data-href=\"Тема №8. Циклы в JavaScript\" href=\"лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №8. Циклы в JavaScript</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№7/что-такое-ветвление.html","материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`if`.html","материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`else`.html","материалы/подтемы/секция-1.-javascript/тема-№7/цепочки-`else-if`.html","материалы/подтемы/секция-1.-javascript/тема-№7/тернарный-оператор.html","материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`switch`.html","материалы/подтемы/секция-1.-javascript/тема-№7/сравнение-`if`-и-`switch`.html","задания/секция-1.-javascript/практика-№5.-использование-ветвления..html","лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html","pathToRoot":"../..","attachments":[],"createdTime":1760434701045,"modifiedTime":1760434701046,"sourceSize":980,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №7. Ветвление в JavaScript.md","exportPath":"лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html","showInTree":true,"treeOrder":21,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown"},"лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html":{"title":"Тема №8. Циклы в JavaScript","icon":"","description":"В этой теме вы изучите циклические конструкции языка JavaScript — фундаментальный механизм для повторения действий. Поймёте, как организовать итерации над данными, что необходимо для обработки списков, массивов и других структур, используемых в приложениях любого типа.\n<a data-href=\"Что такое цикл\" href=\"материалы/подтемы/секция-1.-javascript/тема-№8/что-такое-цикл.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Что такое цикл</a>\n<br><a data-href=\"Цикл for\" href=\"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-for.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Цикл for</a>\n<br><a data-href=\"Цикл while\" href=\"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-while.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Цикл while</a>\n<br><a data-href=\"Прерывание и пропуск итераций\" href=\"материалы/подтемы/секция-1.-javascript/тема-№8/прерывание-и-пропуск-итераций.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Прерывание и пропуск итераций</a>\n<br><a data-href=\"Циклы и производительность\" href=\"материалы/подтемы/секция-1.-javascript/тема-№8/циклы-и-производительность.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Циклы и производительность</a> <br><a data-href=\"Практика №6. Вывод таблицы умножения с помощью цикла for\" href=\"задания/секция-1.-javascript/практика-№6.-вывод-таблицы-умножения-с-помощью-цикла-for.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Практика №6. Вывод таблицы умножения с помощью цикла for</a>\n<br><a data-href=\"Тема №9. Функции в JavaScript\" href=\"лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №9. Функции в JavaScript</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№8/что-такое-цикл.html","материалы/подтемы/секция-1.-javascript/тема-№8/цикл-for.html","материалы/подтемы/секция-1.-javascript/тема-№8/цикл-while.html","материалы/подтемы/секция-1.-javascript/тема-№8/прерывание-и-пропуск-итераций.html","материалы/подтемы/секция-1.-javascript/тема-№8/циклы-и-производительность.html","задания/секция-1.-javascript/практика-№6.-вывод-таблицы-умножения-с-помощью-цикла-for.html","лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html","pathToRoot":"../..","attachments":[],"createdTime":1760434700925,"modifiedTime":1760434700925,"sourceSize":980,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №8. Циклы в JavaScript.md","exportPath":"лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html","showInTree":true,"treeOrder":22,"backlinks":["лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"type":"markdown"},"лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html":{"title":"Тема №9. Функции в JavaScript","icon":"","description":"В этой теме вы изучите функции — основной механизм инкапсуляции логики в JavaScript. Поймёте, как объявлять, вызывать и передавать данные через функции, а также познакомитесь с разными способами их определения. Это фундамент для организации кода в любом приложении, включая мобильные, где функции используются для обработки событий, работы с данными и управления состоянием интерфейса.\n<a data-href=\"Что такое функция\" href=\"материалы/подтемы/секция-1.-javascript/тема-№9/что-такое-функция.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Что такое функция</a>\n<br><a data-href=\"Объявление функции (Function Declaration)\" href=\"материалы/подтемы/секция-1.-javascript/тема-№9/объявление-функции-(function-declaration).html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Объявление функции (Function Declaration)</a>\n<br><a data-href=\"Функциональное выражение (Function Expression)\" href=\"материалы/подтемы/секция-1.-javascript/тема-№9/функциональное-выражение-(function-expression).html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Функциональное выражение (Function Expression)</a>\n<br><a data-href=\"Стрелочные функции (Arrow Function)\" href=\"материалы/подтемы/секция-1.-javascript/тема-№9/стрелочные-функции-(arrow-function).html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Стрелочные функции (Arrow Function)</a>\n<br><a data-href=\"Параметры и аргументы\" href=\"материалы/подтемы/секция-1.-javascript/тема-№9/параметры-и-аргументы.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Параметры и аргументы</a>\n<br><a data-href=\"Возвращаемое значение\" href=\"материалы/подтемы/секция-1.-javascript/тема-№9/возвращаемое-значение.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Возвращаемое значение</a>\n<br><a data-href=\"Рекурсия\" href=\"материалы/подтемы/секция-1.-javascript/тема-№9/рекурсия.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Рекурсия</a> <br><a data-href=\"Практика №7. Функции для работы с строками\" href=\"задания/секция-1.-javascript/практика-№7.-функции-для-работы-с-строками.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Практика №7. Функции для работы с строками</a>\n<br><a data-href=\"Тема №10. Область видимости в JavaScript\" href=\"лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №10. Область видимости в JavaScript</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№9/что-такое-функция.html","материалы/подтемы/секция-1.-javascript/тема-№9/объявление-функции-(function-declaration).html","материалы/подтемы/секция-1.-javascript/тема-№9/функциональное-выражение-(function-expression).html","материалы/подтемы/секция-1.-javascript/тема-№9/стрелочные-функции-(arrow-function).html","материалы/подтемы/секция-1.-javascript/тема-№9/параметры-и-аргументы.html","материалы/подтемы/секция-1.-javascript/тема-№9/возвращаемое-значение.html","материалы/подтемы/секция-1.-javascript/тема-№9/рекурсия.html","задания/секция-1.-javascript/практика-№7.-функции-для-работы-с-строками.html","лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html","pathToRoot":"../..","attachments":[],"createdTime":1760434711017,"modifiedTime":1760434711018,"sourceSize":1353,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №9. Функции в JavaScript.md","exportPath":"лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html","showInTree":true,"treeOrder":23,"backlinks":["лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html"],"type":"markdown"},"лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html":{"title":"Тема №10. Область видимости в JavaScript","icon":"","description":"В этой теме вы изучите область видимости переменных — механизм, определяющий, где в коде доступны объявленные переменные и функции. Поймёте разницу между глобальной, функциональной и блочной областью видимости, а также как это влияет на структуру и надёжность кода. Это ключевое понимание для предотвращения ошибок при работе с переменными в любых приложениях, включая мобильные.\n<a data-href=\"Что такое область видимости\" href=\"материалы/подтемы/секция-1.-javascript/тема-№10/что-такое-область-видимости.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Что такое область видимости</a>\n<br><a data-href=\"Глобальная область видимости\" href=\"материалы/подтемы/секция-1.-javascript/тема-№10/глобальная-область-видимости.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Глобальная область видимости</a>\n<br><a data-href=\"Функциональная область видимости\" href=\"материалы/подтемы/секция-1.-javascript/тема-№10/функциональная-область-видимости.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Функциональная область видимости</a>\n<br><a data-href=\"Блочная область видимости\" href=\"материалы/подтемы/секция-1.-javascript/тема-№10/блочная-область-видимости.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Блочная область видимости</a>\n<br><a data-href=\"Вложенность областей видимости\" href=\"материалы/подтемы/секция-1.-javascript/тема-№10/вложенность-областей-видимости.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Вложенность областей видимости</a>\n<br><a data-href=\"Замыкания\" href=\"материалы/подтемы/секция-1.-javascript/тема-№10/замыкания.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Замыкания</a>\n<br><a data-href=\"Практические последствия (var)\" href=\"материалы/подтемы/секция-1.-javascript/тема-№10/практические-последствия-(var).html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Практические последствия (var)</a>\n(Пусто)<br><a data-href=\"Тема №11. Массивы и объекты в JavaScript\" href=\"лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №11. Массивы и объекты в JavaScript</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№10/что-такое-область-видимости.html","материалы/подтемы/секция-1.-javascript/тема-№10/глобальная-область-видимости.html","материалы/подтемы/секция-1.-javascript/тема-№10/функциональная-область-видимости.html","материалы/подтемы/секция-1.-javascript/тема-№10/блочная-область-видимости.html","материалы/подтемы/секция-1.-javascript/тема-№10/вложенность-областей-видимости.html","материалы/подтемы/секция-1.-javascript/тема-№10/замыкания.html","материалы/подтемы/секция-1.-javascript/тема-№10/практические-последствия-(var).html","лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html","pathToRoot":"../..","attachments":[],"createdTime":1760434710315,"modifiedTime":1760434710315,"sourceSize":1316,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №10. Область видимости в JavaScript.md","exportPath":"лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html","showInTree":true,"treeOrder":24,"backlinks":["лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"type":"markdown"},"лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html":{"title":"Тема №11. Массивы и объекты в JavaScript","icon":"","description":"В этой теме вы изучите два фундаментальных типа данных в JavaScript — массивы и объекты — которые используются для структурирования и хранения информации: от списков элементов интерфейса до ответов API. Поймёте, как создавать, изменять и перебирать эти структуры, а также узнаете о различиях между ними и их практическом применении.\n<a data-href=\"Массивы\" href=\"материалы/подтемы/секция-1.-javascript/тема-№11/массивы.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Массивы</a>\n<br><a data-href=\"Объекты\" href=\"материалы/подтемы/секция-1.-javascript/тема-№11/объекты.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Объекты</a>\n<br><a data-href=\"Распаковка (spread)\" href=\"материалы/подтемы/секция-1.-javascript/тема-№11/распаковка-(spread).html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Распаковка (spread)</a>\n<br><a data-href=\"Оператор rest\" href=\"материалы/подтемы/секция-1.-javascript/тема-№11/оператор-rest.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Оператор rest</a>\n<br><a data-href=\"Вложенные структуры\" href=\"материалы/подтемы/секция-1.-javascript/тема-№11/вложенные-структуры.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Вложенные структуры</a>\n<br><a data-href=\"Преобразование типов (Массивы и Объекты) через JSON\" href=\"материалы/подтемы/секция-1.-javascript/тема-№11/преобразование-типов-(массивы-и-объекты)-через-json.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Преобразование типов (Массивы и Объекты) через JSON</a>\n<br><a data-href=\"Практические рекомендации по массивам и объектам\" href=\"материалы/подтемы/секция-1.-javascript/тема-№11/практические-рекомендации-по-массивам-и-объектам.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Практические рекомендации по массивам и объектам</a>\n(Пусто)<br><a data-href=\"Тема №12. Создание сервера NodeJS. WEB 1.0 и WEB 2.0\" href=\"лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №12. Создание сервера NodeJS. WEB 1.0 и WEB 2.0</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№11/массивы.html","материалы/подтемы/секция-1.-javascript/тема-№11/объекты.html","материалы/подтемы/секция-1.-javascript/тема-№11/распаковка-(spread).html","материалы/подтемы/секция-1.-javascript/тема-№11/оператор-rest.html","материалы/подтемы/секция-1.-javascript/тема-№11/вложенные-структуры.html","материалы/подтемы/секция-1.-javascript/тема-№11/преобразование-типов-(массивы-и-объекты)-через-json.html","материалы/подтемы/секция-1.-javascript/тема-№11/практические-рекомендации-по-массивам-и-объектам.html","лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html","pathToRoot":"../..","attachments":[],"createdTime":1760434705877,"modifiedTime":1760434705877,"sourceSize":1181,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №11. Массивы и объекты в JavaScript.md","exportPath":"лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html","showInTree":true,"treeOrder":25,"backlinks":["лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html"],"type":"markdown"},"лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html":{"title":"Тема №12. Создание сервера NodeJS. WEB 1.0 и WEB 2.0","icon":"","description":"В этой теме вы изучите основы создания сервера на NodeJS и эволюцию веб-архитектур — от статического веба (WEB 1.0) до интерактивных приложений с динамической генерацией контента (WEB 2.0). Вы поймёте, как сервер обрабатывает запросы, отдаёт файлы и отвечает JSON-данными. Также разберёте ключевые подходы: SSR и CSR, а также основы маршрутизации и работы с файловой системой.\n<a data-href=\"WEB 1.0 (статический веб)\" href=\"материалы/подтемы/секция-1.-javascript/тема-№12/web-1.0-(статический-веб).html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">WEB 1.0 (статический веб)</a>\n<br><a data-href=\"WEB 2.0 (интерактивный веб)\" href=\"материалы/подтемы/секция-1.-javascript/тема-№12/web-2.0-(интерактивный-веб).html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">WEB 2.0 (интерактивный веб)</a>\n<br><a data-href=\"Основы сервера на NodeJS\" href=\"материалы/подтемы/секция-1.-javascript/тема-№12/основы-сервера-на-nodejs.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Основы сервера на NodeJS</a>\n<br><a data-href=\"Разница между WEB 1.0 и WEB 2.0 в контексте NodeJS\" href=\"материалы/подтемы/секция-1.-javascript/тема-№12/разница-между-web-1.0-и-web-2.0-в-контексте-nodejs.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Разница между WEB 1.0 и WEB 2.0 в контексте NodeJS</a>\n<br><a data-href=\"Маршрутизация в NodeJS\" href=\"материалы/подтемы/секция-1.-javascript/тема-№12/маршрутизация-в-nodejs.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Маршрутизация в NodeJS</a>\n<br><a data-href=\"Отправка файлов с сервера\" href=\"материалы/подтемы/секция-1.-javascript/тема-№12/отправка-файлов-с-сервера.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Отправка файлов с сервера</a>\n<br><a data-href=\"Вкратце о REST\" href=\"материалы/подтемы/секция-1.-javascript/тема-№12/вкратце-о-rest.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Вкратце о REST</a> <br><a data-href=\"Практика №8. SSR-сервер с динамической генерацией страниц\" href=\"задания/секция-1.-javascript/практика-№8.-ssr-сервер-с-динамической-генерацией-страниц.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Практика №8. SSR-сервер с динамической генерацией страниц</a>\n<br><a data-href=\"Практика №9. CSR с гидратацией. Интерактивный счётчик\" href=\"задания/секция-1.-javascript/практика-№9.-csr-с-гидратацией.-интерактивный-счётчик.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Практика №9. CSR с гидратацией. Интерактивный счётчик</a>\n<br><a data-href=\"Тема №13. Основы React\" href=\"лекции/секция-2.-react/тема-№13.-основы-react.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №13. Основы React</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№12/web-1.0-(статический-веб).html","материалы/подтемы/секция-1.-javascript/тема-№12/web-2.0-(интерактивный-веб).html","материалы/подтемы/секция-1.-javascript/тема-№12/основы-сервера-на-nodejs.html","материалы/подтемы/секция-1.-javascript/тема-№12/разница-между-web-1.0-и-web-2.0-в-контексте-nodejs.html","материалы/подтемы/секция-1.-javascript/тема-№12/маршрутизация-в-nodejs.html","материалы/подтемы/секция-1.-javascript/тема-№12/отправка-файлов-с-сервера.html","материалы/подтемы/секция-1.-javascript/тема-№12/вкратце-о-rest.html","задания/секция-1.-javascript/практика-№8.-ssr-сервер-с-динамической-генерацией-страниц.html","задания/секция-1.-javascript/практика-№9.-csr-с-гидратацией.-интерактивный-счётчик.html","лекции/секция-2.-react/тема-№13.-основы-react.html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html","pathToRoot":"../..","attachments":[],"createdTime":1760434712315,"modifiedTime":1760434712315,"sourceSize":1404,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №12. Создание сервера NodeJS. WEB 1.0 и WEB 2.0.md","exportPath":"лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html","showInTree":true,"treeOrder":26,"backlinks":["лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html"],"type":"markdown"},"материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html":{"title":"Как создавать файлы с определённым расширением","icon":"","description":"Самый простой способ - создать файл через \"проводник\".\n<img alt=\"Pasted image 20250912214611.png\" src=\"материалы/файлы/pasted-image-20250912214611.png\" target=\"_self\">\nНо для этого нужно сначала включить опцию чтобы мы могли видеть расширение файлов (по умолчанию оно скрыто, особенно на компьютерах колледжа).<br>\n<img alt=\"Pasted image 20250912214624.png\" src=\"материалы/файлы/pasted-image-20250912214624.png\" target=\"_self\">\nНу а дальше уже все просто, например нам нужно создать js файл&nbsp;example.js<br>\n<img alt=\"Pasted image 20250912214643.png\" src=\"материалы/файлы/pasted-image-20250912214643.png\" target=\"_self\"><br>\n<img alt=\"Pasted image 20250912214649.png\" src=\"материалы/файлы/pasted-image-20250912214649.png\" target=\"_self\"><img alt=\"Pasted image 20250912214653.png\" src=\"материалы/файлы/pasted-image-20250912214653.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html","pathToRoot":"../..","attachments":["материалы/файлы/pasted-image-20250912214611.html","материалы/файлы/pasted-image-20250912214624.html","материалы/файлы/pasted-image-20250912214643.html","материалы/файлы/pasted-image-20250912214649.html","материалы/файлы/pasted-image-20250912214653.html"],"createdTime":1760434689807,"modifiedTime":1760434689807,"sourceSize":667,"sourcePath":"Материалы/Как сделать/Как создавать файлы с определённым расширением.md","exportPath":"материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html","showInTree":true,"treeOrder":35,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№3/создание-своей-html-страницы.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№1/основные-платформы-мобильных-приложений.html":{"title":"Основные платформы мобильных приложений","icon":"","description":"Платформа мобильных приложений — это совокупность программного обеспечения, инструментов, стандартов и правил, которые определяют, как создаются, устанавливаются и работают мобильные приложения на конкретном устройстве. Это не просто операционная система (ОС), а целая экосистема: от ядра ОС и API-интерфейсов до магазинов приложений, систем подписок, политик безопасности и требований к разработчикам. Выбор платформы напрямую влияет на: доступные функции устройства (камера, GPS, биометрия); способы взаимодействия с пользователем; методы тестирования и отладки; стратегию монетизации и распространения; сроки и стоимость разработки. На сегодняшний день подавляющее большинство мобильных приложений создаётся для двух основных платформ — iOS и Android. Их доминирование обусловлено масштабами рынка, зрелостью инструментов и поддержкой со стороны крупнейших технологических компаний.iOS — экосистема Apple, работающая на устройствах iPhone, iPad и iPod touch. Закрытая, строго контролируемая платформа с единым стандартом качества, высокой безопасностью и стабильной производительностью. Основная аудитория — пользователи в развитых странах, с высоким уровнем дохода и лояльностью к бренду.Android — открытая операционная система от Google, используемая сотнями производителей (Samsung, Xiaomi, OnePlus, Motorola и др.). Обладает огромной фрагментацией устройств и версий, но обеспечивает максимальную доступность и гибкость для разработчиков и пользователей. Доминирует в развивающихся рынках и по объёму установленных устройств — более 70% глобального рынка смартфонов.Но, помимо iOS и Android, на протяжении истории мобильных технологий существовали и другие платформы, которые либо имели значительную долю рынка, либо обладали высоким потенциалом, но в итоге уступили место доминирующим системам.Windows Phone (Microsoft) — запущенная в 2010 году платформа, основанная на ядре Windows NT, предлагала уникальный пользовательский интерфейс с динамическими «живыми» плитками. Несмотря на техническую изящность и глубокую интеграцию с экосистемой Microsoft (Outlook, Office, OneDrive), она не смогла привлечь достаточное количество разработчиков. Отсутствие приложений, особенно популярных сервисов вроде Instagram или WhatsApp на ранних этапах, стало фатальным. Microsoft официально прекратила поддержку Windows Phone в 2017 году.BlackBerry OS / BlackBerry 10 — до середины 2000-х годов BlackBerry была синонимом корпоративной мобильности благодаря надёжной безопасности, физической клавиатуре и собственной сети Push Mail. Однако компания не сумела адекватно ответить на рост сенсорных экранов и экосистемы приложений. Попытка перезапуска с BlackBerry 10 в 2013 году, основанной на QNX, оказалась слишком поздней — к тому времени пользователи уже массово перешли на iOS и Android. В 2016 году BlackBerry перестала производить собственные устройства.Symbian — когда-то самая популярная мобильная ОС, особенно в Европе и Азии, Symbian использовалась Nokia, Samsung, Siemens и другими. Она доминировала на рынке до 2007 года, но её архитектура, унаследованная от эпохи кнопочных телефонов, не позволила эффективно адаптироваться к новым требованиям тачскринов и мультимедиа. После выхода iPhone и Android, Nokia в 2011 году перешла на Windows Phone, а Symbian была официально закрыта в 2014 году.WebOS (Palm, затем HP) — оригинальная и продвинутая система с многооконным интерфейсом, предшественник современных концепций многозадачности. Palm выпустила первые устройства на WebOS в 2009 году, а HP попыталась развивать платформу дальше, даже выпустив планшет TouchPad. Но недостаток приложений, маркетинговой поддержки и внутренние конфликты в HP привели к отказу от WebOS в 2011 году. Позже HP передала код проекта LG, который использовал его для своих смарт-телевизоров — но как мобильная ОС WebOS так и не возродилась.HarmonyOS (Huawei) — современный пример платформы, появившейся как ответ на геополитические ограничения. Разработанная Huawei в 2019 году после запрета Google на использование GMS (Google Mobile Services), HarmonyOS изначально позиционировалась как универсальная ОС для IoT-устройств, а позже — как замена Android на смартфонах. Хотя она технически совместима с Android-приложениями через App Pack, её глобальное распространение ограничено из-за отсутствия доступа к ключевым сервисам Google и западным приложениям. На сегодня — это важный региональный игрок (особенно в Китае), но не глобальная альтернатива iOS/Android.iOS и Android — две доминирующие мобильные платформы, отличающиеся не только архитектурой, но и философией разработки, подходом к безопасности, экосистеме и взаимодействию с пользователем. Их сравнение позволяет понять фундаментальные различия, которые влияют на процесс создания мобильных приложений.Языки программирования и инструменты разработки\niOS-приложения разрабатываются преимущественно на языке Swift (с 2014 года), а также на Objective-C — унаследованном от эпохи NeXTSTEP. Интегрированная среда разработки — Xcode, доступная исключительно на macOS. Это накладывает ограничения: разработка под iOS невозможна без устройства Apple или виртуальной машины с macOS.\nAndroid-приложения пишутся на Kotlin (рекомендуемый язык с 2019 года) или Java (традиционный, но постепенно вытесняемый). Среда разработки — Android Studio, основанная на IntelliJ IDEA, работает на Windows, macOS и Linux, что обеспечивает большую доступность для разработчиков.Архитектура и управление ресурсами\niOS использует закрытую, унифицированную архитектуру: ограниченное количество моделей устройств с жёстко контролируемыми характеристиками (память, процессор, экран). Это позволяет оптимизировать приложения под конкретные аппаратные конфигурации, обеспечивая высокую производительность и стабильность.\nAndroid, напротив, работает на тысячах устройств с разными процессорами, объёмами ОЗУ, плотностями пикселей и версиями ОС. Разработчику приходится учитывать фрагментацию — от старых смартфонов с Android 8 до новых с Android 14 — и применять адаптивные интерфейсы, проверять совместимость и использовать библиотеки поддержки (Android Support Library / AndroidX).Магазины приложений и политики распространения\nПриложения для iOS распространяются исключительно через App Store — строго централизованный и контролируемый канал. Apple проводит ручную модерацию каждого приложения, требует соблюдения строгих гайдлайнов по дизайну, приватности и функциональности. Это повышает уровень безопасности для пользователей, но замедляет выпуск обновлений и ограничивает возможности монетизации (например, запрещены сторонние магазины и системы внутренних покупок вне App Store).\nAndroid-приложения могут распространяться через Google Play, но также допускается установка из сторонних источников (APK-файлы). Google Play имеет автоматизированную модерацию, менее строгие требования, но более высокий риск распространения вредоносного ПО. Это делает Android более открытой, но требует от разработчика дополнительных мер по защите приложения и информированию пользователей о безопасности.Доля рынка и целевая аудитория\nПо количеству установленных устройств Android доминирует — около 70–75% глобального рынка смартфонов, особенно в Азии, Африке и Латинской Америке. При этом iOS занимает около 25–30%, но сосредоточена в странах с высоким уровнем дохода — США, Западная Европа, Япония, Австралия.\nЭто создаёт принципиально разные экономические модели: приложения для iOS чаще генерируют больше дохода на одного пользователя (высокий ARPU — Average Revenue Per User), тогда как Android обеспечивает больший охват аудитории, но с меньшей monetization. Для бизнес-приложений это означает выбор между качеством и количеством.Обновления и жизненный цикл устройств\nApple контролирует полный цикл — от железа до ПО — и обеспечивает массовые обновления ОС для устройств, выпущенных до 5–6 лет назад. Более 90% активных устройств iOS работают на последних двух версиях ОС.\nAndroid-устройства получают обновления неравномерно: производители (Samsung, Xiaomi и др.) сами решают, какие модели поддерживают, а многие бюджетные устройства остаются на устаревших версиях (Android 8–10) годами. Это вынуждает разработчиков поддерживать совместимость с множеством версий API, увеличивая сложность тестирования и развертывания.Безопасность и приватность\niOS позиционируется как более безопасная платформа благодаря изолированной среде выполнения приложений (sandboxing), строгому контролю доступа к данным (персональные файлы, камера, микрофон), шифрованию данных на уровне ОС и обязательному использованию App Transport Security.\nAndroid предоставляет аналогичные механизмы, но их реализация зависит от производителя. Многие OEM-производители добавляют собственные сервисы, фоновые процессы и права, которые могут компрометировать приватность. Кроме того, открытость Android делает его более уязвимым к вредоносным APK-файлам, загружаемым вне Google Play.Интеграция с экосистемой\niOS тесно интегрирован с другими продуктами Apple: iCloud, AirDrop, Handoff, Continuity, Apple Watch, HomeKit. Это позволяет создавать кросс-устройственные приложения с единым пользовательским опытом.\nAndroid интегрируется с сервисами Google: Gmail, Google Maps, Drive, Firebase, Google Assistant, Wear OS. Эти сервисы предоставляют мощные инструменты для разработчиков — особенно для аналитики (Firebase), push-уведомлений, облачного хранения и машинного обучения. Однако интеграция с другими устройствами (TV, часы, авто) менее унифицирована, чем в Apple.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Что означает платформа мобильных приложений","level":2,"id":"Что_означает_платформа_мобильных_приложений_0"},{"heading":"Существующие платформы","level":2,"id":"Существующие_платформы_0"},{"heading":"Сравнительная характеристика iOS и Android","level":2,"id":"Сравнительная_характеристика_iOS_и_Android_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№1/основные-платформы-мобильных-приложений.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434780410,"modifiedTime":1760434780411,"sourceSize":16719,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №1/Основные платформы мобильных приложений.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№1/основные-платформы-мобильных-приложений.html","showInTree":true,"treeOrder":39,"backlinks":["лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№1/основные-технологии-для-разработки-мобильных-приложений.html":{"title":"Основные технологии для разработки мобильных приложений","icon":"","description":"Нативная разработка предполагает использование официальных языков программирования, сред разработки и фреймворков, предоставляемых производителями платформ — Apple и Google. Приложения компилируются напрямую в машинный код, обеспечивающий максимальную производительность и полный доступ к API устройства.Для разработки приложений под iOS используется Swift — язык, созданный Apple в 2014 году как современная замена Objective-C. Swift отличается чистым синтаксисом, безопасностью типов, поддержкой функционального программирования и высокой скоростью выполнения. Он активно развивается и является стандартом для новых проектов.Вместо него до сих пор встречается Objective-C — унаследованный от NeXTSTEP язык, который использовался в iOS до появления Swift. Он остаётся актуальным при поддержке старых проектов, но новые разработчики начинают с Swift.Инструмент разработки — Xcode, единственный официально поддерживаемый IDE от Apple. Он включает в себя редактор кода, симулятор устройств, инструменты отладки, профилирования производительности и систему управления версиями (Git). Xcode работает только на macOS, что делает разработку под iOS невозможной на Windows или Linux без виртуализации.Фреймворки интерфейса:\nUIKit — традиционный фреймворк для создания пользовательских интерфейсов. Работает на основе иерархии представлений (UIView), требует детального описания макетов через код или Interface Builder. Подходит для сложных, детально настраиваемых интерфейсов.\nSwiftUI — декларативный фреймворк, представленный в 2019 году. Позволяет описывать интерфейс как функцию состояния приложения — «что должно отображаться при данном состоянии», а не «как его построить». Упрощает разработку, обеспечивает автоматическую адаптацию под все размеры экранов и темы (светлая/тёмная), и полностью интегрирован с Swift. Считается будущим iOS-разработки.\nОбе технологии работают с экосистемой Apple: Core Animation, Core Location, ARKit, HealthKit, Face ID, Push Notifications — всё доступно через единые API, документированные и стабильно поддерживающиеся Apple.Основным языком для Android сегодня является Kotlin — язык, разработанный JetBrains и официально объявленный Google предпочтительным для Android-разработки с 2019 года. Kotlin сочетает в себе функциональные и объектно-ориентированные парадигмы, обладает более безопасной системой типов (отсутствие null-pointer исключений по умолчанию), сжатым синтаксисом и полной совместимостью с Java.Java остаётся актуальной благодаря огромной базе legacy-приложений и корпоративных систем. Многие библиотеки, туториалы и инструкции всё ещё написаны на Java, но новые проекты рекомендуют начинать с Kotlin.Среда разработки — Android Studio, основанная на IntelliJ IDEA. Она предоставляет полноценный набор инструментов: эмулятор устройств, профайлер памяти и сети, анализатор производительности, инструменты для тестирования и поддержку Firebase. Работает на Windows, macOS и Linux — обеспечивает большую доступность, чем Xcode.Фреймворки интерфейса:\nXML-разметка + View-система — классический подход. Интерфейс описывается в XML-файлах, а логика — в Kotlin/Java-классах. Требует явного связывания элементов UI с кодом (findViewById()), что создаёт больше шаблонного кода и потенциальных ошибок.\nJetpack Compose — современный декларативный фреймворк, аналог SwiftUI. Позволяет описывать интерфейс как функцию состояния, используя только Kotlin. Компоненты (Composables) перерисовываются автоматически при изменении данных. Упрощает создание динамических интерфейсов, снижает количество кода и повышает читаемость. С 2023 года считается основным стандартом для новых проектов.\nAndroid также предлагает богатую экосистему Jetpack — набор библиотек (ViewModel, Room, Navigation, DataStore, WorkManager и др.), которые решают типовые задачи: управление жизненным циклом, работа с базами данных, фоновые задачи, маршрутизация между экранами — всё стандартизировано и поддерживается Google.Кроссплатформенные технологии позволяют писать один код, который компилируется в нативные приложения для iOS и Android. Отличие от гибридных — отсутствие WebView: вместо веб-страницы приложение использует настоящие нативные компоненты или собственные рендереры, что обеспечивает близкую к нативной производительность.Разработан Google и представлен в 2017 году. Основан на языке Dart — объектно-ориентированном языке с быстрой компиляцией и поддержкой JIT/AOT (Just-in-Time / Ahead-of-Time). Flutter компилирует код напрямую в нативный ARM-код, минуя виртуальную машину.Ключевая особенность — декларативная widget-архитектура. Весь интерфейс строится из деревьев виджетов — каждый элемент (кнопка, текст, список) — это виджет, который может быть изменён, вложен или переиспользован. Даже отступы и цвета — это виджеты.Flutter не использует нативные UI-компоненты iOS или Android. Вместо этого он рендерит собственные элементы с помощью графического движка Skia — то же, что используется в Chrome и Android. Это даёт:\nЕдиный дизайн на всех платформах — приложение выглядит одинаково на iPhone и Samsung.\nВысокую производительность — 60–120 FPS даже на сложных анимациях.\nГибкость дизайна — можно создавать уникальные интерфейсы, не привязанные к Material Design или Human Interface Guidelines.\nОграничения: больший размер приложения (включает рендер-движок), ограниченная интеграция с некоторыми нативными API без написания плагинов на Swift/Kotlin, менее «родной» UX на iOS, если не следовать гайдлайнам вручную.Flutter идеален для проектов с акцентом на дизайн: продукты с уникальной визуальной идентичностью, маркетплейсы, сервисы с частыми анимациями, MVP-стартапы, где важна скорость выхода на два рынка.Разработан Meta (ранее Facebook) в 2015 году. Основан на JavaScript и TypeScript — языках, уже знакомых миллионам веб-разработчиков. React Native использует принцип React — компонентный подход, где интерфейс строится из повторно используемых компонентов, реагирующих на изменения состояния.Архитектура React Native основана на JS-бриджe: JavaScript-код выполняется в отдельном потоке, а вызовы к нативным компонентам (кнопки, списки, камера) передаются через мост. Это позволяет использовать настоящие нативные UI-элементы, но создаёт задержки при частых взаимодействиях между JS и нативным кодом.Преимущества:\nВысокая скорость разработки для команд с опытом в вебе.\nБольшое сообщество и множество готовых библиотек (npm).\nВозможность частичного перехода: можно внедрять React Native-экраны в существующее нативное приложение.\nПоддержка горячей перезагрузки (Hot Reload) — изменения видны мгновенно.\nОграничения:\nПроизводительность ниже, чем у Flutter или нативных приложений — особенно при сложной анимации или работе с большим количеством данных.\nЗависимость от сторонних библиотек для доступа к API — многие требуют установки и настройки нативных модулей (Native Modules).\nРазница в поведении между iOS и Android — некоторые компоненты могут работать по-разному, требуя платформо-специфичного кода.\nСложность отладки: ошибки могут возникать как в JS, так и в нативном коде, затрудняя диагностику.\nReact Native популярен в компаниях, где есть команда веб-разработчиков, нуждающаяся в выходе на мобильный рынок без полного переобучения. Примеры: Facebook, Instagram, Skype, Walmart, Tesla.Разработан Microsoft, ранее известный как Xamarin Forms. Использует язык C# и фреймворк .NET — популярный в корпоративной разработке. В 2022 году Xamarin был объединён с .NET Multi-platform App UI (.NET MAUI) — современной версией, поддерживающей не только iOS и Android, но и Windows, macOS.Отличие от React Native и Flutter: Xamarin/.NET MAUI не использует мост. Код компилируется напрямую в нативный код через Mono или .NET runtime, что обеспечивает лучшую производительность и меньшие накладные расходы.Плюсы:\nПолный доступ к нативным API через привязки (bindings) — почти все функции устройства доступны «из коробки».\nЕдиная кодовая база для мобильных и десктопных приложений.\nИнтеграция с Visual Studio и Azure — удобна для корпоративных проектов.\nСильная типизация и безопасность C#.\nМинусы:\nМеньшее сообщество по сравнению с Flutter и React Native.\nБолее сложная настройка, особенно для новичков.\nМенее гибкий UI — интерфейс часто выглядит «по-Windows», если не применять платформо-специфичные стили.\nМедленнее развитие экосистемы по сравнению с Google и Meta.\n.NET MAUI подходит для enterprise-решений: внутренние корпоративные приложения, ERP-системы, CRM, медицинские терминалы, приложения с интеграцией в облачные сервисы Microsoft (Azure, Office 365).","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Нативная разработка","level":2,"id":"Нативная_разработка_0"},{"heading":"iOS: Swift, Objective-C, Xcode, UIKit, SwiftUI","level":3,"id":"iOS_Swift,_Objective-C,_Xcode,_UIKit,_SwiftUI_0"},{"heading":"Android: Kotlin, Java, Android Studio, Jetpack Compose, XML-разметка","level":3,"id":"Android_Kotlin,_Java,_Android_Studio,_Jetpack_Compose,_XML-разметка_0"},{"heading":"Кроссплатформенная разработка","level":2,"id":"Кроссплатформенная_разработка_0"},{"heading":"Flutter: Dart, widget-архитектура, рендеринг на Skia","level":3,"id":"Flutter_Dart,_widget-архитектура,_рендеринг_на_Skia_0"},{"heading":"React Native: JavaScript/TypeScript, Bridge-механизм, native modules","level":3,"id":"React_Native_JavaScript/TypeScript,_Bridge-механизм,_native_modules_0"},{"heading":"Xamarin (.NET MAUI): C#, .NET, прямая компиляция в нативный код","level":3,"id":"Xamarin_(.NET_MAUI)_C#,_.NET,_прямая_компиляция_в_нативный_код_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№1/основные-технологии-для-разработки-мобильных-приложений.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434776958,"modifiedTime":1760434776958,"sourceSize":15238,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №1/Основные технологии для разработки мобильных приложений.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№1/основные-технологии-для-разработки-мобильных-приложений.html","showInTree":true,"treeOrder":40,"backlinks":["лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№1/основные-типы-мобильных-приложений.html":{"title":"Основные типы мобильных приложений","icon":"","description":"Мобильное приложение — это не просто программа, запущенная на смартфоне. Его тип определяется тем, как оно создано, на чём работает и как взаимодействует с операционной системой и аппаратными компонентами устройства. Выбор типа приложения влияет на производительность, сроки разработки, стоимость поддержки и качество пользовательского опыта. Существует четыре основных типа: нативные, веб-приложения, гибридные и кроссплатформенные.Нативные приложения — это программы, разработанные специально для одной конкретной платформы с использованием официальных языков программирования, SDK и инструментов, предоставленных её создателем.Для iOS приложения пишутся на Swift или Objective-C с использованием фреймворков UIKit и SwiftUI, собираются в Xcode и компилируются напрямую в машинный код для архитектуры ARM процессоров Apple.\nДля Android — на Kotlin или Java с использованием Android SDK, сборка происходит через Android Studio в APK или AAB-файлы, которые затем интерпретируются Android Runtime (ART).Преимущества: Максимальная производительность — код выполняется напрямую на устройстве без промежуточных слоёв. Полный доступ ко всем API устройства: камера, GPS, Bluetooth, сенсоры, биометрия, уведомления, фоновые задачи. Соответствие стандартам платформы (Human Interface Guidelines для iOS, Material Design для Android) — обеспечивает интуитивный и «родной» пользовательский опыт. Лучшая стабильность и поддержка обновлений ОС — разработчики получают ранний доступ к новым функциям через beta-версии SDK.\nОграничения: Требуется отдельная команда разработчиков для каждой платформы — удвоение затрат на разработку и тестирование. Дублирование логики и дизайна между версиями — увеличивает время выхода на рынок. Высокая зависимость от экосистемы: обновление API может потребовать переписывания значительной части кода.\nОбласти применения:\nНативные приложения — стандарт для проектов, где важны скорость, надёжность и глубокая интеграция с устройством: банковские и финансовые приложения, игры, AR/VR-решения, медицинские системы, приложения с реальным временем (например, такси, доставка), корпоративные инструменты с высокими требованиями к безопасности.Веб-приложения — это сайты, спроектированные так, чтобы вести себя как мобильные приложения. Они работают в браузере, но могут быть добавлены на домашний экран, работать оффлайн и отправлять уведомления благодаря технологиям PWA.Основаны на стандартных веб-технологиях: HTML5, CSS3, JavaScript, а также Service Workers (для кэширования и работы без интернета), Web App Manifest (для определения иконки, имени, цвета темы) и Push API.Преимущества: Одна кодовая база — работает на всех устройствах с браузером (iOS, Android, даже десктоп). Нет необходимости проходить модерацию в магазинах приложений — публикация мгновенная. Низкие затраты на разработку и обслуживание. Не требует установки — пользователь сразу переходит по ссылке. Автоматическое обновление — изменения видны сразу после релиза.\nОграничения: Ограниченный доступ к аппаратным возможностям устройства: нет прямого доступа к контактам, файловой системе, Bluetooth Low Energy, NFC, гироскопу в некоторых случаях. Невозможность использовать многие нативные UI-компоненты — интерфейс выглядит как сайт, а не как приложение. Зависимость от браузера: производительность и совместимость различаются между Safari, Chrome, Firefox. Отсутствие в App Store и Google Play — потеря видимости, возможности рейтингов, рекомендаций и внутренних покупок через официальные каналы.\nОбласти применения:\nPWA подходят для контентных сервисов, информационных сайтов, электронной коммерции с простой логикой, корпоративных порталов, приложений с низким уровнем взаимодействия: онлайн-газеты, каталоги товаров, формы обратной связи, калькуляторы, лендинги. Особенно эффективны там, где важна скорость распространения и минимальные затраты — например, маркетинговые кампании или временные акции.Гибридные приложения — это веб-приложения, обёрнутые в «оболочку» нативного контейнера (WebView), который позволяет им запускаться как обычные мобильные приложения из магазинов. Они используют веб-технологии (HTML/CSS/JS), но имеют доступ к нативным API через плагины.Популярные фреймворки: Apache Cordova (ранее PhoneGap) и Ionic (основан на Angular/React/Vue + Cordova).Преимущества: Одна кодовая база для iOS и Android — снижение затрат на разработку. Возможность публикации в App Store и Google Play — как нативные приложения. Быстрая разработка для команд с опытом в вебе. Поддержка большинства базовых функций: камера, геолокация, уведомления, файловая система — через плагины.\nОграничения: Производительность ниже, чем у нативных — все операции проходят через WebView, что создаёт задержки, особенно при анимациях и сложной графике. Плагины часто устаревают или плохо документированы — могут вызывать баги на новых версиях ОС. UX редко достигает уровня «родного» приложения — интерфейс чувствуется как «веб-страница в обёртке». Ограниченный доступ к современным нативным функциям (например, Face ID, ARKit, Android Jetpack Compose).\nОбласти применения:\nГибридные приложения подходят для прототипирования, MVP-проектов, внутренних корпоративных инструментов, приложений с простой логикой и минимальным взаимодействием с оборудованием: учётные системы, формы регистрации, CRM-клиенты, базовые лояльностные программы. Идеальны, когда бюджет ограничен, а сроки — жёсткие, и требуется быстрый выход на два рынка.Кроссплатформенные приложения — это приложения, написанные на одном языке и фреймворке, которые компилируются в нативный код для разных платформ. Это не обёртки, а генерация нативных компонентов на основе единого исходного кода.Популярные фреймворки: Flutter (Dart, от Google), React Native (JavaScript/TypeScript, от Meta), Xamarin (C#, от Microsoft), Kivy (Python, редко используется в коммерческой разработке).Отличие от гибридных: вместо WebView они используют настоящие нативные UI-компоненты (например, Flutter рисует собственные виджеты, React Native вызывает native UI элементы iOS/Android напрямую).Преимущества: Одна кодовая база — до 80–95% общего кода между iOS и Android. Производительность близка к нативной — особенно в Flutter и React Native с правильной оптимизацией. Доступ к большинству нативных API через библиотеки (например, Firebase, Mapbox, camera plugin). Современный UI — возможность создавать уникальный дизайн, не привязанный к стандартам платформы. Активное сообщество, регулярные обновления, хорошая документация.\nОграничения: Некоторые функции требуют написания нативного кода (Java/Kotlin, Swift/Objective-C) — если нужна глубокая интеграция с OS. Размер приложения больше, чем у чисто нативного (особенно в Flutter — включает движок рендеринга). Возможны баги на границах платформ — поведение одного и того же компонента может отличаться на iOS и Android. Обучение новому языку (Dart, TypeScript) требует времени для команд, привыкших к Java/Kotlin или Swift.\nОбласти применения:\nКроссплатформенные решения — выбор большинства стартапов, компаний с ограниченным бюджетом, но амбициозными целями. Подходят для социальных сетей, мессенджеров, e-commerce, финтех-приложений, образовательных платформ, приложений с частыми обновлениями и необходимостью быстро масштабироваться. Примеры: Facebook, Instagram (частично), Uber Eats, Alibaba, Tencent.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Нативные приложения","level":3,"id":"Нативные_приложения_0"},{"heading":"Веб-приложения (Progressive Web Apps — PWA)","level":3,"id":"Веб-приложения_(Progressive_Web_Apps_—_PWA)_0"},{"heading":"Гибридные приложения","level":3,"id":"Гибридные_приложения_0"},{"heading":"Кроссплатформенные приложения","level":3,"id":"Кроссплатформенные_приложения_0"},{"heading":"Сравнительная таблица ключевых параметров","level":3,"id":"Сравнительная_таблица_ключевых_параметров_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№1/основные-типы-мобильных-приложений.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434777027,"modifiedTime":1760434777027,"sourceSize":15196,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №1/Основные типы мобильных приложений.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№1/основные-типы-мобильных-приложений.html","showInTree":true,"treeOrder":41,"backlinks":["лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№2/базовое-понимание-синтаксиса-javascript.html":{"title":"Базовое понимание синтаксиса JavaScript","icon":"","description":"В рамках данной темы рассматриваются только базовые элементы синтаксиса JavaScript, необходимые для начала практической работы. Полный объём синтаксических конструкций — от операторов и структур управления до модулей, классов, асинхронности и деструктуризации — будет изучаться последовательно в последующих разделах курса. Настоящая часть служит фундаментом для понимания структуры кода, а не исчерпывающим руководством по языку.Комментарии не влияют на выполнение кода и предназначены исключительно для повышения читаемости и документирования.JavaScript поддерживает два типа комментариев: Однострочные — начинаются с //. Все, что следует после // до конца строки, игнорируется движком. // Это однострочный комментарий\nlet x = 5; // Можно писать и в конце строки Многострочные — заключаются между /* и */. Позволяют комментировать несколько строк или блоки кода. /*\nЭто многострочный комментарий\nИспользуется для описания функций, модулей или временного отключения кода\n*/\nlet y = 10;\nJavaScript — язык, чувствительный к регистру. Это означает, что имена переменных, функций, ключевых слов и свойств различаются по написанию букв в верхнем и нижнем регистре.\nПримеры: let name = \"Анна\";\nlet Name = \"Иван\"; // Это другая переменная\nlet NAME = \"Олег\"; // И ещё одна console.log(name); // \"Анна\"\nconsole.log(Name); // \"Иван\"\nconsole.log(NAME); // \"Олег\"\nТо же относится к ключевым словам: let — корректно, Let — ошибка (если не является именем переменной).\nТакже чувствительны к регистру названия свойств объектов: user.name ≠ user.Name.В JavaScript точки с запятой (;) используются для явного завершения инструкций. Хотя язык позволяет опускать их в большинстве случаев благодаря автоматической вставке точек с запятой (ASI — Automatic Semicolon Insertion), рекомендуется всегда использовать точки с запятой для предотвращения неочевидных ошибок. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Комментарии JS","level":2,"id":"Комментарии_JS_0"},{"heading":"Чувствительность к регистру","level":2,"id":"Чувствительность_к_регистру_0"},{"heading":"Точки с запятой <code>;</code>","level":2,"id":"Точки_с_запятой_`;`_0"},{"heading":"<a data-href=\"Переменные в JavaScript\" href=\"Переменные в JavaScript\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">Переменные в JavaScript</a>","level":2,"id":"[[Переменные_в_JavaScript]]_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№2/переменные-в-javascript.html"],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№2/базовое-понимание-синтаксиса-javascript.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434740966,"modifiedTime":1760434740967,"sourceSize":3470,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №2/Базовое понимание синтаксиса JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№2/базовое-понимание-синтаксиса-javascript.html","showInTree":true,"treeOrder":43,"backlinks":["лекции/секция-1.-javascript/тема-№2.-основы-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№2/переменные-в-javascript.html":{"title":"Переменные в JavaScript","icon":"","description":"Переменная в JavaScript — это именованный контейнер для хранения данных, который позволяет обращаться к значению по его имени в процессе выполнения программы.Каждая переменная ассоциирована с определённым значением (число, строка, объект, функция и т.д.), которое может меняться во время работы приложения. Переменные позволяют сохранять промежуточные результаты, пользовательские данные, состояния интерфейса — всё, что требуется для динамического поведения приложения.let age = 25;\nlet userName = \"Алексей\";\nlet isActive = true;\nЗдесь:\nage, userName, isActive — имена переменных.\n25, \"Алексей\", true — значения, которые они хранят. Динамическая типизация — тип значения определяется автоматически при присваивании, и переменная может хранить значения разных типов в разное время.\nlet x = 10; // число\nx = \"привет\"; // теперь строка — допустимо\nx = [1, 2, 3]; // теперь массив — тоже допустимо Объявление и использование — переменную нужно объявить перед использованием (кроме случаев с var в нестрогом режиме, но это устаревшая практика).\nОбласть видимости — определяет, где переменная доступна (блок, функция, глобально), зависит от ключевого слова (let, const, var).\nПодробнее про эти особенности мы прочтём в следующих лекциях.При создании и использовании переменных необходимо следовать <a data-tooltip-position=\"top\" aria-label=\"Правила наименования переменных в JavaScript\" data-href=\"Правила наименования переменных в JavaScript\" href=\"материалы/подтемы/секция-1.-javascript/тема-№2/правила-наименования-переменных-в-javascript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">правилам наименования переменных</a>.Работа с переменными включает три ключевых действия: объявление, инициализация и присваивание. Эти понятия тесно связаны, но не тождественны — их различие критически важно для понимания поведения кода.Объявление переменной — это создание её имени в области видимости. Оно сообщает интерпретатору: «Я хочу использовать эту метку для хранения значения».В JavaScript есть три ключевых слова для объявления:Примеры:var x; // объявление через var\nlet y; // объявление через let\nconst z; // Ошибка: const требует инициализации при объявлении\nКлючевое отличие: const обязывает сразу присвоить значение — без этого возникает синтаксическая ошибка.\n💡 Рекомендация: Всегда используйте const по умолчанию. Если знаете, что значение будет меняться — замените на let. Никогда не используйте var в современных проектах — он вносит путаницу из-за hoisting и функциональной области видимости.\nИнициализация — это первое присваивание значения переменной в момент её создания. Это когда переменная получает своё начальное значение и становится доступной для использования.\nИнициализация может совпадать с объявлением.\nОна обязательна для const, опциональна для let и var.\nПримеры:let age; // объявление — без инициализации (значение undefined)\nage = 25; // присваивание — теперь переменная проинициализирована let score = 100; // объявление + инициализация в одной строке\nconst name = \"Алекс\"; // объявление + инициализация (обязательно!)\nИнициализация = объявление + первое присваивание в одном действии.Присваивание — это операция изменения значения уже существующей переменной. Оно происходит после объявления (и, если нужно, после инициализации).\nДля let — можно присваивать сколько угодно раз.\nДля const — присваивание разрешено только один раз (при инициализации); любое последующее присваивание вызовет ошибку.\nПрисваивание не обязательно должно происходить сразу после объявления.\nПримеры:let count;\ncount = 0; // первое присваивание (и одновременно инициализация)\ncount = count + 1; // второе присваивание — изменение значения\ncount = null; // присваивание — можно менять const PI = 3.14;\nPI = 3.14159; // Ошибка: присваивание const после инициализации запрещено // Но! Если значение — объект или массив:\nconst user = { name: \"Иван\" };\nuser.name = \"Петр\"; // Разрешено — меняется содержимое объекта, а не ссылка\nuser = {}; // Ошибка — попытка изменить ссылку\nВажно: const защищает ссылку, а не содержимое. Для объектов и массивов можно менять свойства — это не нарушает константность.В JavaScript, как и в любом языке программирования, читаемость и поддерживаемость кода важнее минимального количества строк. Создание дополнительной переменной для хранения промежуточного результата — это не расточительство, а практика, повышающая ясность кода.\nУпрощает чтение: имя переменной может объяснять смысл действия, вместо того чтобы оставлять сложное выражение без контекста.\nОблегчает отладку: можно легко поставить точку останова на конкретной переменной и увидеть её значение.\nСнижает когнитивную нагрузку: другие разработчики (и вы сами через неделю) быстрее поймут логику.\nПовышает переиспользуемость: если значение используется несколько раз — нет нужды повторять вычисление.\nБез лишней переменной (менее читаемо):if (user.age &gt;= 18 &amp;&amp; user.status === 'active' &amp;&amp; user.country !== 'restricted') { enableAccess();\n}\nС лишней переменной (более понятно):const isAdult = user.age &gt;= 18;\nconst isActive = user.status === 'active';\nconst isAllowedCountry = user.country !== 'restricted'; if (isAdult &amp;&amp; isActive &amp;&amp; isAllowedCountry) { enableAccess();\n}\nЗдесь имена переменных выполняют роль документации — они сразу говорят, что проверяется, а не как.Не стоит создавать переменные ради создания — только если они действительно улучшают понимание. Не нужно оборачивать простые литералы или очевидные значения, например:const five = 5; // Избыточно\nreturn x + five; // Лучше:\nreturn x + 5;\nНо если значение получено в результате вычисления, преобразования или запроса — лучше сохранить его с осмысленным именем.Переменные используются для хранения данных, которые могут изменяться во время выполнения программы. Они позволяют:\nСохранять результаты вычислений;\nПередавать данные между частями кода;\nУправлять состоянием приложения (например, флаги, счётчики, пользовательские данные). Обращайтесь к переменной только после её объявления и инициализации. Попытка использовать let или const до объявления вызовет ошибку ReferenceError.\nНе используйте переменные с неопределённым значением (undefined) без проверки — это источник багов.\nИзбегайте глобальных переменных. Всегда ограничивайте область видимости блоками ({}), функциями или модулями.\nИспользуйте переменные для повторяющихся значений — это упрощает изменение параметров в будущем (например, таймауты, цвета, константы конфигурации).\nconst apiUrl = 'https://api.example.com/data';\nconst timeoutMs = 5000; fetch(apiUrl, { timeout: timeoutMs }) .then(response =&gt; response.json()) .then(data =&gt; { const processedData = data.map(item =&gt; item.toUpperCase()); displayResults(processedData); });\nЗдесь каждая переменная имеет чёткую роль:\napiUrl — централизованное управление адресом API;\ntimeoutMs — легко изменяемый параметр;\nprocessedData — промежуточный результат, понятный по имени. Переиспользование одной переменной для разных целей:\nlet user = getUserById(123);\nuser = calculateDiscount(user); // Теперь user — не объект пользователя, а число. Путаница! Использование переменных без инициализации:\nlet result;\nconsole.log(result + 10); // NaN — непредсказуемое поведение ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Пример:","level":3,"id":"Пример_0"},{"heading":"Ключевые особенности:","level":3,"id":"Ключевые_особенности_0"},{"heading":"Названия переменных","level":2,"id":"Названия_переменных_0"},{"heading":"Работа с переменными: объявление, инициализация и присваивание","level":2,"id":"Работа_с_переменными_объявление,_инициализация_и_присваивание_0"},{"heading":"Объявление","level":3,"id":"Объявление_0"},{"heading":"Инициализация","level":3,"id":"Инициализация_0"},{"heading":"Присваивание","level":3,"id":"Присваивание_0"},{"heading":"Рекомендация: не жалеть создавать лишнюю переменную","level":2,"id":"Рекомендация_не_жалеть_создавать_лишнюю_переменную_0"},{"heading":"Почему это полезно:","level":3,"id":"Почему_это_полезно_0"},{"heading":"Пример до и после:","level":3,"id":"Пример_до_и_после_0"},{"heading":"Важно:","level":3,"id":"Важно_0"},{"heading":"Использование переменных в коде","level":2,"id":"Использование_переменных_в_коде_0"},{"heading":"Правила использования:","level":4,"id":"Правила_использования_0"},{"heading":"Пример правильного использования:","level":4,"id":"Пример_правильного_использования_0"},{"heading":"Ошибки, которых следует избегать:","level":4,"id":"Ошибки,_которых_следует_избегать_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№2/правила-наименования-переменных-в-javascript.html"],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№2/переменные-в-javascript.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434776005,"modifiedTime":1760434776005,"sourceSize":13815,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №2/Переменные в JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№2/переменные-в-javascript.html","showInTree":true,"treeOrder":44,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№2/базовое-понимание-синтаксиса-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№2/правила-наименования-переменных-в-javascript.html":{"title":"Правила наименования переменных в JavaScript","icon":"","description":"В JavaScript как и в любом другом языке программирования существуют строгие синтаксические правила для именования переменных: Имя должно начинаться с буквы (a–z, A–Z), символа подчёркивания (_) или знака доллара ($).\n✅ Разрешено: name, _count, $element\n❌ Запрещено: 2name, -value, 3dModel После первого символа можно использовать буквы, цифры (0–9), _ и $.\n✅ Разрешено: userName1, total_price, API_KEY\n❌ Запрещено: user-name, email@domain, my variable Имена чувствительны к регистру — name, Name и NAME — это три разные переменные. Нельзя использовать зарезервированные слова языка как имена переменных:\nlet, const, var, function, if, else, return, class, import, export, null, true, false, this, new, while, for, break, continue, try, catch, finally, throw, switch, case, default, typeof, instanceof, in, of, async, await, yield и другие.\n❌ Запрещено: let = 5;, function = \"test\"; Нельзя использовать ключевые слова будущих версий ECMAScript, даже если они пока не используются (например, package, interface, private, protected, public, static).\n❌ Лучше избегать: class, enum, implements, module, namespace, super Хотя JavaScript позволяет многое, следование общепринятым соглашениям делает код понятным, поддерживаемым и профессиональным: Используйте camelCase для имен переменных и функций.\n✅ userName, isLoading, getTotalPrice\n❌ user_name, User Name, usertotalprice Для констант (которые не меняются) используйте UPPER_SNAKE_CASE.\n✅ MAX_USERS, API_URL, DEFAULT_TIMEOUT Выбирайте осмысленные, описательные имена — избегайте аббревиатур и однобуквенных имён, если контекст не очевиден.\n✅ numberOfItems, currentUser, isFormValid\n❌ n, x, tmp, data1, arr Используйте логические имена для булевых переменных — начинайте с is, has, can, should.\n✅ isVisible, hasPermission, canSubmit, isLoading Избегайте двойных отрицаний — лучше isDisabled, чем isNotEnabled. Не используйте $ в начале имени без причины — хотя $ разрешён, он часто используется в библиотеках (например, jQuery) для обозначения объектов DOM. Используйте только если это часть вашей договорённости в проекте (например, const $button = document.querySelector('#btn');). Следуйте единому стилю в команде — согласуйте стиль именования в проекте (через ESLint, Prettier или внутренний гайдлайн). Не пишите имена на кириллице — даже если JavaScript это позволяет, это снижает читаемость для международной команды и может вызвать проблемы с инструментами/редакторами. 💡 Рекомендация: «Не жалейте создавать лишнюю переменную» — лучше сделать код более читаемым через понятные имена, чем экономить на количестве строк. Например: const isEmailValid = validateEmail(userInput); // Читаемо и понятно вместо const v = validateEmail(userInput); // Неясно, что такое v ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Требования к названию","level":2,"id":"Требования_к_названию_0"},{"heading":"Рекомендации","level":2,"id":"Рекомендации_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№2/правила-наименования-переменных-в-javascript.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434748478,"modifiedTime":1760434748478,"sourceSize":4650,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №2/Правила наименования переменных в JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№2/правила-наименования-переменных-в-javascript.html","showInTree":true,"treeOrder":45,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№2/переменные-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№2/что-такое-javascript,-история-появления.html":{"title":"Что такое JavaScript, история появления","icon":"","description":"JavaScript — это динамический, интерпретируемый язык программирования, изначально разработанный для добавления интерактивности на веб-страницы. Он является одним из трёх основных технологий веб-разработки (наряду с HTML и CSS) и позволяет управлять поведением веб-приложений: обрабатывать события, изменять содержимое страницы, взаимодействовать с сервером и многое другое. Сегодня JavaScript работает не только в браузерах, но и на стороне сервера, в мобильных приложениях, десктопных программах и даже в устройствах Интернета вещей.Это мультипарадигмальный язык, что означает, он поддерживает несколько стилей (парадигм) программирования, и разработчик может выбирать подход, наиболее подходящий для решения задачи. Основные поддерживаемые парадигмы: Функциональное программирование — функции являются первоклассными объектами, можно передавать их как аргументы, возвращать из других функций, создавать замыкания. Поддерживаются чистые функции, иммутабельность, высшие порядки (map, filter, reduce). Объектно-ориентированное программирование (ООП) — через прототипы и (с ES6) синтаксис классов реализуется инкапсуляция, наследование и полиморфизм. Объекты могут динамически расширяться, свойства и методы добавляются во время выполнения. Процедурное программирование — код может быть написан как последовательность инструкций без явного использования классов или функций высшего порядка, что удобно для простых скриптов. JavaScript обладает следующими ключевыми особенностями: Динамическая типизация — тип переменной определяется во время выполнения. Интерпретируемость — код выполняется без предварительной компиляции. Поддержка функционального и объектно-ориентированного стилей — позволяет писать код разными способами. Асинхронность — через колбэки, промисы и async/await обеспечивает неблокирующее выполнение операций. Кроссплатформенность — работает в браузерах, Node.js, React Native, Flutter (через плагины) и других средах. Пример простого кода на JavaScript: alert(\"Привет, мир!\"); let name = \"Анна\"; console.log(\"Здравствуйте, \" + name + \"!\"); Этот код отобразит всплывающее окно с сообщением, сохранит имя в переменную и выведет приветствие в консоль браузера.\nВеб-браузеры — интерактивные формы, анимации, динамическая загрузка контента. Фронтенд-фреймворки — React, Vue, Angular. Бэкенд — Node.js для серверной логики. Мобильные приложения — React Native, Ionic, NativeScript. Десктопные приложения — Electron. Игры — с использованием Canvas или WebGL. IoT — управление устройствами через JavaScript-среды (например, Johnny-Five).\nВ середине 1990-х годов веб был преимущественно статичным: HTML описывал структуру, CSS — оформление, но не было инструментов для взаимодействия с пользователем. Нужен был язык, который позволил бы браузерам выполнять простые действия — проверку форм, анимации, реакцию на клики — без обращения к серверу. Netscape Communications, одна из ведущих компаний того времени, решила создать такой язык.В 1995 году Брендан Эйх, работающий в Netscape, за десять дней разработал язык, первоначально названный Mocha, затем LiveScript, а в конце года — JavaScript. Название было выбрано в маркетинговых целях — чтобы ассоциироваться с популярным Java (несмотря на то, что языки принципиально различны). JavaScript был внедрён в браузер Netscape Navigator 2.0.В 1996 году Netscape передала язык в Ecma International для стандартизации. В 1997 году был принят стандарт ECMAScript 1 (ES1). С тех пор язык развивается под управлением Ecma TC39. Каждые 12 месяцев выпускается новая версия стандарта (ES6/ES2015, ES2020, ES2024 и т.д.), которые добавляют новые возможности: стрелочные функции, модули, классы, промисы, деструктуризацию и другие.Сегодня JavaScript — один из самых популярных языков программирования в мире (по данным Stack Overflow, GitHub и других источников). Его экосистема включает тысячи библиотек и фреймворков. Благодаря Node.js он стал универсальным языком, применяемым как на клиенте, так и на сервере. В мобильной разработке JavaScript используется в таких фреймворках, как React Native, позволяя создавать нативные приложения для iOS и Android на единой кодовой базе. Развитие продолжается: активно внедряются новые API, улучшается производительность движков (V8, SpiderMonkey), растёт поддержка TypeScript как надмножества JavaScript.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Что такое JavaScript","level":2,"id":"Что_такое_JavaScript_0"},{"heading":"Основные характеристики","level":2,"id":"Основные_характеристики_0"},{"heading":"Где применяется JavaScript","level":2,"id":"Где_применяется_JavaScript_0"},{"heading":"История появления и развития JavaScript","level":2,"id":"История_появления_и_развития_JavaScript_0"},{"heading":"Предпосылки создания","level":3,"id":"Предпосылки_создания_0"},{"heading":"Создание языка","level":3,"id":"Создание_языка_0"},{"heading":"Стандартизация*","level":3,"id":"Стандартизация*_0"},{"heading":"Современное развитие","level":3,"id":"Современное_развитие_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№2/что-такое-javascript,-история-появления.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434765319,"modifiedTime":1760434765319,"sourceSize":7899,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №2/Что такое JavaScript, история появления.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№2/что-такое-javascript,-история-появления.html","showInTree":true,"treeOrder":46,"backlinks":["лекции/секция-1.-javascript/тема-№2.-основы-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№3/базовая-работа-с-элементами-веб-страницы-через-javascript.html":{"title":"Базовая работа с элементами веб страницы через JavaScript","icon":"","description":"В JavaScript для взаимодействия с HTML-элементами используются методы работы с DOM (Document Object Model). Основные способы получения элементов: document.getElementById(id) — возвращает элемент по уникальному атрибуту id.\nПример: const button = document.getElementById('submit-btn'); document.querySelector(selector) — возвращает первый элемент, соответствующий CSS-селектору.\nПример: const title = document.querySelector('h1'); или const item = document.querySelector('.item.active'); document.querySelectorAll(selector) — возвращает NodeList (массивоподобный объект) всех элементов, соответствующих селектору.\nПример: const buttons = document.querySelectorAll('button'); document.getElementsByTagName(name) — возвращает HTMLCollection элементов по тегу.\nПример: const paragraphs = document.getElementsByTagName('p'); document.getElementsByClassName(name) — возвращает HTMLCollection элементов по классу.\nПример: const items = document.getElementsByClassName('list-item'); ⚠️ Методы, возвращающие коллекции (HTMLCollection, NodeList), не являются настоящими массивами и не имеют методов массивов (например, .map(), .filter()). Для их использования можно преобразовать в массив через [...collection] или Array.from(collection).\nПосле получения элемента можно изменять его атрибуты и содержимое: element.textContent — устанавливает или возвращает текстовое содержимое элемента (без HTML-разметки).\nПример: paragraph.textContent = 'Новый текст'; element.innerHTML — устанавливает или возвращает HTML-содержимое элемента (включая разметку).\nПример: div.innerHTML = '&lt;strong&gt;Жирный текст&lt;/strong&gt;'; element.setAttribute(name, value) — задаёт значение атрибута.\nПример: button.setAttribute('disabled', 'true'); element.getAttribute(name) — получает значение атрибута.\nПример: const type = input.getAttribute('type'); element.removeAttribute(name) — удаляет атрибут.\nПример: button.removeAttribute('disabled'); 💡 Используйте textContent для изменения текста — он безопаснее innerHTML, так как не выполняет HTML-код и защищает от XSS-атак.\nСтили элемента можно менять напрямую через свойство style — оно представляет собой объект, содержащий все CSS-свойства в формате camelCase:\nelement.style.propertyName = 'value';\nПримеры:\nelement.style.color = 'red';\nelement.style.fontSize = '20px';\nelement.style.backgroundColor = '#f0f0f0';\nelement.style.marginTop = '10px'; 🔍 Важно: CSS-свойства с дефисом (например, background-color) в JavaScript записываются в camelCase (backgroundColor).\nОграничения:\nСтили, заданные через style, имеют приоритет над внешними CSS-правилами.\nНельзя установить несколько стилей одновременно — только по одному свойству.\nДля сложных стилевых изменений рекомендуется использовать классы (classList):\nelement.classList.add('highlight');\nelement.classList.remove('hidden');\nelement.classList.toggle('active'); ✅ Использование classList предпочтительнее прямого изменения style — это позволяет отделять логику от стилей и поддерживать чистоту кода.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Получение элементов","level":3,"id":"Получение_элементов_0"},{"heading":"Изменение свойств элемента","level":3,"id":"Изменение_свойств_элемента_0"},{"heading":"Изменение CSS стилей элемента","level":3,"id":"Изменение_CSS_стилей_элемента_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№3/базовая-работа-с-элементами-веб-страницы-через-javascript.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434748641,"modifiedTime":1760434748641,"sourceSize":4668,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №3/Базовая работа с элементами веб страницы через JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№3/базовая-работа-с-элементами-веб-страницы-через-javascript.html","showInTree":true,"treeOrder":48,"backlinks":["лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№3/основные-понятия-веб-страницы.html":{"title":"Основные понятия веб страницы","icon":"","description":"Основные понятия веб-страницыВеб-страница — это документ, отображаемый в браузере, который состоит из трёх взаимосвязанных технологий: HTML, CSS и JavaScript. Каждая из них выполняет свою уникальную роль, и только их совместное использование позволяет создавать полноценные, интерактивные и визуально привлекательные приложения.HTML (HyperText Markup Language) — это язык гипертекстовой разметки, созданный для описания структуры веб-документов. Он не выполняет вычислений, не обрабатывает логику и не управляет поведением — его задача: обозначить смысл содержимого. Каждый элемент HTML — это маркер, который говорит браузеру: «Это заголовок», «Это абзац», «Это ссылка», «Это изображение».HTML работает на основе тегов — специальных ключевых слов, заключённых в угловые скобки: &lt;tag&gt;. Теги могут быть:\nПарными — имеют открывающий и закрывающий тег: &lt;p&gt;Это параграф&lt;/p&gt; Самозакрывающимися — не содержат содержимого и закрываются сразу: &lt;img src=\"image.jpg\" alt=\"Описание изображения\" /&gt;\n&lt;br /&gt; Каждый тег может иметь атрибуты — дополнительные параметры, уточняющие поведение или свойства элемента. Например:&lt;a href=\"https://example.com\" target=\"_blank\"&gt;Перейти&lt;/a&gt;\nЗдесь href указывает адрес ссылки, а target=\"_blank\" — открывать её в новой вкладке.HTML5 — современная версия стандарта — ввела семантические теги, которые не только описывают внешний вид, но и передают значение контента:\n&lt;header&gt; — шапка страницы или раздела\n&lt;nav&gt; — навигационное меню\n&lt;main&gt; — основное содержимое страницы\n&lt;section&gt; — логический блок тематически связанного контента\n&lt;article&gt; — самостоятельная сущность (например, статья, пост)\n&lt;footer&gt; — подвал\nИспользование семантики улучшает:\nДоступность — для пользователей с ограниченными возможностями (экранная речь корректно интерпретирует структуру),\nSEO — поисковые системы лучше понимают и ранжируют содержимое,\nПоддержку кода — разработчики быстрее ориентируются в структуре.\nCSS (Cascading Style Sheets) — это язык, предназначенный для оформления HTML-документов. Он отвечает за то, как выглядит страница: цвета, размеры, расположение элементов, анимации, адаптивность под разные устройства.CSS работает через селекторы — правила, определяющие, к каким элементам применяются стили. Пример:h1 { color: #2c3e50; font-size: 2rem; text-align: center;\n}\nЗдесь h1 — селектор, { ... } — набор свойств и их значений.CSS обладает ключевыми особенностями:\nКаскадность (Cascading) — стили могут переопределяться. Если два правила влияют на один элемент, приоритет определяется по специфичности селектора, порядку объявления и использованию !important.\nНаследование — некоторые свойства (например, font-family, color) автоматически передаются дочерним элементам.\nМедиа-запросы — позволяют применять стили в зависимости от характеристик устройства: ширины экрана, ориентации, разрешения. Это основа адаптивного дизайна:\n@media (max-width: 768px) { body { font-size: 14px; }\n} CSS можно подключать тремя способами:\nВнутренний стиль — внутри &lt;style&gt; в &lt;head&gt; (не рекомендуется для больших проектов).\nВнешний файл — через &lt;link rel=\"stylesheet\" href=\"styles.css\"&gt; — лучшая практика.\nВстроенный стиль — атрибут style внутри тега (&lt;p style=\"color:red;\"&gt;) — используется крайне редко, только для экстренных случаев.\nВажно: HTML отвечает за что — CSS — за как выглядит. Их разделение — фундаментальный принцип веб-разработки. Это позволяет:\nМенять дизайн без трогания структуры,\nОдинаковый HTML отображать по-разному на разных устройствах,\nУскорять загрузку за счёт кэширования CSS-файлов,\nОблегчать командную разработку (дизайнеры работают с CSS, разработчики — с HTML и JS). В рамках дисциплины мы не будем изучать свойства CSS, поэтому они остаются на самообучение\nКаждый валидный HTML-документ должен начинаться с DOCTYPE, чтобы браузер знал, какой стандарт использовать. Без него он может перейти в режим \"quirks mode\", где поведение становится непредсказуемым.&lt;!DOCTYPE html&gt;\n— единственное объявление, необходимое для HTML5. Не требует закрывающего тега.Корневой элемент. Атрибут lang обязателен для доступности и SEO:&lt;html lang=\"ru\"&gt;\nУказывает язык содержимого — помогает экранной речи, переводчикам и поисковикам.Не отображается на странице, но содержит метаданные, необходимые для работы браузера и поисковых систем:\n&lt;meta charset=\"UTF-8\"&gt; — задаёт кодировку символов. UTF-8 поддерживает все языки мира — обязательный элемент.\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; — критически важен для мобильных устройств. Без него страница будет масштабироваться как на десктопе, что делает её нечитаемой на телефоне.\n&lt;title&gt; — название вкладки браузера и заголовок в результатах поиска. Должен быть уникальным и описательным.\n&lt;link&gt; — подключение внешних ресурсов: CSS, favicon, шрифтов.\n&lt;script&gt; — подключение JavaScript (может находиться и в &lt;head&gt;, и в &lt;body&gt;, но это отдельная тема).\nПример полного &lt;head&gt;:&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Моя первая страница&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"styles.css\"&gt; &lt;link rel=\"icon\" href=\"favicon.ico\" type=\"image/x-icon\"&gt;\n&lt;/head&gt;\nСодержит всё, что видит пользователь. Внутри могут быть любые элементы, включая:\nЗаголовки: &lt;h1&gt; до &lt;h6&gt; — иерархия важности. &lt;h1&gt; — главный заголовок страницы, только один.\nПараграфы: &lt;p&gt; — для текстовых блоков.\nСписки: &lt;ul&gt; — неупорядоченный (с точками),\n&lt;ol&gt; — упорядоченный (с номерами),\n&lt;li&gt; — элемент списка. Изображения: &lt;img src=\"...\" alt=\"...\"&gt; — alt обязателен для доступности и SEO.\nСсылки: &lt;a href=\"...\"&gt;текст&lt;/a&gt; — href — адрес перехода.\nКнопки: &lt;button&gt;...&lt;/button&gt; — для взаимодействия.\nФормы: &lt;form&gt;, &lt;input&gt;, &lt;label&gt; — для сбора данных.\nПример минимальной, но корректной структуры &lt;body&gt;:&lt;body&gt; &lt;header&gt; &lt;h1&gt;Добро пожаловать!&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;Это основной текст страницы.&lt;/p&gt; &lt;button id=\"myButton\"&gt;Нажми меня&lt;/button&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;&amp;copy; 2025 Моя компания&lt;/p&gt; &lt;/footer&gt;\n&lt;/body&gt;\nHTML — дерево. Элементы должны быть правильно вложены:\n✅ Правильно:&lt;p&gt;&lt;strong&gt;Жирный текст&lt;/strong&gt; внутри параграфа&lt;/p&gt;\n❌ Неправильно:&lt;p&gt;&lt;strong&gt;Жирный текст&lt;/p&gt;&lt;/strong&gt; &lt;!-- Нарушена вложенность --&gt;\nБраузеры пытаются исправить ошибки, но это приводит к непредсказуемому поведению, особенно в сложных случаях.\nИспользуйте семантические теги вместо &lt;div&gt; там, где это возможно.\nНе используйте &lt;h1&gt;–&lt;h6&gt; исключительно для изменения размера шрифта — используйте CSS.\nВсе изображения должны иметь alt — даже если пустой (alt=\"\"), если они декоративные.\nДля кнопок и ссылок используйте правильные теги: &lt;button&gt; — для действий, &lt;a&gt; — для переходов.\nПоддерживайте чистую и читаемую структуру: отступы, переносы, комментарии (если нужно).\nВсегда проверяйте валидность кода через <a data-tooltip-position=\"top\" aria-label=\"https://validator.w3.org/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://validator.w3.org/\" target=\"_self\">validator.w3.org</a>.\nDOM (Document Object Model — Модель объектов документа) — это программное представление веб-документа (обычно HTML или XML), созданное браузером в виде иерархического дерева объектов, где каждый элемент документа — это объект, доступный для манипуляций через JavaScript.DOM не является частью самого HTML-файла. Он динамически генерируется браузером при загрузке страницы: парсер читает HTML-код и превращает его в структуру из узлов (nodes), которые можно изменять, добавлять, удалять или запрашивать с помощью JavaScript.Каждый элемент HTML становится узлом (node) в DOM-дереве:\nЭлементные узлы — теги (&lt;div&gt;, &lt;p&gt;, &lt;button&gt; и т.д.)\nТекстовые узлы — текст внутри тегов\nАтрибутные узлы — атрибуты элементов (id, class, href)\nКорневой узел — &lt;html&gt;\nДочерние и родительские узлы — элементы связаны отношениями «родитель–ребёнок»\nПример HTML:&lt;div id=\"container\"&gt; &lt;h1&gt;Привет, мир!&lt;/h1&gt; &lt;p&gt;Это параграф.&lt;/p&gt;\n&lt;/div&gt;\nСоответствующее DOM-дерево:html\n└── body └── div#container ├── h1 │ └── #text: \"Привет, мир!\" └── p └── #text: \"Это параграф.\"\nКаждый узел имеет свойства и методы, позволяющие взаимодействовать с ним. Например:\nelement.tagName — имя тега,\nelement.textContent — содержимое текста,\nelement.id, element.className — значения атрибутов,\nelement.appendChild(), element.removeChild() — управление дочерними узлами.\nJavaScript не может напрямую работать с HTML-кодом файла. Он работает только с DOM-представлением, которое браузер создал в памяти. Это позволяет:\nДинамически изменять содержимое страницы без перезагрузки (например, обновлять список задач, менять текст кнопки),\nРеагировать на действия пользователя — клики, ввод текста, скроллинг,\nИзменять стили элементов — через element.style,\nДобавлять и удалять элементы — например, создавать новые карточки товаров по запросу,\nПолучать информацию о состоянии страницы — размер окна, положение элементов, состояние форм.\nБез DOM JavaScript был бы бесполезен на веб-странице — он просто не имел бы «точки входа» в контент.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Что такое HTML, CSS","level":2,"id":"Что_такое_HTML,_CSS_0"},{"heading":"Структура HTML","level":2,"id":"Структура_HTML_0"},{"heading":"<code>&lt;html&gt;</code>","level":3,"id":"`<html>`_0"},{"heading":"<code>&lt;head&gt;</code>","level":3,"id":"`<head>`_0"},{"heading":"<code>&lt;body&gt;</code>","level":3,"id":"`<body>`_0"},{"heading":"Вложенность и иерархия","level":3,"id":"Вложенность_и_иерархия_0"},{"heading":"Рекомендации по структуре","level":3,"id":"Рекомендации_по_структуре_0"},{"heading":"Что такое DOM","level":2,"id":"Что_такое_DOM_0"},{"heading":"Структура DOM как дерева","level":3,"id":"Структура_DOM_как_дерева_0"},{"heading":"Зачем нужен DOM?","level":3,"id":"Зачем_нужен_DOM?_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№3/основные-понятия-веб-страницы.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434777630,"modifiedTime":1760434777630,"sourceSize":15642,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №3/Основные понятия веб страницы.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№3/основные-понятия-веб-страницы.html","showInTree":true,"treeOrder":49,"backlinks":["лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№3/самое-простое-использование-javascript.html":{"title":"Самое простое использование JavaScript","icon":"","description":"Для быстрого тестирования и экспериментов с JavaScript можно использовать консоль разработчика — встроенную инструментальную панель в любом современном браузере (Chrome, Firefox, Edge, Safari). Открыть её можно сочетанием клавиш F12 или Ctrl+Shift+I (на macOS — Cmd+Option+I), затем перейти на вкладку Console.Консоль позволяет выполнять JavaScript-код прямо в браузере без создания HTML-файлов. Это идеальное место для проверки синтаксиса, отладки простых выражений и изучения поведения языка в реальном времени.\n<img alt=\"Pasted image 20250912212732.png\" src=\"материалы/файлы/pasted-image-20250912212732.png\" target=\"_self\">Для вывода информации в консоль используется функция console.log():console.log(\"Привет, мир!\");\nconsole.log(42);\nconsole.log(true);\n<br><img alt=\"Pasted image 20250912212810.png\" src=\"материалы/файлы/pasted-image-20250912212810.png\" target=\"_self\">Эта команда — основной инструмент отладки на начальных этапах. Она выводит переданные значения в консоль, помогая увидеть, что происходит в коде. Можно передавать несколько аргументов:console.log(\"Значение переменной:\", variableName);\nТакже доступны другие методы:\nconsole.error() — для ошибок (выводится красным),\nconsole.warn() — для предупреждений (жёлтый цвет),\nconsole.table() — для удобного отображения массивов и объектов в виде таблицы.\nДля показа пользователю простого сообщения используется функция alert():alert(\"Это сообщение от JavaScript!\");\n<br><img alt=\"Pasted image 20250912212840.png\" src=\"материалы/файлы/pasted-image-20250912212840.png\" target=\"_self\">Она выводит модальное окно с текстом, которое блокирует взаимодействие с страницей до нажатия кнопки «ОК». Используется исключительно для учебных целей и быстрой обратной связи — в реальных приложениях alert() не применяется из-за плохого пользовательского опыта.\n⚠️ Не используйте alert() в продакшене — он нарушает поток работы пользователя и не поддерживает стилизацию.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Консоль разработчика в браузере","level":2,"id":"Консоль_разработчика_в_браузере_0"},{"heading":"Базовые команды","level":2,"id":"Базовые_команды_0"},{"heading":"Вывод в консоль","level":3,"id":"Вывод_в_консоль_0"},{"heading":"Оповещение в браузере","level":3,"id":"Оповещение_в_браузере_0"}],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№3/самое-простое-использование-javascript.html","pathToRoot":"../../../..","attachments":["материалы/файлы/pasted-image-20250912212732.html","материалы/файлы/pasted-image-20250912212810.html","материалы/файлы/pasted-image-20250912212840.html"],"createdTime":1760434736544,"modifiedTime":1760434736544,"sourceSize":3060,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №3/Самое простое использование JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№3/самое-простое-использование-javascript.html","showInTree":true,"treeOrder":50,"backlinks":["лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№3/создание-своей-html-страницы.html":{"title":"Создание своей HTML страницы","icon":"","description":"Чтобы создать HTML-страницу, достаточно использовать любой текстовый редактор — даже Блокнот. Однако для эффективной разработки рекомендуется использовать современный редактор кода, такой как Visual Studio Code (VS Code).HTML-страница — это текстовый файл с расширением .html. Минимальная структура HTML-документа выглядит так:&lt;!DOCTYPE html&gt;\n&lt;html lang=\"ru\"&gt;\n&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Моя первая страница&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt; &lt;h1&gt;Привет, мир!&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nСохраните этот код в файл с именем, например, index.html. Откройте его в браузере — вы увидите заголовок «Привет, мир!». Это и есть ваша первая веб-страница.<a data-href=\"Как создавать файлы с определённым расширением\" href=\"материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Как создавать файлы с определённым расширением</a>JavaScript можно подключать к HTML-странице двумя основными способами: встроенно (внутри HTML-файла) или через внешний файл. Второй способ — единственно правильный для профессиональной разработки.JavaScript можно вставить прямо внутрь HTML-документа с помощью тега &lt;script&gt;:&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt; &lt;title&gt;Страница с встроенным JS&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt; &lt;h1&gt;Привет!&lt;/h1&gt; &lt;script&gt; alert(\"Это встроенный JavaScript!\"); document.write(\"&lt;p&gt;Текст добавлен скриптом.&lt;/p&gt;\"); &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nПочему это не рекомендуется:\nНарушает принцип разделения ответственности: структура (HTML), стиль (CSS) и логика (JS) должны быть разделены.\nСложно поддерживать и масштабировать код — особенно при росте проекта.\nЗатрудняется повторное использование кода между страницами.\nУхудшается читаемость и тестирование.\nМожет замедлять загрузку страницы, если скрипт большой.\nИспользуйте этот способ только для быстрых экспериментов, демонстраций или очень простых примеров.Правильный и стандартный способ — создать отдельный файл с расширением .js и подключить его к HTML:\nСоздайте файл script.js в той же папке, что и index.html.\nНапишите в нём JavaScript-код:\n// script.js\nalert(\"Это внешний JavaScript-файл!\");\ndocument.querySelector('h1').style.color = 'blue'; Подключите его в HTML перед закрывающим тегом &lt;/body&gt;:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt; &lt;title&gt;Страница с внешним JS&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt; &lt;h1&gt;Привет!&lt;/h1&gt; &lt;script src=\"script.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nПреимущества:\nЧистый, организованный код.\nВозможность переиспользования одного файла на нескольких страницах.\nУпрощённая отладка и версионный контроль (Git).\nЛучшая производительность — браузер может кэшировать внешние скрипты.\nJavaScript следует подключать в самом конце тела HTML-документа, перед закрывающим тегом &lt;/body&gt;.Когда браузер встречает тег &lt;script&gt; во время парсинга HTML, он приостанавливает загрузку и разбор DOM-дерева, чтобы загрузить и выполнить скрипт. Если скрипт подключен в &lt;head&gt; или в начале &lt;body&gt;, а он пытается взаимодействовать с элементами, которые ещё не загружены — возникнет ошибка:&lt;head&gt; &lt;script src=\"script.js\"&gt;&lt;/script&gt; &lt;!-- ❌ Опасно! --&gt;\n&lt;/head&gt;\n&lt;body&gt; &lt;button id=\"myButton\"&gt;Нажми меня&lt;/button&gt;\n&lt;/body&gt;\nЕсли в script.js написано:document.getElementById('myButton').addEventListener('click', () =&gt; { alert('Клик!');\n});\n— то скрипт выполнится до того, как кнопка появится в DOM, и getElementById вернёт null. Результат — ошибка в консоли.&lt;body&gt; &lt;button id=\"myButton\"&gt;Нажми меня&lt;/button&gt; &lt;script src=\"script.js\"&gt;&lt;/script&gt; &lt;!-- ✅ Безопасно: DOM уже построен --&gt;\n&lt;/body&gt;\nТеперь браузер сначала полностью загрузит и отрисует все элементы страницы, а только потом выполнит скрипт — и все запросы к DOM будут успешными.\nБыстрая отрисовка контента: пользователь видит страницу быстрее, без задержек из-за загрузки скриптов.\nПредсказуемое поведение: код работает только тогда, когда всё, к чему он обращается, уже существует.\nСовместимость с современными практиками: так делают все крупные фреймворки и библиотеки. Если скрипт не зависит от DOM (например, модуль аналитики, который запускается сразу при загрузке страницы), его можно размещать в &lt;head&gt;.\nИспользование атрибута defer (в &lt;head&gt;) позволяет отложить выполнение скрипта до завершения парсинга HTML — это альтернатива размещению в конце, но требует понимания нюансов.\n&lt;head&gt; &lt;script src=\"script.js\" defer&gt;&lt;/script&gt; &lt;!-- ✅ Альтернатива, если нужно в head --&gt;\n&lt;/head&gt; ✅ Рекомендация: Всегда подключайте JavaScript-файлы перед закрывающим тегом &lt;/body&gt;, если только вы точно не знаете, что делаете и почему используете defer или async. Это — базовое правило надёжной и предсказуемой работы JavaScript на веб-странице.\nЧтобы реагировать на действия пользователя (например, нажатие кнопки), можно назначить обработчик события двумя способами: через атрибуты HTML или через JavaScript. Второй способ — единственный корректный для профессиональной разработки.Можно напрямую вписать JavaScript-код в атрибут onclick элемента:&lt;button onclick=\"alert('Кнопка нажата!')\"&gt;Нажми меня&lt;/button&gt;\nИли вызвать функцию:&lt;script&gt;\nfunction handleClick() { alert('Функция вызвана через атрибут!');\n}\n&lt;/script&gt; &lt;button onclick=\"handleClick()\"&gt;Нажми меня&lt;/button&gt;\nПочему это не рекомендуется:\nСмешивание ответственности: логика (JS) и структура (HTML) сливаются — нарушает принцип разделения.\nСложность поддержки: сложно отлаживать, тестировать и рефакторить код, особенно при росте проекта.\nУязвимость к ошибкам: если имя функции опечатано — ошибка не будет заметна до момента клика.\nНе масштабируемо: невозможно динамически добавлять/удалять обработчики, работать с несколькими элементами, использовать замыкания.\nПроблемы с безопасностью: в некоторых контекстах (CSP) использование onclick может быть заблокировано. ⚠️ Используйте этот способ только для быстрых экспериментов или учебных примеров — никогда в продакшене.\nПравильный и стандартный способ — назначать обработчики событий из JavaScript, после того как DOM загружен:&lt;button id=\"myButton\"&gt;Нажми меня&lt;/button&gt; &lt;script src=\"script.js\"&gt;&lt;/script&gt;\n// script.js\nconst button = document.getElementById('myButton'); button.addEventListener('click', function() { alert('Кнопка нажата через addEventListener!');\n});\nПреимущества:\nПолное разделение логики и разметки.\nВозможность назначать несколько обработчиков на один элемент.\nЛегко удалять обработчики через removeEventListener.\nПоддержка современных возможностей JS: стрелочные функции, async/await, замыкания.\nУдобно работать с динамически создаваемыми элементами.\nСовместимость с системами сборки, тестирования и фреймворками.\nДополнительно — лучшая практика:document.addEventListener('DOMContentLoaded', () =&gt; { const button = document.getElementById('myButton'); if (button) { button.addEventListener('click', () =&gt; { console.log('Клик обработан надёжно'); }); }\n});\nЭто гарантирует, что скрипт выполнится только после полной загрузки DOM, даже если он подключён в &lt;head&gt;.Представим, что у нас есть кнопка в HTML:&lt;button id=\"myButton\"&gt;Нажми меня&lt;/button&gt;\nМы хотим, чтобы при нажатии на неё в консоль браузера выводилось сообщение: \"Кнопка была нажата!\"\nУбедитесь, что у вас есть файл script.js, и он подключен в конце &lt;body&gt;:&lt;body&gt; &lt;button id=\"myButton\"&gt;Нажми меня&lt;/button&gt; &lt;script src=\"script.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\nВ script.js напишите:const button = document.getElementById('myButton');\nЭта строка говорит браузеру:\n👉 «Найди элемент на странице, у которого атрибут id=\"myButton\"» — и сохрани его в переменную button.Теперь добавьте эту строку:button.addEventListener('click', () =&gt; { console.log('Кнопка была нажата!');\n});\nЧто здесь происходит (без функций):\naddEventListener — это встроенная команда, которая привязывает действие к элементу.\n'click' — это тип события, которое мы хотим отслеживать (нажатие).\n() — это просто способ сказать: «здесь будет код, который выполнится при событии».\nconsole.log(...) — это команда, которая выводит текст в окно разработчика (не на экран). ✅ Всё, что внутри { } — это просто набор команд, которые должны сработать, когда пользователь кликнет.\nКогда пользователь кликает по кнопке — в консоли браузера появляется сообщение: Кнопка была нажата!\nЭтот шаблон — основа всего дальнейшего взаимодействия с пользователем. Его нужно запомнить как фиксированную формулу:\nэлемент.addEventListener('событие', () =&gt; { ... });\nИ заменять:\nэлемент — на нужный вам (button, input, div и т.д.)\n'событие' — на нужное (click, mouseover, keydown и т.д.)\n{ ... } — на то, что вы хотите сделать (вывести сообщение, изменить цвет, отправить данные)\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Как создать HTML-страницу","level":3,"id":"Как_создать_HTML-страницу_0"},{"heading":"Как использовать JavaScript на странице","level":3,"id":"Как_использовать_JavaScript_на_странице_0"},{"heading":"В том же HTML файле (не рекомендуется)","level":4,"id":"В_том_же_HTML_файле_(не_рекомендуется)_0"},{"heading":"Подключая внешний файл","level":4,"id":"Подключая_внешний_файл_0"},{"heading":"Где подключать JS — в конце или начале HTML-файла?","level":3,"id":"Где_подключать_JS_—_в_конце_или_начале_HTML-файла?_0"},{"heading":"Почему именно в конце?","level":4,"id":"Почему_именно_в_конце?_0"},{"heading":"Правильный способ:","level":4,"id":"Правильный_способ_0"},{"heading":"Дополнительные преимущества:","level":4,"id":"Дополнительные_преимущества_0"},{"heading":"Исключения:","level":4,"id":"Исключения_0"},{"heading":"Подключение логики обработки в кнопки","level":2,"id":"Подключение_логики_обработки_в_кнопки_0"},{"heading":"Через атрибут в кнопках (не рекомендуется)","level":3,"id":"Через_атрибут_в_кнопках_(не_рекомендуется)_0"},{"heading":"Через назначения обработчиков событий","level":3,"id":"Через_назначения_обработчиков_событий_0"},{"heading":"Добавление обработчика на кнопку — простой пример","level":3,"id":"Добавление_обработчика_на_кнопку_—_простой_пример_0"},{"heading":"Шаг 1: Подключите внешний JavaScript-файл","level":4,"id":"Шаг_1_Подключите_внешний_JavaScript-файл_0"},{"heading":"Шаг 2: Найдите кнопку в JavaScript","level":4,"id":"Шаг_2_Найдите_кнопку_в_JavaScript_0"},{"heading":"Шаг 3: Назначьте обработчик события","level":4,"id":"Шаг_3_Назначьте_обработчик_события_0"},{"heading":"Результат:","level":4,"id":"Результат_0"}],"links":["материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html"],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№3/создание-своей-html-страницы.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434776506,"modifiedTime":1760434776506,"sourceSize":15024,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №3/Создание своей HTML страницы.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№3/создание-своей-html-страницы.html","showInTree":true,"treeOrder":51,"backlinks":["лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№4/примитивные-типы-данных-javascript.html":{"title":"Примитивные типы данных JavaScript","icon":"","description":"Примитивные типы данных — это базовые, неструктурированные значения в JavaScript, которые не содержат свойств или методов сами по себе и не могут быть изменены после создания. Главная особенность примитивов — они передаются по значению: при присваивании или передаче в функцию копируется само значение, а не ссылка на него. Это означает, что если вы присвоите примитивную переменную другой переменной и измените одну из них — другая останется неизменной. Примитивы также не имеют внутреннего состояния — их нельзя расширить, добавить свойства или переопределить. Они являются фундаментом для всех операций в JavaScript и лежат в основе хранения и обработки любых данных — от чисел в расчётах до текста в интерфейсе мобильного приложения.В JavaScript все числа — это числа с плавающей запятой по стандарту IEEE 754. Это значит, что даже целые числа хранятся как дробные, и из-за особенностей двоичного представления могут возникать небольшие погрешности при вычислениях (например, 0.1 + 0.2 !== 0.3). JavaScript не разделяет целые и вещественные числа — всё объединено в один тип number. Поддерживаются положительные, отрицательные, ноль, а также специальные значения Infinity, -Infinity и NaN (Not a Number).Строка в JavaScript — это последовательность символов, заключённая в одинарные ('), двойные (\") или обратные кавычки (`). Обратные кавычки позволяют использовать шаблонные строки — вставлять переменные через ${} и писать многострочный текст без экранирования. Например: `Привет, ${name}!`. Строки неизменяемы — любое изменение создаёт новую строку, а не модифицирует существующую.Логический тип представляет два возможных значения: true и false. Используется для условий, сравнений, флагов состояний (например, загружено ли приложение, авторизован ли пользователь). В JavaScript есть понятие «ложных» и «истинных» значений — например, 0, \"\", null, undefined воспринимаются как false в булевом контексте, но сами по себе они не являются boolean.null — это специальное значение, которое программист присваивает намеренно, чтобы указать: «здесь ничего нет». Это не ошибка и не неопределённость — это осознанное обозначение отсутствия данных. Например, если пользователь не выбрал аватар, можно установить avatarUrl: null. Несмотря на поведение typeof null === 'object' (историческая ошибка языка), null — это примитив.undefined означает, что переменная была объявлена, но ей ещё не присвоено значение. Это автоматическое состояние, которое присваивается переменной при объявлении через let или const без инициализации. Также возвращается, если функция не возвращает значение, или свойство объекта не существует. Отличие от null: undefined — это результат отсутствия действия, а null — результат преднамеренного действия.<img alt=\"Pasted image 20240923235323.png\" src=\"материалы/файлы/pasted-image-20240923235323.png\" target=\"_self\">Symbol — это новый примитивный тип, появившийся в ES6, предназначенный для создания уникальных ключей свойств объектов. Каждый символ, созданный через Symbol(), гарантированно уникален, даже если у них одинаковое описание. Используется редко в базовой разработке, но важен для внутренней работы библиотек и предотвращения коллизий имён свойств. Не нужно запоминать детали — достаточно знать, что он существует и используется для скрытия и защиты ключей.bigint — это тип для работы с целыми числами, превышающими предел Number.MAX_SAFE_INTEGER (около 9 квадриллионов). Чтобы создать bigint, нужно добавить букву n в конец числа: 123456789012345678901234567890n. Он нужен для точных расчётов — например, при работе с финансовыми данными, хешами, криптографией или большими идентификаторами. С bigint нельзя выполнять операции с обычными числами — требуется явное приведение.Оператор typeof в JavaScript используется для определения типа значения на момент выполнения. Он возвращает строку с названием типа данных. Это важный инструмент для отладки, валидации входных данных и безопасной работы с переменными, особенно когда тип неизвестен заранее — например, при получении данных из API или пользовательского ввода.typeof 42; // \"number\"\ntypeof 3.14; // \"number\"\ntypeof -0; // \"number\"\ntypeof Infinity; // \"number\"\ntypeof NaN; // \"number\" typeof \"Привет\"; // \"string\"\ntypeof ''; // \"string\"\ntypeof `Шаблон ${1 + 2}`; // \"string\" typeof true; // \"boolean\"\ntypeof false; // \"boolean\" typeof null; // \"object\" — историческая ошибка языка typeof undefined; // \"undefined\" typeof Symbol('id'); // \"symbol\" typeof 12345678901234567890n; // \"bigint\" typeof function() {}; // \"function\" typeof {}; // \"object\"\ntypeof []; // \"object\" — массивы тоже объекты typeof null возвращает \"object\" — это известная ошибка в спецификации JavaScript, которая осталась ради совместимости.\ntypeof всегда возвращает строку, даже если значение не существует (например, typeof undeclaredVariable вернёт \"undefined\" без ошибки).\nДля проверки массивов или объектов typeof недостаточен — лучше использовать Array.isArray() или instanceof.\nПри работе с JSON-ответами API часто приходят данные неизвестного типа. Например, поле userId может быть числом или строкой. Перед использованием его стоит проверить:if (typeof userId === 'string') { // обработать как строку\n} else if (typeof userId === 'number') { // обработать как число\n}\nПреобразование типов — это процесс изменения значения одного типа данных в другой. В JavaScript, как в языке с динамической типизацией, это происходит постоянно — иногда намеренно, а иногда автоматически, что может приводить к неожиданным результатам. Различают два вида преобразований: явное (когда разработчик сам управляет процессом) и неявное (когда язык делает это автоматически на основе контекста).Явное преобразование — это когда разработчик сознательно и намеренно превращает значение из одного типа в другой с помощью специальных функций или операторов. Это безопасный и предсказуемый способ, который рекомендуется использовать в production-коде.// Число → строка\nString(42); // \"42\"\n(42).toString(); // \"42\"\n42 + \"\"; // \"42\" — это уже неявное, но можно использовать и явно // Строка → число\nNumber(\"123\"); // 123\nNumber(\"3.14\"); // 3.14\nNumber(\"abc\"); // NaN — некорректная строка\nparseInt(\"42px\"); // 42 — преобразует до первого нецифрового символа\nparseFloat(\"3.14abc\"); // 3.14 // Строка → булево\nBoolean(\"hello\"); // true\nBoolean(\"\"); // false — пустая строка — ложь\nBoolean(\"0\"); // true — любая непустая строка — истина, даже \"false\" // Число → булево\nBoolean(0); // false\nBoolean(-1); // true\nBoolean(1); // true\nBoolean(NaN); // false\nBoolean(Infinity); // true // Любое значение → булево через двойное отрицание\n!!\"text\"; // true\n!!0; // false\n!!null; // false // Объект → строка\nString({}); // \"[object Object]\"\nJSON.stringify({}); // \"{}\" — для структурированного представления При получении данных из формы (input.value всегда строка).\nПри работе с API, где типы могут быть неточными.\nПри необходимости гарантировать поведение — например, чтобы +\"5\" не вызывало путаницы.\nВ тестах и валидации входных данных. ✅ Правило: Если вы не уверены в типе — приведите его явно. Это делает код понятнее и надёжнее.\nНеявное преобразование — это когда JavaScript автоматически меняет тип значения, чтобы выполнить операцию. Оно происходит при использовании операторов +, -, *, /, ==, if(), while() и других в контекстах, требующих другого типа. Это мощный механизм, но он часто вызывает ошибки у новичков, потому что поведение не всегда очевидно.Если хотя бы один операнд — строка, то оба приводятся к строке:\"5\" + 3; // \"53\" — строка + число → конкатенация\n5 + \"3\"; // \"53\"\n\"Привет\" + 123; // \"Привет123\"\ntrue + \"!\" // \"true!\"\nЕсли оба операнда — числа — выполняется математическое сложение:5 + 3; // 8\n0.1 + 0.2; // 0.30000000000000004 — особенность IEEE 754\nМатематическое сложение так-же происходит если среди операндов нет строк, в таком случае операнды преобразуются в числа:5 + true; // 6 = 5 + 1\nfalse + Infinity; // Infinity - что тоже является числом // 0 + бесконечность\nЭти операторы всегда пытаются привести операнды к числам:\"5\" - \"3\"; // 2 — строки превратились в числа\n\"10\" * \"2\"; // 20\n\"15\" / \"3\"; // 5\n\"abc\" - 1; // NaN — нельзя преобразовать \"abc\" в число\ntrue - 1; // 0 — true → 1\nfalse * 5; // 0 — false → 0\nОператор == выполняет неявное приведение типов перед сравнением — это главный источник ошибок:\"\" == 0; // true — пустая строка → 0\n\"0\" == 0; // true — \"0\" → 0\nfalse == 0; // true — false → 0\nnull == undefined;// true — особое правило: они равны друг другу\n0 == false; // true — false → 0\n\"1\" == true; // true — \"1\" → 1, true → 1\n[] == 0; // true — пустой массив → \"\" → 0\n[1] == 1; // true — [1] → \"1\" → 1\n[1,2] == \"1,2\"; // true — массив → строка \"1,2\"\n{} == \"[object Object]\"; // false — объекты сравниваются по ссылке, но при приведении к строке — да, но тут логика сложнее ⚠️ Важно: null == undefined — единственное исключение, где два разных примитива считаются равными.\nЛюбое значение приводится к булевому типу:if (\"0\") { console.log(\"Это правда!\"); } // сработает — непустая строка → true\nif (0) { console.log(\"Не сработает\"); } // не сработает — 0 → false\nif ([]) { console.log(\"Это правда!\"); } // сработает — массив → true\nif ({}) { console.log(\"Это правда!\"); } // сработает — объект → true\nif (null) { console.log(\"Не сработает\"); } // не сработает — null → false\nif (undefined) { console.log(\"Не сработает\"); } // не сработает 📌 Эти 6 значений называются falsy — всё остальное — truthy.\n// Начинающий разработчик ожидает:\n\"5\" == 5; // true — логично?\n\"5\" === 5; // false — теперь понятно! // А вот так:\n[] == ![]; // true — почему?\n// Разбор:\n// ![] → false (пустой массив → true → отрицание → false)\n// [] == false → \"\" == false → 0 == 0 → true // Или:\n\" \\t\\n\" == 0; // true — строка с пробелами → пустая после trim → 0\nТакие случаи ведут к багам, которые сложно отследить. Особенно в мобильных приложениях, где данные приходят из сети и могут быть неожиданного типа.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Типы:","level":2,"id":"Типы_0"},{"heading":"<code>number</code> — целые и дробные числа, особенности представления (IEEE 754)","level":3,"id":"`number`_—_целые_и_дробные_числа,_особенности_представления_(IEEE_754)_0"},{"heading":"<code>string</code> — последовательность символов, кавычки, шаблонные строки","level":3,"id":"`string`_—_последовательность_символов,_кавычки,_шаблонные_строки_0"},{"heading":"<code>boolean</code> — <code>true</code> / <code>false</code>","level":3,"id":"`boolean`_—_`true`_/_`false`_0"},{"heading":"<code>null</code> — явное отсутствие значения","level":3,"id":"`null`_—_явное_отсутствие_значения_0"},{"heading":"<code>undefined</code> — неинициализированная переменная","level":3,"id":"`undefined`_—_неинициализированная_переменная_0"},{"heading":"<code>symbol</code> — уникальный идентификатор","level":3,"id":"`symbol`_—_уникальный_идентификатор_0"},{"heading":"<code>bigint</code> — произвольной точности целые числа","level":3,"id":"`bigint`_—_произвольной_точности_целые_числа_0"},{"heading":"Определение типа: <code>typeof</code>","level":2,"id":"Определение_типа_`typeof`_0"},{"heading":"Примеры использования <code>typeof</code>:","level":3,"id":"Примеры_использования_`typeof`_0"},{"heading":"Важные особенности:","level":3,"id":"Важные_особенности_0"},{"heading":"Пример практического применения:","level":3,"id":"Пример_практического_применения_0"},{"heading":"Преобразование типов: явное и неявное","level":2,"id":"Преобразование_типов_явное_и_неявное_0"},{"heading":"Явное преобразование типов","level":3,"id":"Явное_преобразование_типов_0"},{"heading":"Примеры явного преобразования:","level":4,"id":"Примеры_явного_преобразования_0"},{"heading":"Когда использовать явное преобразование:","level":4,"id":"Когда_использовать_явное_преобразование_0"},{"heading":"Неявное преобразование типов (коэрши́он)","level":3,"id":"Неявное_преобразование_типов_(коэрши́он)_0"},{"heading":"Основные правила неявного преобразования:","level":4,"id":"Основные_правила_неявного_преобразования_0"},{"heading":"1. Оператор + — сложение или конкатенация?","level":5,"id":"1._Оператор_`+`_—_сложение_или_конкатенация?_0"},{"heading":"2. Операторы -, *, /, % — только числа","level":5,"id":"2._Операторы_`-`,_`*`,_`/`,_`%`_—_только_числа_0"},{"heading":"3. Сравнение с == (абстрактное равенство)","level":5,"id":"3._Сравнение_с_`==`_(абстрактное_равенство)_0"},{"heading":"4. Условия в if, while, ? :","level":5,"id":"4._Условия_в_`if`,_`while`,_`?_`_0"},{"heading":"Таблица неявного приведения к булевому типу («ложные» значения):","level":4,"id":"Таблица_неявного_приведения_к_булевому_типу_(«ложные»_значения)_0"},{"heading":"Почему неявное преобразование опасно?","level":3,"id":"Почему_неявное_преобразование_опасно?_0"}],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№4/примитивные-типы-данных-javascript.html","pathToRoot":"../../../..","attachments":["материалы/файлы/pasted-image-20240923235323.html"],"createdTime":1760434782744,"modifiedTime":1760434782744,"sourceSize":18935,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №4/Примитивные типы данных JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№4/примитивные-типы-данных-javascript.html","showInTree":true,"treeOrder":53,"backlinks":["лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№4/установка-и-базовое-использование-node.js.html":{"title":"Установка и базовое использование Node.js","icon":"","description":"Node.js можно установить двумя основными способами. Первый — через официальный установщик с сайта nodejs.org: он подходит для новичков и автоматически настраивает Node.js и npm (советую вам использовать этот способ). Второй — через nvm (Node Version Manager): это инструмент для управления несколькими версиями Node.js на одном компьютере, что особенно полезно при работе с разными проектами. На macOS и Linux nvm устанавливается через терминал командой curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash, на Windows — через nvm-windows. После установки nvm можно легко переключаться между версиями: nvm install 20, nvm use 20.После установки важно проверить, что Node.js и npm (менеджер пакетов) работают корректно. В терминале введите node -v — вы увидите текущую версию Node.js (например, v20.12.0). Затем введите npm -v — вы увидите версию npm (например, 10.5.0). Если обе команды возвращают номера версий — среда готова к работе. Если нет — перезагрузите терминал или проверьте путь установки.Чтобы запустить JavaScript-файл в Node.js, создайте файл с расширением .js (например, app.js), напишите в нём любой код — например, console.log('Привет, Node.js!'); — и сохраните. В терминале перейдите в папку с файлом и выполните команду node app.js. Node.js прочитает файл, выполнит его содержимое и выведет результат в консоль. Это простейший способ тестировать серверный код, не используя браузер.Так-же, для вас будет проще запускать его сразу из редактора кода.Нажимаем на f5 находясь в нужном файле.\nВ первый запуск у вас спросят выбрать способ дебагера, выбираем Node.js.\n<img alt=\"Pasted image 20240928221620.png\" src=\"материалы/файлы/pasted-image-20240928221620.png\" target=\"_self\">ПКМ по файлу.<br><img alt=\"Pasted image 20240928222139.png\" src=\"материалы/файлы/pasted-image-20240928222139.png\" target=\"_self\">нажимаем кнопку Run \"название скрипта\"Дальше можем просто нажимать на кнопку \"запуск\"<br>\n<img alt=\"Pasted image 20240928222237.png\" src=\"материалы/файлы/pasted-image-20240928222237.png\" target=\"_self\">REPL (Read-Eval-Print Loop) — это интерактивная оболочка Node.js, которая позволяет сразу писать и выполнять JavaScript-код в терминале. Чтобы запустить её, введите node без аргументов. Вы увидите приглашение &gt; — теперь можете вводить выражения: 2 + 2, const name = 'Миша'; console.log(name);. Результат выводится мгновенно. Для выхода из REPL нажмите Ctrl + C дважды или введите .exit. REPL идеален для быстрой проверки синтаксиса, экспериментов с API или отладки небольших фрагментов кода.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Установка через nvm или официальный установщик","level":2,"id":"Установка_через_nvm_или_официальный_установщик_0"},{"heading":"Проверка версии (<code>node -v</code>, <code>npm -v</code>)","level":2,"id":"Проверка_версии_(`node_-v`,_`npm_-v`)_0"},{"heading":"Запуск скрипта через <code>node filename.js</code>","level":2,"id":"Запуск_скрипта_через_`node_filename.js`_0"},{"heading":"Запуск в Visual Studio Code","level":3,"id":"Запуск_в_Visual_Studio_Code_0"},{"heading":"Запуск в WebStorm","level":3,"id":"Запуск_в_WebStorm_0"},{"heading":"Работа с REPL (интерактивная оболочка)","level":2,"id":"Работа_с_REPL_(интерактивная_оболочка)_0"}],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№4/установка-и-базовое-использование-node.js.html","pathToRoot":"../../../..","attachments":["материалы/файлы/pasted-image-20240928221620.html","материалы/файлы/pasted-image-20240928222139.html","материалы/файлы/pasted-image-20240928222237.html"],"createdTime":1760434745086,"modifiedTime":1760434745086,"sourceSize":4135,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №4/Установка и базовое использование Node.js.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№4/установка-и-базовое-использование-node.js.html","showInTree":true,"treeOrder":54,"backlinks":["лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№4/что-такое-node.js.html":{"title":"Что такое Node.js","icon":"","description":"Node.js — это среда выполнения JavaScript, которая позволяет запускать код на сервере, а не только в браузере. Она построена на движке V8 от Google и даёт JavaScript доступ к системным ресурсам: файловой системе, сети, процессам. Это делает JavaScript полноценным языком для создания серверных приложений, инструментов разработки и автоматизации — всё на том же языке, что и фронтенд.Node.js появился в 2009 году благодаря Райану Далю — разработчику, который задался вопросом: почему JavaScript, который так хорошо справляется с асинхронными событиями в браузере (клики, загрузки, запросы), не может делать то же самое на сервере? Он объединил движок V8, который быстро выполняет JavaScript, с библиотекой libuv — специальной системой для асинхронного ввода-вывода. В результате получилась первая среда, где сервер мог обрабатывать тысячи одновременных соединений без создания отдельного потока на каждое — это стало прорывом в производительности.JavaScript на сервере упрощает разработку. Если вы пишете мобильное приложение на React Native или используете JSON-API, то логика, данные и даже части валидации могут быть общими между клиентом и сервером. Нет необходимости учить два разных языка — JavaScript на фронтенде и, например, Java или Python на бэкенде. Это снижает сложность команды, ускоряет разработку и делает поддержку проще. Также огромная экосистема npm дарит готовые решения для любой задачи — от баз данных до авторизации.В браузере JavaScript работает в ограниченной среде: он может работать с DOM, отправлять запросы через fetch, хранить данные в localStorage, но не может читать файлы с диска или слушать порты. В Node.js этих ограничений нет. Вместо window и document вы получаете global, process, require, module. Вы можете использовать модули fs для работы с файлами, http для создания сервера, path для обработки путей, child_process для запуска команд. То есть — Node.js превращает JavaScript из языка «для страниц» в язык «для всего».Node.js — невидимый двигатель современной мобильной разработки.\n— Backend для API: большинство мобильных приложений получают данные через REST или GraphQL. Эти API почти всегда пишут на Node.js (Express, NestJS, Fastify).\n— Инструменты сборки: Webpack, Metro, Babel, Vite — все они написаны на Node.js и собирают ваш код в приложение для iOS и Android.\n— CLI-инструменты: Expo CLI, Ionic CLI, Capacitor — они создают проекты, добавляют плагины, настраивают конфиги — и всё это работает на Node.js.\n— CI/CD: когда вы заливаете код в GitHub, а система автоматически собирает APK/IPA и публикует его — за этим стоит скрипт на Node.js.\nДаже если вы никогда не напишете строчку на Node.js — вы будете им пользоваться каждый день. Без него мобильная разработка была бы намного медленнее, сложнее и менее гибкой.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Определение Node.js","level":2,"id":"Определение_Node.js_0"},{"heading":"История появления (V8, Ryan Dahl)","level":2,"id":"История_появления_(V8,_Ryan_Dahl)_0"},{"heading":"Зачем нужен JavaScript на сервере","level":2,"id":"Зачем_нужен_JavaScript_на_сервере_0"},{"heading":"Отличие от браузерного JavaScript (глобальные объекты, доступ к файловой системе, сети)","level":2,"id":"Отличие_от_браузерного_JavaScript_(глобальные_объекты,_доступ_к_файловой_системе,_сети)_0"},{"heading":"Примеры использования Node.js в мобильной разработке (backend для API, инструменты сборки, CI/CD)","level":2,"id":"Примеры_использования_Node.js_в_мобильной_разработке_(backend_для_API,_инструменты_сборки,_CI/CD)_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№4/что-такое-node.js.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434752807,"modifiedTime":1760434752807,"sourceSize":5177,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №4/Что такое Node.js.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№4/что-такое-node.js.html","showInTree":true,"treeOrder":55,"backlinks":["лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№5/арифметические-операторы-javascript.html":{"title":"Арифметические операторы JavaScript","icon":"","description":"Арифметические операторы — это основные инструменты для выполнения математических вычислений в JavaScript. Они работают с числами и возвращают числовые результаты.Пример использования остатка: const isEven = number =&gt; number % 2 === 0;\nconsole.log(isEven(4)); // true\nconsole.log(isEven(7)); // false\nОператор ** возводит первое число в степень, указанную вторым:console.log(2 ** 4); // 16 (2 × 2 × 2 × 2)\nconsole.log(9 ** 0.5); // 3 (квадратный корень из 9)\nЭто удобно для расчётов: например, при вычислении площади квадрата или сложных процентов.Унарный плюс + преобразует значение в число:console.log(+\"42\"); // 42 (строка → число)\nconsole.log(+\"hello\"); // NaN (непреводимая строка)\nconsole.log(+true); // 1\nconsole.log(+false); // 0\nУнарный минус - меняет знак числа:console.log(-5); // -5\nconsole.log(-(3 + 2)); // -5\nconsole.log(-\"10\"); // -10 (сначала приведение к числу, потом отрицание)\nИнкремент ++ увеличивает значение на 1, декремент -- уменьшает на 1.Различают две формы:Сначала изменяет значение, потом возвращает его:let a = 5;\nconsole.log(++a); // 6 — сначала прибавили, потом вернули\nconsole.log(a); // 6\nСначала возвращает текущее значение, потом изменяет:let b = 5;\nconsole.log(b++); // 5 — вернули старое значение\nconsole.log(b); // 6 — теперь уже увеличено 💡 Важно: в циклах и выражениях разница между i++ и ++i может привести к ошибкам, если не учитывать порядок.\nJavaScript имеет специальные числовые значения, которые появляются при некорректных операциях.Появляется, когда операция не может быть выполнена:console.log(0 / 0); // NaN\nconsole.log(\"abc\" * 2); // NaN\nconsole.log(NaN + 5); // NaN\nconsole.log(NaN === NaN); // false — важно! NaN не равен самому себе\nДля проверки на NaN используйте Number.isNaN():console.log(Number.isNaN(NaN)); // true\nconsole.log(Number.isNaN(\"hello\")); // false\nПолучается при делении на ноль или при переполнении:console.log(1 / 0); // Infinity\nconsole.log(-1 / 0); // -Infinity\nconsole.log(Number.MAX_VALUE * 2); // Infinity console.log(Infinity + 1); // Infinity\nconsole.log(Infinity - Infinity); // NaN ⚠️ Не используйте == Infinity для проверки — лучше применять isFinite(): console.log(isFinite(1000)); // true\nconsole.log(isFinite(Infinity)); // false ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Основные арифметические операторы","level":3,"id":"Основные_арифметические_операторы_0"},{"heading":"Возведение в степень","level":3,"id":"Возведение_в_степень_0"},{"heading":"Унарный плюс и минус","level":3,"id":"Унарный_плюс_и_минус_0"},{"heading":"Инкремент и декремент","level":3,"id":"Инкремент_и_декремент_0"},{"heading":"Префиксная форма (<code>++x</code>, <code>--x</code>)","level":4,"id":"Префиксная_форма_(`++x`,_`--x`)_0"},{"heading":"Постфиксная форма (<code>x++</code>, <code>x--</code>)","level":4,"id":"Постфиксная_форма_(`x++`,_`x--`)_0"},{"heading":"Особенности: NaN и Infinity","level":3,"id":"Особенности_NaN_и_Infinity_0"},{"heading":"<code>NaN</code> — Not a Number","level":4,"id":"`NaN`_—_Not_a_Number_0"},{"heading":"<code>Infinity</code> — бесконечность","level":4,"id":"`Infinity`_—_бесконечность_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№5/арифметические-операторы-javascript.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434747295,"modifiedTime":1760434747296,"sourceSize":4417,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Арифметические операторы JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№5/арифметические-операторы-javascript.html","showInTree":true,"treeOrder":57,"backlinks":["лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№5/логические-операторы-javascript.html":{"title":"Логические операторы JavaScript","icon":"","description":"Логические операторы — &amp;&amp; (И), || (ИЛИ) и ! (НЕ) — позволяют комбинировать и инвертировать логические значения. В JavaScript они работают не только с true и false, но и с любыми значениями, благодаря особенностям приведения типов и механизму короткого замыкания.Возвращает true, если оба операнда истинны.\nНо в JavaScript он возвращает не булево значение, а один из операндов — первый ложный или последний истинный.console.log(true &amp;&amp; true); // true\nconsole.log(true &amp;&amp; false); // false\nconsole.log(5 &amp;&amp; \"hello\"); // \"hello\" — оба истинны, возвращён второй\nconsole.log(0 &amp;&amp; \"test\"); // 0 — первый ложный, возвращён он же\nconsole.log(\"\" &amp;&amp; null); // \"\" — первый ложный\nЕсли первый операнд — ложный, второй не вычисляется.function log() { console.log(\"Эта функция не вызовется\"); return true;\n} console.log(false &amp;&amp; log()); // false — функция log() НЕ была вызвана ✅ Это полезно для безопасного доступа к свойствам объектов:\nconst user = { profile: { name: \"Alice\" } }; // Безопасно: если user или user.profile отсутствуют — не будет ошибки\nconsole.log(user &amp;&amp; user.profile &amp;&amp; user.profile.name); // \"Alice\" // Если бы user был undefined — выражение остановилось бы на первом шаге\nВозвращает первый истинный операнд, или последний, если все ложные.console.log(true || false); // true\nconsole.log(false || \"world\"); // \"world\"\nconsole.log(0 || null || 5 || 10); // 5 — первый истинный\nconsole.log(\"\" || 0 || false); // false — все ложные, возвращён последний\nЕсли первый операнд — истинный, второй не вычисляется.function log() { console.log(\"Эта функция вызовется только если нужно\"); return \"result\";\n} console.log(true || log()); // true — функция log() НЕ вызвана\nfunction greet(name) { name = name || \"Гость\"; // если name пустой/ложный — использовать \"Гость\" console.log(`Привет, ${name}!`);\n} greet(); // \"Привет, Гость!\"\ngreet(\"\"); // \"Привет, Гость!\"\ngreet(null); // \"Привет, Гость!\"\ngreet(\"Анна\"); // \"Привет, Анна!\"\ngreet(0); // \"Привет, Гость!\" — осторожно! ⚠️ Внимание: 0, \"\", null, undefined, NaN — всё это ложные значения.\nЕсли вы ожидаете 0 как валидный ввод — такой подход сломается.\nfunction greet(name) { name = name ?? \"Гость\"; // только null или undefined → заменяются console.log(`Привет, ${name}!`);\n} greet(0); // \"Привет, 0!\" — правильно!\ngreet(undefined); // \"Привет, Гость!\" ✅ Рекомендация: в современных приложениях используйте ?? вместо || для установки значений по умолчанию, если вам важно отличать 0, false, \"\" от null/undefined.\nИнвертирует значение операнда. Возвращает булево значение (true или false).console.log(!true); // false\nconsole.log(!false); // true\nconsole.log(!\"hello\"); // false — строка истинна\nconsole.log(!0); // true — 0 ложен\nconsole.log(!{}); // false — объект истинен\nconsole.log(!!\"text\"); // true — двойное отрицание приводит к булеву значению\nconst isEmpty = !array.length; // true, если массив пуст\nconst hasUser = !!user; // true, если user существует и не null/undefined ✅ Двойное отрицание !!value — популярный способ явно преобразовать любое значение в булево.\nПриоритет (с высшего к низшему):\n! — НЕ (наиболее высокий)\n&amp;&amp; — И\n|| — ИЛИ (наименьший)\nconsole.log(true || false &amp;&amp; false); // true\n// Эквивалентно: true || (false &amp;&amp; false) → true || false → true\nЧтобы избежать путаницы — всегда используйте скобки:console.log((true || false) &amp;&amp; false); // false\n(Больше про приоритет операторов будет в этой же теме)","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Оператор <code>&amp;&amp;</code> — Логическое И","level":3,"id":"Оператор_`&&`_—_Логическое_И_0"},{"heading":"Примеры:","level":4,"id":"Примеры_0"},{"heading":"Короткое замыкание:","level":4,"id":"Короткое_замыкание_0"},{"heading":"Оператор <code>||</code> — Логическое ИЛИ","level":3,"id":"Оператор_`||`_—_Логическое_ИЛИ_0"},{"heading":"Примеры:","level":4,"id":"Примеры_1"},{"heading":"Короткое замыкание:","level":4,"id":"Короткое_замыкание_1"},{"heading":"💡 Ключевое применение: установка значений по умолчанию","level":4,"id":"💡_Ключевое_применение_установка_значений_по_умолчанию_0"},{"heading":"Лучшая практика: используйте <strong>оператор нулевого слияния</strong> <code>??</code> (если поддерживается):","level":4,"id":"Лучшая_практика_используйте_**оператор_нулевого_слияния**_`??`_(если_поддерживается)_0"},{"heading":"Оператор <code>!</code> — Логическое НЕ","level":3,"id":"Оператор_`!`_—_Логическое_НЕ_0"},{"heading":"Примеры:","level":4,"id":"Примеры_2"},{"heading":"Полезное применение: приведение к булеву типу","level":4,"id":"Полезное_применение_приведение_к_булеву_типу_0"},{"heading":"Приоритет операторов","level":3,"id":"Приоритет_операторов_0"},{"heading":"Пример:","level":4,"id":"Пример_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№5/логические-операторы-javascript.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434757030,"modifiedTime":1760434757030,"sourceSize":6159,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Логические операторы JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№5/логические-операторы-javascript.html","showInTree":true,"treeOrder":58,"backlinks":["лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-присваивания-javascript.html":{"title":"Операторы присваивания JavaScript","icon":"","description":"Операторы присваивания используются для записи значений в переменные. В JavaScript они делятся на базовые и составные, а также включают современные операторы, упрощающие работу с потенциально отсутствующими данными.Присваивает значение справа переменной слева.let count = 0;\nlet message = \"Привет\";\nlet isActive = true; Это единственный оператор, который создаёт переменную при первом использовании в глобальной области видимости (если не используется let/const — не рекомендуется).\nСокращённая форма операций, где значение переменной изменяется и сразу присваивается обратно.let score = 100; score += 25; // 125\nscore *= 2; // 250\nscore -= 50; // 200\nscore %= 60; // 20 (остаток от 200 ÷ 60)\nscore **= 2; // 400 (20²) console.log(score); // 400 ✅ Преимущество: короче, читаемее, немного эффективнее — особенно полезны в циклах и обработке данных.\nПрисваивает значение только если левый операнд равен null или undefined.let userLanguage = null;\nuserLanguage ??= \"en\"; // теперь userLanguage = \"en\" let userName = \"\";\nuserName ??= \"Аноним\"; // останется \"\", потому что \"\" ≠ null/undefined let settings = { theme: undefined };\nsettings.theme ??= \"dark\"; // theme станет \"dark\" console.log(settings.theme); // \"dark\" 💡 Отличие от =: ??= не перезаписывает существующие значения, даже если они ложные (0, \"\", false).\nЭто делает его идеальным для установки значений по умолчанию в конфигурациях, настройках, API-ответах.\nlet theme = localStorage.getItem(\"theme\");\ntheme ??= \"light\"; // если не задано — использовать светлую тему let fontSize = localStorage.getItem(\"fontSize\");\nfontSize ??= 16; // если не задано — 16px console.log({ theme, fontSize });\nПрисваивает значение только если предшествующая цепочка существует (не null/undefined).let user = { profile: { name: \"Иван\" } }; // Попытка присвоить значение только если user.profile существует\nuser.profile?.name ??= \"Гость\"; // НЕ сработает — это не присваивание через ?.\nuser.profile?.age ??= 25; // НЕ сработает — age не существует, но ?. не создаёт свойства // А вот так:\nuser.profile?.age = 25; // ❌ Ошибка: нельзя присвоить, если user.profile не существует\nНа самом деле, ?.= — это оператор присваивания, а не объединения. Он работает следующим образом:let obj = {}; obj?.prop = 10; // ❌ ОШИБКА — SyntaxError: Invalid left-hand side expression // Правильно — только если объект существует:\nlet config = { settings: {} };\nconfig.settings?.debug = true; // ✅ Работает — config.settings существует console.log(config.settings.debug); // true // Если объект отсутствует — ничего не происходит:\nlet data = null;\ndata?.value = \"test\"; // Ничего не произойдёт — ошибки нет\nconsole.log(data); // null ⚠️ Важно: ?.= не создаёт свойства — он лишь пропускает присваивание, если левая часть null/undefined.\nОн применяется только к существующим объектам и их вложенным свойствам.\nfunction updateUser(user, newSettings) { user?.profile?.name = newSettings.name; user?.profile?.email = newSettings.email; user?.preferences?.theme = newSettings.theme;\n} updateUser(null, { name: \"Анна\" }); // Ничего не сломается\nupdateUser({ profile: {} }, { name: \"Анна\" }); // profile.name = \"Анна\" — сработает ✅ Идеально подходит для работы с API-ответами, где структура может быть неполной. Не используйте ?.= для создания новых свойств в null/undefined объектах — это невозможно.\nНе путайте ??= и ?.=: ??= — присваивает, если значение null/undefined ?.= — присваивает, только если путь существует ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Базовый оператор присваивания: <code>=</code>","level":3,"id":"Базовый_оператор_присваивания_`=`_0"},{"heading":"Составные операторы присваивания","level":3,"id":"Составные_операторы_присваивания_0"},{"heading":"Примеры:","level":4,"id":"Примеры_0"},{"heading":"Оператор объединения с присваиванием: <code>??=</code>","level":3,"id":"Оператор_объединения_с_присваиванием_`??=`_0"},{"heading":"Практический пример: загрузка настроек из локального хранилища","level":4,"id":"Практический_пример_загрузка_настроек_из_локального_хранилища_0"},{"heading":"Оператор присваивания с опциональной цепочкой: <code>?.=</code>","level":3,"id":"Оператор_присваивания_с_опциональной_цепочкой_`?.=`_0"},{"heading":"Полезный кейс: безопасное обновление вложенных данных","level":4,"id":"Полезный_кейс_безопасное_обновление_вложенных_данных_0"},{"heading":"Что нельзя делать","level":3,"id":"Что_нельзя_делать_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-присваивания-javascript.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434758508,"modifiedTime":1760434758508,"sourceSize":6443,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Операторы присваивания JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-присваивания-javascript.html","showInTree":true,"treeOrder":59,"backlinks":["лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-работы-с-битами.html":{"title":"Операторы работы с битами","icon":"","description":"Операторы работы с битами выполняют операции на уровне отдельных битов целочисленных значений. В мобильной разработке они встречаются редко, но могут быть полезны при оптимизации хранения флагов, работе с сетевыми протоколами, обработке изображений или взаимодействии с нативными модулями.Все битовые операции в JavaScript работают с 32-битными целыми числами. Любые числа перед операцией приводятся к этому формату (дробные части отбрасываются).Часто используется для хранения нескольких булевых состояний в одном числе.const READ = 1; // 0001\nconst WRITE = 2; // 0010\nconst EXEC = 4; // 0100\nconst DELETE = 8; // 1000 let permissions = READ | WRITE | EXEC; // 0111 = 7 // Проверяем, есть ли право на чтение:\nif (permissions &amp; READ) { console.log(\"Можно читать\"); // выполнится\n} // Проверяем, есть ли право на удаление:\nif (permissions &amp; DELETE) { console.log(\"Можно удалять\"); // не выполнится\n} ✅ Экономит память и ускоряет проверки в низкоуровневых сценариях — например, при передаче прав доступа через API или хранении настроек в локальном хранилище.\nОбъединяет несколько флагов в одно значение:let flags = 0;\nflags |= READ; // 0001\nflags |= WRITE; // 0011\nflags |= EXEC; // 0111 console.log(flags); // 7\nИспользуется для инвертирования конкретного флага:let theme = 0; // 0 — светлая, 1 — тёмная\ntheme ^= 1; // теперь theme = 1\ntheme ^= 1; // теперь theme = 0\nТакже применяется в алгоритмах шифрования или генерации контрольных сумм.Применяется для преобразования чисел и часто встречается в сочетании с indexOf:const arr = [\"apple\", \"banana\", \"cherry\"];\nconst index = arr.indexOf(\"banana\"); if (~index) { // эквивалентно: if (index !== -1) console.log(\"Найдено\");\n} ❗ Устаревший стиль. Современный код предпочтительно пишет так:\nif (index !== -1) — более читаемо и понятно.\nconsole.log(5 &lt;&lt; 1); // 10 → 5 * 2¹\nconsole.log(5 &lt;&lt; 2); // 20 → 5 * 2²\nconsole.log(1 &lt;&lt; 3); // 8 → 2³ ⚠️ Работает только с целыми числами. Не заменяет Math.pow() для дробных степеней.\nПолезно при оптимизации вычислений в играх, графических движках или обработке сигналов.console.log(8 &gt;&gt; 1); // 4 → 8 / 2\nconsole.log(-8 &gt;&gt; 1); // -4 — знак сохранён\nСохраняет знак числа — подходит для целочисленного деления на 2, 4, 8 и т.д.Преобразует отрицательные числа в большие положительные:console.log(-8 &gt;&gt;&gt; 1); // 2147483644 — интерпретируется как беззнаковое число Используется редко — в основном при работе с бинарными данными (например, Uint32Array, WebAssembly). Хранение флагов в одной переменной: например, права пользователя, состояние UI-элемента, режимы приложения.\nОптимизация производительности: в низкоуровневых системах (игры, аудио/видео обработка).\nРабота с нативными модулями: когда приложение использует JNI (Android) или Objective-C/Swift-код, где данные передаются как битовые маски.\nКомпрессия данных: при отправке маленьких наборов булевых значений через API.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Основные битовые операторы","level":3,"id":"Основные_битовые_операторы_0"},{"heading":"Примеры использования","level":3,"id":"Примеры_использования_0"},{"heading":"Побитовое И (<code>&amp;</code>) — проверка флагов","level":4,"id":"Побитовое_И_(`&`)_—_проверка_флагов_0"},{"heading":"Побитовое ИЛИ (<code>|</code>) — установка флагов","level":4,"id":"Побитовое_ИЛИ_(`|`)_—_установка_флагов_0"},{"heading":"Побитовое исключающее ИЛИ (<code>^</code>) — переключение флага","level":4,"id":"Побитовое_исключающее_ИЛИ_(`^`)_—_переключение_флага_0"},{"heading":"Побитовое НЕ (<code>~</code>) — инверсия битов","level":4,"id":"Побитовое_НЕ_(`~`)_—_инверсия_битов_0"},{"heading":"Сдвиг влево (<code>&lt;&lt;</code>) — умножение на степени двойки","level":4,"id":"Сдвиг_влево_(`<<`)_—_умножение_на_степени_двойки_0"},{"heading":"Арифметический сдвиг вправо (<code>&gt;&gt;</code>) — деление на степени двойки (со знаком)","level":4,"id":"Арифметический_сдвиг_вправо_(`>>`)_—_деление_на_степени_двойки_(со_знаком)_0"},{"heading":"Логический сдвиг вправо (<code>&gt;&gt;&gt;</code>) — деление на степени двойки (без знака)","level":4,"id":"Логический_сдвиг_вправо_(`>>>`)_—_деление_на_степени_двойки_(без_знака)_0"},{"heading":"Где это может пригодиться в мобильной разработке?","level":3,"id":"Где_это_может_пригодиться_в_мобильной_разработке?_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-работы-с-битами.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434762065,"modifiedTime":1760434762065,"sourceSize":7214,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Операторы работы с битами.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-работы-с-битами.html","showInTree":true,"treeOrder":60,"backlinks":["лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-сравнения-javascript.html":{"title":"Операторы сравнения JavaScript","icon":"","description":"Операторы сравнения позволяют проверять отношения между значениями и возвращают логическое значение — true или false. В JavaScript важно понимать разницу между нестрогим и строгим сравнением, а также то, как язык приводит типы автоматически.Операторы == (равно) и != (не равно) выполняют приведение типов перед сравнением. Это означает, что JavaScript пытается преобразовать операнды к одному типу, чтобы сделать сравнение возможным.console.log(5 == \"5\"); // true — строка \"5\" приводится к числу 5\nconsole.log(true == 1); // true — true приводится к 1\nconsole.log(false == 0); // true — false приводится к 0\nconsole.log(\"\" == 0); // true — пустая строка приводится к 0\nconsole.log(null == undefined); // true — особое правило: null и undefined равны друг другу\nconsole.log(\"0\" == false); // true — \"0\" → 0, false → 0 → 0 == 0\nconsole.log([] == false); // true — пустой массив → \"\" → 0 → false → 0\nТакие поведения могут привести к скрытым багам, особенно при обработке пользовательского ввода или данных из API.\n✅ Правило: Избегайте == и != в production-коде.\nОператоры === (строго равно) и !== (строго не равно) не выполняют приведение типов. Сравниваются и значение, и тип.console.log(5 === \"5\"); // false — разные типы: число и строка\nconsole.log(true === 1); // false — boolean и number\nconsole.log(5 === 5); // true — одинаковые тип и значение\nconsole.log(null === undefined); // false — разные типы\nconsole.log(\"\" === 0); // false — строка не равна числу\nВсегда используйте === и !==, если вам нужно точное совпадение.// Хорошо\nif (userInput === \"yes\") { ... } // Плохо\nif (userInput == \"yes\") { ... } // Может сработать на 1, true, \"1\"\nЭти операторы сравнивают значения по величине. При сравнении разных типов JavaScript также применяет приведение, но по другим правилам.console.log(10 &gt; 5); // true\nconsole.log(3 &lt;= 3); // true\nСтроки сравниваются по символам, в лексикографическом порядке (как в словаре):console.log(\"apple\" &lt; \"banana\"); // true — 'a' &lt; 'b'\nconsole.log(\"Z\" &lt; \"a\"); // true — в ASCII 'Z' (90) &lt; 'a' (97)\nconsole.log(\"10\" &lt; \"2\"); // true — потому что \"1\" &lt; \"2\", сравнение по первому символу! ❗ Важно: \"10\" &lt; \"2\" даёт true, хотя числово 10 &gt; 2.\nЭто частая ошибка при сравнении строковых чисел.\nПриведите их к числу:console.log(Number(\"10\") &lt; Number(\"2\")); // false\n// или проще:\nconsole.log(+ \"10\" &lt; + \"2\"); // false\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Нестрогое сравнение: <code>==</code> и <code>!=</code>","level":3,"id":"Нестрогое_сравнение_`==`_и_`!=`_0"},{"heading":"Примеры:","level":4,"id":"Примеры_0"},{"heading":"Почему это проблема?","level":4,"id":"Почему_это_проблема?_0"},{"heading":"Строгое сравнение: <code>===</code> и <code>!==</code>","level":3,"id":"Строгое_сравнение_`===`_и_`!==`_0"},{"heading":"Примеры:","level":4,"id":"Примеры_1"},{"heading":"Рекомендация:","level":4,"id":"Рекомендация_0"},{"heading":"Операторы больше/меньше: <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>","level":3,"id":"Операторы_больше/меньше_`>`,_`<`,_`>=`,_`<=`_0"},{"heading":"Сравнение чисел:","level":4,"id":"Сравнение_чисел_0"},{"heading":"Сравнение строк:","level":4,"id":"Сравнение_строк_0"},{"heading":"Как правильно сравнивать числа, представленные как строки?","level":4,"id":"Как_правильно_сравнивать_числа,_представленные_как_строки?_0"},{"heading":"Примеры неожиданного поведения и как их избегать","level":3,"id":"Примеры_неожиданного_поведения_и_как_их_избегать_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-сравнения-javascript.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434751830,"modifiedTime":1760434751830,"sourceSize":5077,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Операторы сравнения JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-сравнения-javascript.html","showInTree":true,"treeOrder":61,"backlinks":["лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№5/определение-оператора-и-операнда.html":{"title":"Определение оператора и операнда","icon":"","description":"Оператор — это символ или ключевое слово, которое выполняет определённое действие над данными.Операнд — это значение или переменная, над которой применяется оператор.Операторы классифицируются по количеству операндов, с которыми они работают:\nУнарные операторы используют один операнд — например, отрицание !x или инкремент ++i.\nБинарные операторы работают с двумя операндами — например, сложение a + b или сравнение x &gt; y.\nТернарный оператор использует три операнда — единственный в JavaScript: условное выражение condition ? value1 : value2 (про него подробнее будет в следующей теме).","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№5/определение-оператора-и-операнда.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434703091,"modifiedTime":1760434703091,"sourceSize":1060,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Определение оператора и операнда.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№5/определение-оператора-и-операнда.html","showInTree":true,"treeOrder":62,"backlinks":["лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№5/приоритет-операторов-и-ассоциативность.html":{"title":"Приоритет операторов и ассоциативность","icon":"","description":"Приоритет операторов определяет порядок, в котором выполняются операции в выражении, когда скобки не указаны. Ассоциативность — направление вычисления (слева направо или справа налево), если операторы имеют одинаковый приоритет.\n🔹 Важно: Операторы одной группы имеют одинаковый приоритет и выполняются в соответствии с ассоциативностью.\nlet result = 5 + 3 * 2;\n// Выполняется как: 5 + (3 * 2) → 5 + 6 → 11\nУмножение (*) имеет более высокий приоритет, чем сложение (+) — поэтому умножение выполняется первым.let a = true;\nlet b = false;\nlet c = true; let result = a || b &amp;&amp; c;\n// Выполняется как: a || (b &amp;&amp; c) → true || (false &amp;&amp; true) → true || false → true\nОператор &amp;&amp; выше по приоритету, чем || — поэтому сначала вычисляется b &amp;&amp; c.let x = 10;\nlet y = x &gt; 5 ? \"да\" : x &lt; 3 ? \"нет\" : \"не знаю\";\n// Эквивалентно: x &gt; 5 ? \"да\" : (x &lt; 3 ? \"нет\" : \"не знаю\")\nТернарный оператор ?: ассоциативен справа налево, поэтому вложенные условия обрабатываются корректно.let a = 1, b = 2, c = 3;\na = b += c *= 2;\n// Выполняется как: c *= 2 → c = 6; b += c → b = 8; a = b → a = 8\n// Порядок: справа налево, потому что `=` и составные операторы присваивания ассоциативны справа\nСкобки — это не просто формальность. Они делают код предсказуемым и понятным даже для того, кто читает его впервые.if (user.isAdmin &amp;&amp; user.isActive || user.isGuest) { ... }\nЧто здесь реально проверяется?\n→ (user.isAdmin &amp;&amp; user.isActive) || user.isGuestА если вы хотели:\n→ user.isAdmin &amp;&amp; (user.isActive || user.isGuest)?Разница критична.if (user.isAdmin &amp;&amp; (user.isActive || user.isGuest)) { ... }\n— Чётко видно намерение.// Без скобок — легко ошибиться\nif (age &gt;= 18 &amp;&amp; role === 'admin' || role === 'moderator') { ... } // Скобки спасают\nif (age &gt;= 18 &amp;&amp; (role === 'admin' || role === 'moderator')) { ... } Никогда не полагайтесь на память о приоритетах\nДаже опытные разработчики ошибаются. Если есть сомнения — используйте скобки. Разбивайте сложные выражения на части\nВместо:\nconst isValid = !isEmpty &amp;&amp; (value.length &gt;= 5 &amp;&amp; value.includes(\"@\")) || isTemp; Лучше:\nconst isEmpty = value.trim().length === 0;\nconst hasAtSymbol = value.includes(\"@\");\nconst meetsLength = value.length &gt;= 5;\nconst isValid = !isEmpty &amp;&amp; (meetsLength &amp;&amp; hasAtSymbol) || isTemp; Используйте переносы для многострочных условий\nif (user &amp;&amp; user.profile &amp;&amp; user.profile.isActive &amp;&amp; (user.role === 'admin' || user.role === 'editor')) { showDashboard();\n} Не пишите «умные» однострочные конструкции ради экономии строк\nНапример:\n// ❌ Непонятно\nresult = a &amp;&amp; b ? c : d || e; // ✅ Ясно\nif (a &amp;&amp; b) { result = c;\n} else { result = d || e;\n} Для логических выражений — комментируйте намерение // Разрешить доступ, если пользователь админ ИЛИ (зарегистрирован и активен)\nconst canAccess = user.role === 'admin' || (user.registered &amp;&amp; user.active); ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Обзор ключевых уровней приоритета (от высшего к низшему)","level":3,"id":"Обзор_ключевых_уровней_приоритета_(от_высшего_к_низшему)_0"},{"heading":"Примеры без скобок: что происходит на самом деле","level":3,"id":"Примеры_без_скобок_что_происходит_на_самом_деле_0"},{"heading":"Пример 1: Умножение и сложение","level":4,"id":"Пример_1_Умножение_и_сложение_0"},{"heading":"Пример 2: Логические операторы","level":4,"id":"Пример_2_Логические_операторы_0"},{"heading":"Пример 3: Тернарный оператор","level":4,"id":"Пример_3_Тернарный_оператор_0"},{"heading":"Пример 4: Смешанные операторы присваивания","level":4,"id":"Пример_4_Смешанные_операторы_присваивания_0"},{"heading":"Как избежать ошибок с помощью скобок","level":3,"id":"Как_избежать_ошибок_с_помощью_скобок_0"},{"heading":"Плохо:","level":4,"id":"Плохо_0"},{"heading":"Хорошо:","level":4,"id":"Хорошо_0"},{"heading":"Особенно важно при сочетании логических и сравнительных операторов:","level":4,"id":"Особенно_важно_при_сочетании_логических_и_сравнительных_операторов_0"},{"heading":"Рекомендации по читаемости кода","level":3,"id":"Рекомендации_по_читаемости_кода_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№5/приоритет-операторов-и-ассоциативность.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434764759,"modifiedTime":1760434764759,"sourceSize":7759,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Приоритет операторов и ассоциативность.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№5/приоритет-операторов-и-ассоциативность.html","showInTree":true,"treeOrder":63,"backlinks":["лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№6/базовые-команды-git.html":{"title":"Базовые команды Git","icon":"","description":"Создаёт новый Git-репозиторий в текущей папке.\nПосле этой команды появляется скрытая папка .git — она хранит всю историю проекта.git init\nПример:\nВы начинаете новый проект на React Native:cd MyMobileApp\ngit init\nТеперь Git отслеживает все файлы в папке MyMobileApp/: App.js, package.json, src/, android/, ios/.\n⚠️ Не запускайте git init внутри уже существующего репозитория — это сломает структуру.\nДобавляет изменения файлов в staging area — область, откуда они будут включены в следующий коммит.Добавить один файл:git add src/components/LoginButton.js\nДобавить все изменённые и новые файлы:git add .\nДобавить все файлы, кроме игнорируемых (через .gitignore):git add -A\nПример:\nВы изменили App.js и создали src/screens/Home.js.\nЧтобы зафиксировать оба:git add App.js src/screens/Home.js Важно: git add не сохраняет изменения — он только готовит их к сохранению.\nБез git commit изменения не зафиксируются.\nСохраняет все подготовленные изменения как один коммит.\nОбязательно нужно указывать сообщение с флагом -m.git commit -m \"Добавил экран Home с приветствием\"\nПример хорошего сообщения:\n\"Исправил баг: HomeScreen не отображался на Android 12\" — понятно, конкретно, воспроизводимо.Пример плохого сообщения:\n\"fixed\" — ничего не объясняет.\nКоммит — это логическая единица. Делайте один коммит на одну задачу.\nПоказывает, какие файлы изменены, какие добавлены, а какие ещё не отслеживаются.git status\nВывод может выглядеть так:On branch main\nChanges not staged for commit: modified: src/components/Button.js Untracked files: src/screens/Home.js Changes to be committed: new file: src/utils/api.js\nЭто помогает понять:\n— Что вы сделали?\n— Что ещё нужно добавить?\n— Что уже готово к коммиту?Показывает список всех коммитов в текущей ветке — от самого нового к самому старому.git log\nВывод:commit a1b2c3d4e5f67890...\nAuthor: Ivan Petrov &lt;ivan@example.com&gt;\nDate: Mon Apr 1 10:30:00 2025 +0300 Добавил экран Home с приветствием commit f9e8d7c6b5a4a3b2...\nAuthor: Ivan Petrov &lt;ivan@example.com&gt;\nDate: Sun Mar 31 15:20:00 2025 +0300 Настроил стили кнопок\nКороткая версия (только хеш и сообщение):git log --oneline\nВывод:a1b2c3d Добавил экран Home с приветствием\nf9e8d7c Настроил стили кнопок Используйте git log --oneline чаще — он удобнее для быстрого просмотра.\nПоказывает, что именно изменилось в файлах между рабочей директорией и последним коммитом.git diff\nПример вывода:diff --git a/src/components/Button.js b/src/components/Button.js\nindex 1234567..89abcde 100644\n--- a/src/components/Button.js\n+++ b/src/components/Button.js\n@@ -5,7 +5,7 @@ const Button = () =&gt; ( &lt;View style={styles.container}&gt;\n- &lt;Text&gt;Войти&lt;/Text&gt;\n+ &lt;Text style={styles.bold}&gt;Войти&lt;/Text&gt; &lt;/View&gt; );\nЗдесь:\n- — удалённая строка\n+ — добавленная строка\nЕсли вы хотите увидеть изменения, которые уже добавлены в staging (и готовы к коммиту):git diff --cached git diff без флагов — показывает не добавленные изменения.\ngit diff --cached — показывает добавленные, но ещё не закоммиченные.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"<code>git init</code> — создание репозитория","level":2,"id":"`git_init`_—_создание_репозитория_0"},{"heading":"<code>git add</code> — добавление изменений в область подготовки","level":2,"id":"`git_add`_—_добавление_изменений_в_область_подготовки_0"},{"heading":"<code>git commit</code> — фиксация изменений с сообщением","level":2,"id":"`git_commit`_—_фиксация_изменений_с_сообщением_0"},{"heading":"<code>git status</code> — просмотр состояния рабочей директории","level":2,"id":"`git_status`_—_просмотр_состояния_рабочей_директории_0"},{"heading":"<code>git log</code> — история коммитов","level":2,"id":"`git_log`_—_история_коммитов_0"},{"heading":"<code>git diff</code> — сравнение изменений","level":2,"id":"`git_diff`_—_сравнение_изменений_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№6/базовые-команды-git.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434753269,"modifiedTime":1760434753269,"sourceSize":5306,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Базовые команды Git.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№6/базовые-команды-git.html","showInTree":true,"treeOrder":65,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№6/основные-понятия-git.html":{"title":"Основные понятия Git","icon":"","description":"Репозиторий — это папка, в которой Git отслеживает все изменения файлов.\nОн хранит всю историю проекта: все коммиты, ветки, настройки.Создать репозиторий можно в любой папке:git init\nПосле этой команды в папке появляется скрытая папка .git — именно там Git хранит всю информацию.\nНе удаляйте её — без неё репозиторий перестанет работать.Пример:\nВы создаёте мобильное приложение на React Native. Папка MyMobileApp/ становится репозиторием — Git будет следить за всеми изменениями в файлах App.js, src/components/Button.js, package.json, ios/ и android/.Коммит — это сохранённое состояние проекта на определённый момент.\nЭто как снимок экрана вашего кода, который вы можете вернуть в любое время.Каждый коммит имеет уникальный хеш (например, a1b2c3d4) и сообщение, описывающее, что было изменено.Пример создания коммита:git add src/components/LoginButton.js\ngit commit -m \"Добавил кнопку входа с анимацией\" git add — выбирает изменения для сохранения.\ngit commit — фиксирует их как единое целое.\nВажно: коммит — это не просто сохранение файла. Это логическая единица изменений.\nХороший коммит делает одну вещь и говорит, что именно он сделал.Пример плохого коммита:\n\"fixed stuff\" — непонятно, что исправлено.Пример хорошего коммита:\n\"Исправил баг: кнопка входа не реагировала на тач в Android\" — ясно, понятно, воспроизводимо.Ветка — это изолированная линия разработки.\nПо умолчанию при создании репозитория создаётся ветка main.Вы можете создавать новые ветки для работы над новой функцией, исправлением бага или экспериментом — и не мешать основной версии приложения.Пример:git branch feature/login-animation\ngit switch feature/login-animation\nТеперь вы работаете в ветке feature/login-animation.\nВсе изменения — только здесь.\nКогда функция готова — вы объедините её с main.Это позволяет:\nНе ломать рабочую версию приложения.\nПараллельно работать над несколькими задачами.\nЛегко откатиться, если что-то пошло не так.\nПример сценария:\nВы добавляете анимацию при входе в приложении.\nДругой разработчик работает над авторизацией через Google.\nОба работают в своих ветках — никаких конфликтов до момента слияния.Git отслеживает файлы по четырём состояниям. Понимание этих состояний — ключ к работе с Git.Чтобы посмотреть текущее состояние всех файлов:git status\nПример последовательности:\nВы создали src/screens/AuthScreen.js → untracked\nВы выполнили git add src/screens/AuthScreen.js → staged\nВы выполнили git commit -m \"Добавил экран авторизации\" → теперь файл tracked, изменения зафиксированы\nВы снова отредактировали src/screens/AuthScreen.js → теперь он modified Запомните: чтобы сохранить изменения — нужно сначала add, потом commit.\nНельзя сделать коммит, не добавив изменения в staging-зону.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Репозиторий (repository)","level":2,"id":"Репозиторий_(repository)_0"},{"heading":"Коммит (commit)","level":2,"id":"Коммит_(commit)_0"},{"heading":"Ветка (branch)","level":2,"id":"Ветка_(branch)_0"},{"heading":"Статус файлов: tracked, modified, staged, untracked","level":2,"id":"Статус_файлов_tracked,_modified,_staged,_untracked_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№6/основные-понятия-git.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434755536,"modifiedTime":1760434755537,"sourceSize":5771,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Основные понятия Git.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№6/основные-понятия-git.html","showInTree":true,"treeOrder":66,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-ветками-git.html":{"title":"Работа с ветками Git","icon":"","description":"Показывает все ветки в репозитории. Текущая ветка отмечена звёздочкой *.git branch\nПример вывода: main\n* feature/login-screen bugfix/button-color\nЗдесь вы находитесь в ветке feature/login-screen.Чтобы увидеть только удалённые ветки (на сервере):git branch -r\nЧтобы увидеть все ветки — локальные и удалённые:git branch -a\nПереключает рабочую директорию на указанную ветку.\nИзменения в файлах сохраняются, если они не конфликтуют.git checkout feature/login-screen\nЕсли ветка ещё не существует локально, но есть на сервере — можно создать и переключиться сразу:git checkout feature/login-screen\n# если ветка не найдена локально — выдаст ошибку\nЧтобы создать новую ветку и сразу переключиться:git checkout -b feature/auth-google checkout — многофункциональная команда: она может переключать ветки, восстанавливать файлы, и даже переходить к коммитам. Это может запутать новичков.\nПоявилась в Git 2.23 как более понятная альтернатива для переключения веток.\nРаботает только с ветками — меньше шансов ошибиться.git switch feature/login-screen\nСоздать новую ветку и переключиться:git switch -c feature/auth-google ✅ Рекомендуется использовать git switch для переключения между ветками.\nОставьте git checkout только для восстановления файлов или перехода к старым коммитам.\nОбъединяет изменения из одной ветки в текущую.\nРаботает только после переключения на целевую ветку.Пример: вы закончили работу в feature/login-screen и хотите добавить изменения в main.git switch main\ngit merge feature/login-screen\nЕсли изменений нет в конфликте — Git сделает быстрое слияние (fast-forward).\nЕсли в main были новые коммиты — Git создаст отдельный коммит слияния.Пример вывода после успешного слияния:Updating a1b2c3d..f9e8d7c\nFast-forward src/screens/Login.js | 20 ++++++++++++++++++++ 1 file changed, 20 insertions(+) create mode 100644 src/screens/Login.js\nЕсли возникает конфликт — Git остановится и попросит вас разрешить его вручную.\nФайлы с конфликтами будут помечены специальными маркерами:&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n&lt;Text&gt;Войти&lt;/Text&gt;\n=======\n&lt;Text style={styles.bold}&gt;Войти&lt;/Text&gt;\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/login-screen\nРазрешите конфликт — удалите маркеры, оставьте нужный код — затем:git add src/components/Button.js\ngit commit ⚠️ Не делайте слияние в main с незавершёнными или неотлаженными фичами.\nВсегда тестируйте ветку перед слиянием.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"<code>git branch</code> — список веток","level":2,"id":"`git_branch`_—_список_веток_0"},{"heading":"<code>git checkout</code> — переключение между ветками","level":2,"id":"`git_checkout`_—_переключение_между_ветками_0"},{"heading":"<code>git switch</code> — альтернатива <code>checkout</code> для переключения","level":2,"id":"`git_switch`_—_альтернатива_`checkout`_для_переключения_0"},{"heading":"<code>git merge</code> — объединение веток","level":2,"id":"`git_merge`_—_объединение_веток_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-ветками-git.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434745652,"modifiedTime":1760434745652,"sourceSize":4169,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Работа с ветками Git.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-ветками-git.html","showInTree":true,"treeOrder":67,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-удалёнными-репозиториями.html":{"title":"Работа с удалёнными репозиториями","icon":"","description":"Чтобы отправить локальный репозиторий на GitHub, нужно связать его с удалённым.git remote add origin https://github.com/username/MyMobileApp.git origin — это имя, которое вы даёте удалённому репозиторию (по умолчанию так называют главный удалённый репозиторий).\nURL берётся из вашего репозитория на GitHub — кнопка «Code» → «HTTPS».\nПроверить, что привязка прошла:git remote -v\nВывод:origin https://github.com/username/MyMobileApp.git (fetch)\norigin https://github.com/username/MyMobileApp.git (push) Не используйте git remote add origin если репозиторий уже имеет удалённую связь — это вызовет ошибку.\nОтправляет ваши локальные коммиты в удалённый репозиторий.git push origin main\nПервый раз, когда вы отправляете ветку — Git может попросить аутентификацию (логин/пароль или токен).\nНа GitHub с 2021 года пароли не работают — используйте Personal Access Token (PAT) вместо пароля.\nЕсли вы работаете с веткой feature/login-screen:git push origin feature/login-screen\nПосле первого push можно использовать короткую команду:git push\nGit запомнит, куда отправлять изменения для текущей ветки.Загружает изменения с удалённого репозитория и объединяет их с вашей текущей веткой.git pull origin main\nЭто эквивалент двух команд:git fetch origin main\ngit merge origin/main\nПример:\nКоллега добавил новый экран в main. Вы выполняете:git switch main\ngit pull\nТеперь у вас есть последние изменения — даже если вы работали офлайн.\n⚠️ Если у вас есть незакоммиченные изменения — pull может сломаться.\nВ этом случае сначала сделайте git stash, потом pull, потом git stash pop.\nСоздаёт локальную копию удалённого репозитория — со всей историей, ветками и файлами.git clone https://github.com/username/MyMobileApp.git\nПосле этой команды:\nСоздаётся папка MyMobileApp/\nВнутри — все файлы, ветки, история коммитов\nАвтоматически создаётся связь origin с исходным репозиторием\nПример:\nВы присоединяетесь к команде. Вам дают ссылку на репозиторий — вы клонируете его и сразу можете работать:cd MyMobileApp\nnpm install\nnpx expo start Используйте git clone только при начале работы над проектом.\nДля обновления существующего репозитория — используйте git pull.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Привязка к удалённому репозиторию","level":2,"id":"Привязка_к_удалённому_репозиторию_0"},{"heading":"Отправка коммитов на сервер","level":2,"id":"Отправка_коммитов_на_сервер_0"},{"heading":"Получение изменений с сервера","level":2,"id":"Получение_изменений_с_сервера_0"},{"heading":"Скачивание репозитория","level":2,"id":"Скачивание_репозитория_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-удалёнными-репозиториями.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434743184,"modifiedTime":1760434743185,"sourceSize":3863,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Работа с удалёнными репозиториями.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-удалёнными-репозиториями.html","showInTree":true,"treeOrder":68,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№6/рекомендации-по-использованию-git.html":{"title":"Рекомендации по использованию Git","icon":"","description":"Делайте коммиты часто — не ждите, пока «всё будет готово».\nМаленький коммит — это безопасный снимок состояния.\nЕсли что-то сломалось — вы легко найдёте, где именно.Пример плохой практики:\nВы работаете над экраном входа 3 дня — меняете App.js, LoginScreen.js, api.js, styles.tsx — и только тогда делаете один коммит:\n\"finished login\" — непонятно, что изменилось.Пример хорошей практики: Добавил кнопку входа → feat: добавил кнопку входа с анимацией Подключил API для авторизации → feat: подключил POST /login к серверу Исправил баг с фокусом поля ввода → fix: исправил фокус на поле email в iOS\nКаждый коммит — отдельная логическая единица.\nЛегче откатиться, легче ревью, легче находить баги.Сообщение коммита — это история вашего кода.\nОно должно отвечать на вопрос: «Что изменилось и зачем?»Хорошее сообщение:\nfix: убрал дублирование стилей в Button и PrimaryButtonПлохое сообщение:\nfixed stuffИспользуйте формат:&lt;тип&gt;: &lt;краткое описание&gt;\nТипы (по соглашению Conventional Commits):\nfeat: — новая функция\nfix: — исправление бага\ndocs: — изменения в документации\nchore: — технические задачи (обновление зависимостей, настройка сборки)\nrefactor: — рефакторинг без изменения поведения\nПример:git commit -m \"feat: добавил экран восстановления пароля\"\ngit commit -m \"fix: кнопка 'Войти' не реагировала на тач в Android\"\ngit commit -m \"chore: обновил expo SDK до версии 50\" Не пишите «исправил ошибку», «сделал лучше» — это неинформативно.\nПишите что было сделано, где, и если важно — почему.\nНикогда не работайте напрямую в main.\nВсегда создавайте ветку для каждой задачи.Пример:git switch main\ngit pull\ngit switch -c feature/login-screen\n# ... работаю над экраном входа ...\ngit add .\ngit commit -m \"feat: добавил экран входа с валидацией\"\ngit push origin feature/login-screen\nЗатем на GitHub создаёте Pull Request (или Merge Request).\nПосле ревью — объединяете с main.Это даёт:\nБезопасность: основной код не ломается.\nЧёткость: каждая ветка — одна задача.\nКоллаборацию: другие могут видеть вашу работу, комментировать, предлагать правки.\nВозможность отложить: если задача не готова — вы можете закрыть ветку без влияния на проект. Если вы работаете над двумя задачами одновременно — две ветки.\nЕсли вы исправляете баг — ветка bugfix/....\nЕсли вы экспериментируете — ветка experiment/....\nЕсли вы добавляете новые фичи — ветка feature/.... Ветки — это ваша страховка.\nОни бесплатны. Они не занимают места.\nИспользуйте их всегда.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Частые, маленькие и осмысленные коммиты","level":2,"id":"Частые,_маленькие_и_осмысленные_коммиты_0"},{"heading":"Описательные сообщения коммитов","level":2,"id":"Описательные_сообщения_коммитов_0"},{"heading":"Использование веток для новых фич и исправлений","level":2,"id":"Использование_веток_для_новых_фич_и_исправлений_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№6/рекомендации-по-использованию-git.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434747844,"modifiedTime":1760434747845,"sourceSize":4475,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Рекомендации по использованию Git.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№6/рекомендации-по-использованию-git.html","showInTree":true,"treeOrder":69,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№6/файл-.gitignore.html":{"title":"Файл .gitignore","icon":"","description":"Файл .gitignore указывает Git, какие файлы и папки не нужно отслеживать.\nОн предотвращает попадание в репозиторий временных, системных или чувствительных файлов, которые не нужны другим разработчикам.Примеры файлов, которые никогда не должны быть в репозитории:\nnode_modules/ — папка с зависимостями React Native (устанавливается через npm install)\n.env — файл с секретными ключами (API-ключи, токены, пароли)\nbuild/, ios/, android/ — скомпилированные бинарники (они разные на каждом компьютере)\n.DS_Store, Thumbs.db — системные файлы macOS и Windows\n*.log, *.tmp — логи и временные файлы\nСоздайте файл .gitignore в корне проекта:touch .gitignore\nИ добавьте туда строки:node_modules/\n.env\nbuild/\nios/\nandroid/\n*.log\n*.tmp\n.DS_Store\nПосле этого Git перестанет отслеживать эти файлы — даже если вы выполните git add ..\nЕсли файл уже был добавлен в репозиторий — .gitignore его не игнорирует.\nСначала удалите его из индекса: git rm -r --cached node_modules/\ngit commit -m \"Убрал node_modules из репозитория\" Вот стандартный .gitignore для React Native-проекта:# Dependencies\nnode_modules/ # Environment\n.env\n.env.local\n.env.development\n.env.production # Build output\nbuild/\nios/\nandroid/ # Logs\n*.log\nnpm-debug.log* # IDE and editor\n.vscode/\n.idea/\n*.swp\n*.swo # OS\n.DS_Store\nThumbs.db # Testing\ncoverage/ # Expo\n.expo/\n.expo-shared/ Вы можете использовать шаблоны из <a data-tooltip-position=\"top\" aria-label=\"https://github.com/github/gitignore\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/github/gitignore\" target=\"_self\">github.com/github/gitignore</a> — там есть готовые .gitignore для React Native, Expo, iOS, Android.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Примеры:","level":2,"id":"Примеры_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№6/файл-.gitignore.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434727226,"modifiedTime":1760434727226,"sourceSize":2311,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Файл .gitignore.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№6/файл-.gitignore.html","showInTree":true,"treeOrder":70,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-git.html":{"title":"Что такое Git","icon":"","description":"Git — это распределённая система контроля версий.\nЭто означает, что каждый разработчик имеет полную копию истории изменений проекта на своём компьютере — не только последнюю версию файла, но и все прошлые состояния.Без Git вы работаете с файлами как с обычными документами: сохраняете, переписываете, теряете изменения.\nGit решает три основные проблемы: История изменений\nВы можете посмотреть, кто, когда и что изменил в любом файле.\nПример: вы заметили, что кнопка перестала работать. С помощью Git вы найдёте, в каком коммите это произошло. Откат к предыдущему состоянию\nЕсли вы внесли ошибку — можно вернуть проект к тому состоянию, когда всё работало.\nПример: git reset --hard a1b2c3d Это вернёт весь проект к коммиту с хешем a1b2c3d. Сотрудничество\nНесколько человек могут работать над одним проектом одновременно, не мешая друг другу.\nКаждый работает в своей копии, потом объединяет изменения. Пример:\nВы работаете в самолёте. В Git: можете делать коммиты, создавать ветки, просматривать историю — всё работает. В SVN: ничего не сможете сделать, пока не выйдете в сеть.\nGit — это инструмент, который работает на вашем компьютере.\nОн не требует интернета, чтобы функционировать.\nЭто делает его надёжным и удобным даже в условиях плохого соединения или при работе офлайн.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Зачем нужен Git","level":2,"id":"Зачем_нужен_Git_0"},{"heading":"Отличие от SVN (и других централизованных систем)","level":2,"id":"Отличие_от_SVN_(и_других_централизованных_систем)_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-git.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434740441,"modifiedTime":1760434740441,"sourceSize":3437,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Что такое Git.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-git.html","showInTree":true,"treeOrder":71,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-github.html":{"title":"Что такое GitHub","icon":"","description":"GitHub — это хостинг для Git-репозиториев.\nЭто веб-платформа, где можно хранить код, делиться им с другими и работать совместно.\nХранение — ваш репозиторий сохраняется на сервере GitHub, даже если ваш компьютер сломается.\nОбмен — вы можете дать доступ другим разработчикам или сделать репозиторий публичным.\nСовместная работа — через pull requests, комментарии, задачи (issues), код-ревью.\nПример:\nВы разрабатываете мобильное приложение на React Native.\nВы закоммитили изменения локально, но хотите, чтобы команда увидела ваш код — вы отправляете его на GitHub.\nДругой разработчик клонирует репозиторий, проверяет код, предлагает правки — вы вносите их и снова публикуете.Git — это инструмент, который работает на вашем компьютере.\nGitHub — это сервис, который предоставляет место для хранения Git-репозиториев в облаке.\nGit — как ручка и тетрадь.\nGitHub — как облако, куда вы сканируете тетрадь, чтобы другие могли её видеть.\nВы можете использовать Git без GitHub — локально, на своём компьютере.\nНо вы не можете использовать GitHub без Git — он требует репозитория, созданный с помощью Git.\nGitHub — это не единственный хостинг. Есть GitLab, Bitbucket, Gitea.\nНо GitHub — самый популярный, особенно в открытых проектах и при поиске работы.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Основные функции","level":2,"id":"Основные_функции_0"},{"heading":"Отличие от Git","level":2,"id":"Отличие_от_Git_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-github.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434726131,"modifiedTime":1760434726132,"sourceSize":2258,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Что такое GitHub.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-github.html","showInTree":true,"treeOrder":72,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`else`.html":{"title":"Оператор `else`","icon":"","description":"Оператор else используется вместе с if, чтобы указать, что нужно выполнить альтернативный блок кода, если условие в if ложно.Синтаксис:if (условие) { // выполнится, если условие истинно\n} else { // выполнится, если условие ложно\n}\nelse не имеет собственного условия — он всегда связан с ближайшим предыдущим if.Пример: проверка наличия интернет-соединенияconst isConnected = navigator.onLine; if (isConnected) { syncData();\n} else { showOfflineMessage(); saveToLocalCache();\n}\nЗдесь программа либо синхронизирует данные, либо показывает сообщение и сохраняет их локально — в зависимости от состояния сети. Нет третьего варианта — только два пути.\nelse не может существовать без if.\nelse выполняется, только если ни один из предыдущих if (или else if) не сработал.\nМожно использовать else даже без фигурных скобок — но снова, всегда используйте скобки для ясности и безопасности.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Оператор else","level":1,"id":"Оператор_else_0"},{"heading":"Важно","level":2,"id":"Важно_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`else`.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434715774,"modifiedTime":1760434715774,"sourceSize":1560,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Оператор `else`.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`else`.html","showInTree":true,"treeOrder":74,"backlinks":["лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`if`.html":{"title":"Оператор `if`","icon":"","description":"Оператор if выполняет блок кода, только если условие в скобках истинно.Базовый синтаксис:if (условие) { // код, который выполнится, если условие истинно\n}\nУсловие — это выражение, которое возвращает true или false. В JavaScript к false приводятся значения: false, 0, \"\" (пустая строка), null, undefined, NaN. Всё остальное — true.Пример: проверка, авторизован ли пользовательconst userToken = localStorage.getItem(\"token\"); if (userToken) { console.log(\"Пользователь авторизован\"); loadUserProfile();\n}\nЗдесь userToken может быть строкой (истина) или null (ложь). Если токен есть — вызываем функцию загрузки профиля. Если нет — ничего не делаем.Нет, они не обязательны, если в блоке if только одна строка:if (userToken) console.log(\"Пользователь авторизован\");\nНо рекомендуется всегда использовать фигурные скобки, даже для одной строки.Почему?\nИзбегает ошибок при доработке кода:\nif (userToken) console.log(\"Пользователь авторизован\"); loadUserProfile(); // Эта строка ВСЕГДА выполнится — вне зависимости от условия!\nЗдесь loadUserProfile() не в блоке if, потому что нет скобок. Это распространённая ошибка. Улучшает читаемость и согласованность кода в команде. Снижает риск багов при рефакторинге. Правило: всегда пишите скобки.if (userToken) { console.log(\"Пользователь авторизован\"); loadUserProfile();\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Оператор if","level":1,"id":"Оператор_if_0"},{"heading":"Обязательны ли фигурные скобки?","level":2,"id":"Обязательны_ли_фигурные_скобки?_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`if`.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434727715,"modifiedTime":1760434727715,"sourceSize":2337,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Оператор `if`.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`if`.html","showInTree":true,"treeOrder":75,"backlinks":["лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`switch`.html":{"title":"Оператор `switch`","icon":"","description":"Оператор switch используется для выбора одного из нескольких блоков кода на основе значения выражения. Он особенно удобен, когда нужно проверить переменную на равенство нескольким дискретным значениям.switch (выражение) { case значение1: // код, если выражение === значение1 break; case значение2: // код, если выражение === значение2 break; default: // код, если ни одно значение не совпало (необязательно)\n}\nswitch сравнивает значение выражения с каждым case с помощью строгого сравнения (===) — то есть и тип, и значение должны совпадать.Пример: выбор языка интерфейсаconst language = \"ru\"; switch (language) { case \"en\": setLanguage(\"English\"); break; case \"ru\": setLanguage(\"Русский\"); break; case \"es\": setLanguage(\"Español\"); break; default: setLanguage(\"English\"); // запасной вариант\n}\nЗдесь language сравнивается со строками \"en\", \"ru\", \"es\". Если совпадает — выполняется соответствующий блок, и break останавливает выполнение.Без break выполнение продолжается на следующие case — это называется просачиванием (fall-through).Пример с ошибкой:const role = \"admin\"; switch (role) { case \"admin\": console.log(\"Администратор\"); case \"moderator\": console.log(\"Модератор\"); case \"user\": console.log(\"Пользователь\"); default: console.log(\"Гость\");\n}\nВывод:Администратор\nМодератор\nПользователь\nГость\nПотому что после case \"admin\": нет break — выполнение «просочилось» дальше.Это может быть полезно в редких случаях — например, когда несколько значений должны делать одно и то же:const permission = \"read\"; switch (permission) { case \"read\": case \"write\": case \"delete\": enableButton(\"action\"); break; default: disableButton(\"action\");\n}\nЗдесь если permission — \"read\", \"write\" или \"delete\" — кнопка включается. Это читаемо и логично.default не обязателен, но рекомендуется всегда добавлять. Он обрабатывает случаи, когда значение не совпало ни с одним case.Пример: обработка типов уведомленийconst notificationType = \"error\"; // пришло из API switch (notificationType) { case \"success\": showBanner(\"Успешно!\", \"green\"); break; case \"warning\": showBanner(\"Предупреждение!\", \"orange\"); break; case \"error\": showBanner(\"Ошибка!\", \"red\"); break; default: console.warn(\"Неизвестный тип уведомления:\", notificationType); showBanner(\"Новое сообщение\", \"blue\");\n}\nЗдесь даже если сервер отправит неожиданный тип — приложение не сломается, а просто покажет стандартное сообщение и залогирует проблему.✅ Используйте switch, когда:\nПроверяете одну переменную на равенство нескольким конкретным значениям.\nЗначения — строковые константы, числа, перечисления (enum).\nКод должен быть структурирован и легко расширяться.\n❌ Не используйте switch, когда:\nНужно проверять диапазоны (if (score &gt;= 90)).\nУсловия сложные (if (user.age &gt; 18 &amp;&amp; user.role === \"admin\")).\nВы сравниваете объекты или массивы — switch работает только с примитивами. switch работает только с примитивами: строки, числа, булевы, null, undefined, символы.\ncase не может быть выражением — только литералы или константы.\nВсе case должны быть уникальными в рамках одного switch.\nПример запрещённого:switch (x) { case y + 1: // ОШИБКА — выражение не допускается break;\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Оператор switch","level":1,"id":"Оператор_switch_0"},{"heading":"Синтаксис","level":2,"id":"Синтаксис_0"},{"heading":"Принцип работы","level":2,"id":"Принцип_работы_0"},{"heading":"Почему нужен <code>break</code>?","level":2,"id":"Почему_нужен_`break`?_0"},{"heading":"<code>default</code> — обработка неожиданных значений","level":2,"id":"`default`_—_обработка_неожиданных_значений_0"},{"heading":"Когда использовать <code>switch</code>","level":2,"id":"Когда_использовать_`switch`_0"},{"heading":"Важно","level":2,"id":"Важно_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`switch`.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434753830,"modifiedTime":1760434753831,"sourceSize":5411,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Оператор `switch`.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`switch`.html","showInTree":true,"treeOrder":76,"backlinks":["лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№7/сравнение-`if`-и-`switch`.html":{"title":"Сравнение `if` и `switch`","icon":"","description":"Выбор между if и switch зависит от типа условия, которое вы проверяете. Оба инструмента решают похожие задачи, но используются в разных сценариях.Используйте if и else if, когда: Проверяете диапазоны значений if (score &gt;= 90) { grade = \"A\";\n} else if (score &gt;= 80) { grade = \"B\";\n} else if (score &gt;= 60) { grade = \"C\";\n} Используете логические операции (&amp;&amp;, ||, !) if (isLoggedIn &amp;&amp; user.role === \"admin\" &amp;&amp; !user.banned) { showAdminPanel();\n} Условия не сводятся к одному значению — например, проверка наличия данных, состояния сети, времени суток if (date.getHours() &gt;= 6 &amp;&amp; date.getHours() &lt; 12) { setMessage(\"Доброе утро!\");\n} Значения динамические или вычисляемые — switch не может работать с выражениями в case. Используйте switch, когда: Проверяете одну переменную на равенство конкретным, дискретным значениям — например, строковым ключам, числам, enum-значениям switch (notificationType) { case \"info\": case \"success\": showBanner(\"Сообщение\", \"blue\"); break; case \"warning\": showBanner(\"Предупреждение\", \"orange\"); break; case \"error\": showBanner(\"Ошибка\", \"red\"); break;\n} У вас есть перечисление возможных состояний — язык интерфейса, тип уведомления, статус заказа, режим приложения switch (appTheme) { case \"light\": case \"dark\": case \"system\": applyTheme(appTheme); break;\n} Код должен быть структурирован и легко расширяться — добавление нового case не нарушает логику остальных веток. В современных движках JavaScript (V8, SpiderMonkey) разница в производительности между if и switch минимальна — особенно при небольшом количестве условий.\nДля большого числа вариантов (например, 10+ дискретных значений) switch может быть чуть быстрее, потому что внутренне использует таблицу переходов (jump table), а не последовательные проверки.\nНо в реальных веб и мобильных приложениях эта разница не имеет значения — важнее читаемость и поддерживаемость. switch лучше читается, когда вы видите список возможных значений — как меню.\nif лучше читается, когда вы видите логические правила — как условия в форме.\nПример читаемого switch:switch (buttonAction) { case \"save\": saveData(); break; case \"cancel\": closeModal(); break; case \"delete\": confirmDelete(); break;\n}\nПример читаемого if:if (isOffline &amp;&amp; hasUnsavedChanges) { showSavePrompt();\n} else if (!isOffline &amp;&amp; !hasUnsavedChanges) { hideNotification();\n} Используйте switch для перечислений — когда у вас есть фиксированный набор значений.\nИспользуйте if для логики — когда нужно проверять диапазоны, комбинации, условия с &amp;&amp; или ||.\nНе гонитесь за «красивым» кодом — выбирайте то, что понятнее вашей команде.\nЕсли вы сомневаетесь — выбирайте if. Он универсален. switch — специализированный инструмент.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Сравнение if и switch","level":1,"id":"Сравнение_if_и_switch_0"},{"heading":"Когда использовать <code>if</code>","level":2,"id":"Когда_использовать_`if`_0"},{"heading":"Когда использовать <code>switch</code>","level":2,"id":"Когда_использовать_`switch`_0"},{"heading":"Производительность","level":2,"id":"Производительность_0"},{"heading":"Читаемость","level":2,"id":"Читаемость_0"},{"heading":"Рекомендация","level":2,"id":"Рекомендация_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№7/сравнение-`if`-и-`switch`.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434750014,"modifiedTime":1760434750015,"sourceSize":4764,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Сравнение `if` и `switch`.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№7/сравнение-`if`-и-`switch`.html","showInTree":true,"treeOrder":77,"backlinks":["лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№7/тернарный-оператор.html":{"title":"Тернарный оператор","icon":"","description":"Тернарный оператор ? : — это краткая форма if else, используемая для присваивания значения в зависимости от условия.Синтаксис:условие ? выражение1 : выражение2\nЕсли условие истинно — возвращается выражение1, иначе — выражение2.const isLoggedIn = true;\nconst buttonText = isLoggedIn ? \"Выйти\" : \"Войти\";\nbutton.textContent = buttonText;\nЗдесь вместо:let buttonText;\nif (isLoggedIn) { buttonText = \"Выйти\";\n} else { buttonText = \"Войти\";\n}\nМы пишем одну строку — чище, короче, удобнее для присваивания.const hasAvatar = user.avatarUrl !== null;\nconst avatarSrc = hasAvatar ? user.avatarUrl : \"/images/default-avatar.png\";\navatarImage.src = avatarSrc;\nconst count = 5;\nconst message = count === 1 ? \"1 новое сообщение\" : `${count} новых сообщений`;\nnotification.textContent = message; Краткость: идеален для простых условий, особенно при присваивании.\nЧитаемость в простых случаях: сразу видно, что значение зависит от условия.\nУдобен в шаблонах, функциях, JSX (в React), где нельзя использовать блоки if. Не подходит для сложной логики. Например:\n// ПЛОХО — не читаемо и сложно отлаживать\nconst result = condition1 ? (condition2 ? (condition3 ? \"A\" : \"B\") : \"C\") : (condition4 ? \"D\" : \"E\");\nТакой код трудно понять и поддерживать. Лучше использовать if else.\nНельзя выполнять несколько действий внутри тернарного оператора:\n// НЕ РАБОТАЕТ так, как ожидается\nisLoggedIn ? console.log(\"Вход выполнен\"), openDashboard() : redirectToLogin();\nЗдесь console.log и openDashboard() не будут выполнены как блок. Для нескольких действий используйте if.✅ Используйте тернарный оператор, когда:\nВы присваиваете значение переменной.\nУсловие простое — одно сравнение, один оператор.\nКод должен быть компактным и понятным.\n❌ Не используйте, когда:\nНужно выполнить несколько действий.\nУсловие сложное (с логическими операторами &amp;&amp;, ||, несколькими вложенными).\nВы хотите повысить читаемость для команды — лучше if else.\nТернарный оператор — инструмент для простых решений. Не превращайте его в замену if else.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Пример: установка текста кнопки","level":2,"id":"Пример_установка_текста_кнопки_0"},{"heading":"Пример: выбор изображения профиля","level":2,"id":"Пример_выбор_изображения_профиля_0"},{"heading":"Пример: форматирование данных","level":2,"id":"Пример_форматирование_данных_0"},{"heading":"Преимущества","level":2,"id":"Преимущества_0"},{"heading":"Ограничения","level":2,"id":"Ограничения_0"},{"heading":"Когда использовать","level":2,"id":"Когда_использовать_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№7/тернарный-оператор.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434741484,"modifiedTime":1760434741484,"sourceSize":3584,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Тернарный оператор.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№7/тернарный-оператор.html","showInTree":true,"treeOrder":78,"backlinks":["лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№7/цепочки-`else-if`.html":{"title":"Цепочки `else if`","icon":"","description":"Цепочка else if` позволяет проверить несколько условий последовательно — и выполнить только первый подходящий блок.Синтаксис:if (условие1) { // выполнится, если условие1 истинно\n} else if (условие2) { // выполнится, если условие1 ложно, а условие2 истинно\n} else if (условие3) { // выполнится, если условие1 и условие2 ложны, а условие3 истинно\n} else { // выполнится, если все условия ложны (необязательно)\n}\nВажно: как только одно из условий становится истинным — выполняется соответствующий блок, и все остальные условия не проверяются.const userRole = \"moderator\"; if (userRole === \"admin\") { showAdminPanel();\n} else if (userRole === \"moderator\") { showModeratorPanel();\n} else if (userRole === \"user\") { showUserPanel();\n} else { showGuestPanel();\n}\nЗдесь:\nЕсли роль — \"admin\" — показывается панель администратора, и проверка останавливается.\nЕсли роль — \"moderator\" — показывается панель модератора, даже если бы были другие условия, они не проверяются.\nЕсли ни одно из известных значений не подошло — показывается панель гостя.\nПредставьте, что вы перепутали порядок:if (userRole === \"user\") { showUserPanel();\n} else if (userRole === \"moderator\") { showModeratorPanel();\n} else if (userRole === \"admin\") { showAdminPanel();\n}\nЕсли пользователь имеет роль \"admin\", он попадёт в блок \"user\", потому что \"admin\" содержит \"user\" как подстроку? Нет — в данном случае сравнение строгое (===), так что не сработает. Но если бы вы использовали indexOf или includes, ошибки были бы критичны.Более реальный пример с ошибкой:const score = 95; if (score &gt;= 60) { grade = \"C\"; // Всегда сработает первым!\n} else if (score &gt;= 80) { grade = \"B\";\n} else if (score &gt;= 90) { grade = \"A\";\n}\nЗдесь оценка 95 получит \"C\", потому что первое условие score &gt;= 60 уже истинно. Правильно:if (score &gt;= 90) { grade = \"A\";\n} else if (score &gt;= 80) { grade = \"B\";\n} else if (score &gt;= 60) { grade = \"C\";\n} else { grade = \"F\";\n}\nconst themeSetting = \"dark\"; if (themeSetting === \"light\") { document.body.classList.remove(\"dark-theme\"); document.body.classList.add(\"light-theme\");\n} else if (themeSetting === \"dark\") { document.body.classList.remove(\"light-theme\"); document.body.classList.add(\"dark-theme\");\n} else if (themeSetting === \"system\") { if (window.matchMedia(\"(prefers-color-scheme: dark)\").matches) { document.body.classList.add(\"dark-theme\"); } else { document.body.classList.add(\"light-theme\"); }\n} else { // значение неизвестно — используем по умолчанию document.body.classList.add(\"light-theme\");\n}\nЗдесь три явных варианта и один запасной — логика понятна, читаема, и порядок условий критичен.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Цепочки else if","level":1,"id":"Цепочки_else_if_0"},{"heading":"Пример: определение роли пользователя","level":2,"id":"Пример_определение_роли_пользователя_0"},{"heading":"Почему порядок важен?","level":2,"id":"Почему_порядок_важен?_0"},{"heading":"Пример: выбор темы приложения","level":2,"id":"Пример_выбор_темы_приложения_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№7/цепочки-`else-if`.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434744529,"modifiedTime":1760434744529,"sourceSize":4028,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Цепочки `else if`.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№7/цепочки-`else-if`.html","showInTree":true,"treeOrder":79,"backlinks":["лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№7/что-такое-ветвление.html":{"title":"Что такое ветвление","icon":"","description":"Ветвление — это механизм, при котором программа выбирает, какой участок кода выполнить, в зависимости от того, истинно или ложно условие.В любых программах это используется повсеместно: например, если пользователь авторизован — показываем главный экран, иначе — экран входа. Или если сеть доступна — загружаем данные, иначе — показываем сообщение об ошибке.В JavaScript ветвление реализуется с помощью условных конструкций: if, else, else if, switch и тернарного оператора.Без ветвления программа выполняет команды строго сверху вниз — как линейный список. С ветвлением она становится адаптивной: реагирует на данные, состояние системы, действия пользователя.Пример:const isLoggedIn = true; if (isLoggedIn) { console.log(\"Добро пожаловать!\");\n} else { console.log(\"Пожалуйста, войдите в аккаунт.\");\n}\nЗдесь программа ведёт себя по-разному в зависимости от значения isLoggedIn. Это и есть ветвление.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№7/что-такое-ветвление.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434716362,"modifiedTime":1760434716362,"sourceSize":1588,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Что такое ветвление.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№7/что-такое-ветвление.html","showInTree":true,"treeOrder":80,"backlinks":["лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№8/прерывание-и-пропуск-итераций.html":{"title":"Прерывание и пропуск итераций","icon":"","description":"Без них цикл всегда выполняет все итерации до завершения условия. Но в реальных приложениях часто нужно:\nОстановить цикл, если найден нужный элемент (например, пользователь найден).\nПропустить некорректные данные (например, пустой товар в списке).\nИзбежать лишних вычислений — это повышает производительность и предсказуемость.\nКоманда break немедленно завершает цикл, даже если условие ещё истинно.const users = [ { id: 1, name: \"Анна\" }, { id: 2, name: \"Иван\" }, { id: 3, name: \"Мария\" }\n]; let foundUser = null; for (let user of users) { if (user.id === 2) { foundUser = user; break; // Нашли — выходим, дальше не ищем }\n} console.log(foundUser); // { id: 2, name: \"Иван\" }\nБез break цикл продолжил бы перебирать остальных пользователей — хотя ответ уже найден.Команда continue пропускает остаток текущей итерации и переходит к следующей.const products = [ \"Ноутбук\", \"\", \"Телефон\", null, \"Наушники\"\n]; for (let product of products) { if (!product) { continue; // Пропускаем пустые и null } console.log(\"Товар: \" + product);\n}\nВывод:Товар: Ноутбук\nТовар: Телефон\nТовар: Наушники\nПустые значения (\"\", null) игнорируются — цикл не выводит их, но не останавливается.При загрузке списка сообщений из API:for (let message of messages) { if (!message.text) { continue; // Пропускаем пустые сообщения } if (message.isDeleted) { break; // Остановить загрузку, если встретили удалённое — дальше не нужно } renderMessage(message);\n} break и continue работают только с ближайшим внешним циклом.\nВложенные циклы: break выйдет только из внутреннего.\nИспользуйте их для улучшения читаемости — не для обхода логики, а для оптимизации. Используйте break, когда найдено нужное и дальнейший перебор не нужен.\nИспользуйте continue, когда текущий элемент не подходит и его нужно пропустить.\nЭто делает код эффективнее и понятнее.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Зачем нужны прерывания и пропуски","level":2,"id":"Зачем_нужны_прерывания_и_пропуски_0"},{"heading":"<code>break</code> — выход из цикла","level":2,"id":"`break`_—_выход_из_цикла_0"},{"heading":"Пример: поиск пользователя в списке","level":3,"id":"Пример_поиск_пользователя_в_списке_0"},{"heading":"<code>continue</code> — переход к следующей итерации","level":2,"id":"`continue`_—_переход_к_следующей_итерации_0"},{"heading":"Пример: обработка списка товаров, пропуск пустых","level":3,"id":"Пример_обработка_списка_товаров,_пропуск_пустых_0"},{"heading":"Пример в мобильном приложении","level":2,"id":"Пример_в_мобильном_приложении_0"},{"heading":"Важно","level":2,"id":"Важно_0"},{"heading":"Правило","level":2,"id":"Правило_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№8/прерывание-и-пропуск-итераций.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434741342,"modifiedTime":1760434741343,"sourceSize":3500,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Прерывание и пропуск итераций.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№8/прерывание-и-пропуск-итераций.html","showInTree":true,"treeOrder":82,"backlinks":["лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`do...while`.html":{"title":"Цикл `do...while`","icon":"","description":"Цикл do...while — это разновидность цикла while, в которой тело выполняется хотя бы один раз, даже если условие ложно с самого начала.do { // тело цикла\n} while (условие);\nОбратите внимание: условие проверяется после выполнения тела. Это главное отличие от while.let userInput = \"\"; do { userInput = prompt(\"Введите пароль (минимум 6 символов):\");\n} while (userInput.length &lt; 6); console.log(\"Пароль принят: \" + userInput);\nЗдесь пользователь обязательно увидит поле ввода хотя бы один раз — даже если он сразу введёт короткий пароль. Цикл продолжится, пока условие не выполнится.\nИспользуйте do...while, когда нужно хотя бы один раз выполнить действие, а потом проверять, нужно ли повторять.\nОсобенно полезно для ввода данных, настроек, подтверждений — там, где пользователь должен что-то сделать до продолжения.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Цикл do...while","level":1,"id":"Цикл_do...while_0"},{"heading":"Синтаксис","level":2,"id":"Синтаксис_0"},{"heading":"Пример: запрос ввода у пользователя","level":2,"id":"Пример_запрос_ввода_у_пользователя_0"},{"heading":"Разница между <code>while</code> и <code>do...while</code>","level":2,"id":"Разница_между_`while`_и_`do...while`_0"},{"heading":"Правило","level":2,"id":"Правило_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`do...while`.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434724559,"modifiedTime":1760434724559,"sourceSize":1988,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Цикл `do...while`.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`do...while`.html","showInTree":true,"treeOrder":83,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№8/цикл-while.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...in`-—-перебор-ключей-объекта.html":{"title":"Цикл `for...in` — перебор ключей объекта","icon":"","description":"Цикл for...in перебирает ключевые свойства объекта — то есть имена (ключи) его перечисляемых свойств.for (ключ in объект) { // тело цикла\n}\nconst user = { name: \"Анна\", age: 28, role: \"администратор\"\n}; for (let key in user) { console.log(key + \": \" + user[key]);\n}\nВывод:name: Анна\nage: 28\nrole: администратор\nКаждая итерация возвращает имя свойства — строку. Чтобы получить значение, нужно обратиться через объект[ключ].\nПеребирает только перечисляемые свойства (те, что можно увидеть в Object.keys()).\nВключает свойства, унаследованные от прототипа, если они не помечены как enumerable: false.\nПорядок не гарантирован — особенно для числовых ключей, которые могут быть отсортированы по возрастанию.\nconst arr = [\"a\", \"b\", \"c\"];\narr.extra = \"лишнее\"; // добавили нечисловое свойство for (let key in arr) { console.log(key); // выведет: \"0\", \"1\", \"2\", \"extra\"\n}\nПроблемы:\nНе только индексы — for...in перебирает все перечисляемые свойства, включая те, что добавлены вручную.\nПорядок может нарушиться — в некоторых движках числовые ключи сортируются по возрастанию, даже если они были добавлены в другом порядке.\nНет гарантии, что вы получите только элементы массива — если библиотека расширила Array.prototype, это тоже попадёт в цикл. Не используйте for...in для массивов.\nИспользуйте for...of или классический for.\nДля массивов for...in — источник багов. Для объектов — нормально, если вы знаете, что делаете.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Цикл for...in — перебор ключей объекта","level":1,"id":"Цикл_for...in_—_перебор_ключей_объекта_0"},{"heading":"Синтаксис","level":2,"id":"Синтаксис_0"},{"heading":"Пример: перебор свойств объекта","level":2,"id":"Пример_перебор_свойств_объекта_0"},{"heading":"Особенности","level":2,"id":"Особенности_0"},{"heading":"Почему не подходит для массивов?","level":2,"id":"Почему_не_подходит_для_массивов?_0"},{"heading":"Правило","level":2,"id":"Правило_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...in`-—-перебор-ключей-объекта.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434731580,"modifiedTime":1760434731581,"sourceSize":2652,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Цикл `for...in` — перебор ключей объекта.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...in`-—-перебор-ключей-объекта.html","showInTree":true,"treeOrder":84,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№8/цикл-for.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...of`-—-перебор-значений-итерируемых-объектов.html":{"title":"Цикл `for...of` — перебор значений итерируемых объектов","icon":"","description":"Цикл for...of — это современный способ перебора значений в итерируемых объектах. Он предназначен для доступа к данным, а не к их ключам.for (значение of итерируемый_объект) { // тело цикла\n}\nconst colors = [\"красный\", \"зелёный\", \"синий\"]; for (let color of colors) { console.log(color);\n}\nВывод:красный\nзелёный\nсиний\nЗдесь color — это значение элемента, а не индекс.const text = \"Привет\"; for (let char of text) { console.log(char);\n}\nВывод:П\nр\nи\nв\nе\nт\nКаждая итерация возвращает один символ.const settings = new Map([ [\"theme\", \"dark\"], [\"lang\", \"ru\"], [\"notifications\", true]\n]); for (let value of settings) { console.log(value); // [\"theme\", \"dark\"], [\"lang\", \"ru\"], [\"notifications\", true]\n} // Если нужно отдельно ключ и значение:\nfor (let [key, value] of settings) { console.log(key + \": \" + value);\n}\nВывод:theme: dark\nlang: ru\nnotifications: true\nconst tags = new Set([\"javascript\", \"react\", \"mobile\"]); for (let tag of tags) { console.log(tag);\n}\nВывод:javascript\nreact\nmobile Используйте for...of, когда нужно перебрать значения — массивы, строки, Map, Set, NodeList и другие итерируемые структуры.\nЭто безопасно, понятно и работает предсказуемо.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Цикл for...of — перебор значений итерируемых объектов","level":1,"id":"Цикл_for...of_—_перебор_значений_итерируемых_объектов_0"},{"heading":"Синтаксис","level":2,"id":"Синтаксис_0"},{"heading":"Примеры","level":2,"id":"Примеры_0"},{"heading":"Перебор массива","level":3,"id":"Перебор_массива_0"},{"heading":"Перебор строки","level":3,"id":"Перебор_строки_0"},{"heading":"Перебор <code>Map</code>","level":3,"id":"Перебор_`Map`_0"},{"heading":"Перебор <code>Set</code>","level":3,"id":"Перебор_`Set`_0"},{"heading":"Отличие от <code>for...in</code>","level":2,"id":"Отличие_от_`for...in`_0"},{"heading":"Правило","level":2,"id":"Правило_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...of`-—-перебор-значений-итерируемых-объектов.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434732374,"modifiedTime":1760434732374,"sourceSize":2690,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Цикл `for...of` — перебор значений итерируемых объектов.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...of`-—-перебор-значений-итерируемых-объектов.html","showInTree":true,"treeOrder":85,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№8/цикл-for.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-for.html":{"title":"Цикл for","icon":"","description":"Цикл for — это самый гибкий и часто используемый цикл в JavaScript. Он позволяет точно контролировать начало, условие продолжения и изменение счётчика на каждой итерации.for (инициализация; условие; шаг) { // тело цикла\n} инициализация — выполняется один раз в начале. Обычно объявляется счётчик (let i = 0).\nусловие — проверяется перед каждой итерацией. Если false — цикл завершается.\nшаг — выполняется после каждого прохода тела цикла. Обычно увеличивает счётчик (i++).\nconst products = [\"Яблоко\", \"Груша\", \"Апельсин\"]; for (let i = 0; i &lt; products.length; i++) { console.log(\"Товар: \" + products[i]);\n}\nВывод:Товар: Яблоко\nТовар: Груша\nТовар: Апельсин\nЗдесь i — индекс текущего элемента. Мы используем его для доступа к products[i].Если массив изменяется во время цикла (например, элементы удаляются), length пересчитывается на каждой итерации. Это безопасно.\n<a data-href=\"Цикл `for...in` — перебор ключей объекта\" href=\"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...in`-—-перебор-ключей-объекта.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Цикл `for...in` — перебор ключей объекта</a>\n<br><a data-href=\"Цикл `for...of` — перебор значений итерируемых объектов\" href=\"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...of`-—-перебор-значений-итерируемых-объектов.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Цикл `for...of` — перебор значений итерируемых объектов</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Синтаксис","level":2,"id":"Синтаксис_0"},{"heading":"Пример: перебор массива по индексу","level":2,"id":"Пример_перебор_массива_по_индексу_0"},{"heading":"Почему важно использовать <code>length</code>?","level":2,"id":"Почему_важно_использовать_`length`?_0"},{"heading":"Разновидности <code>for</code>","level":2,"id":"Разновидности_`for`_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...in`-—-перебор-ключей-объекта.html","материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...of`-—-перебор-значений-итерируемых-объектов.html"],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-for.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434722689,"modifiedTime":1760434722690,"sourceSize":1893,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Цикл for.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-for.html","showInTree":true,"treeOrder":86,"backlinks":["лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-while.html":{"title":"Цикл while","icon":"","description":"Цикл while выполняет блок кода пока условие истинно. Он подходит, когда заранее неизвестно, сколько раз нужно повторить действие.while (условие) { // тело цикла\n}\nУсловие проверяется до каждой итерации. Если оно ложно с самого начала — тело цикла не выполнится ни разу.let isLoading = true;\nlet attempts = 0; while (isLoading &amp;&amp; attempts &lt; 5) { console.log(\"Попытка загрузки #\" + (attempts + 1)); // Имитация асинхронной загрузки if (Math.random() &gt; 0.7) { isLoading = false; console.log(\"Успешно загружено!\"); } attempts++;\n}\nЗдесь мы не знаем, на какой попытке данные загрузятся — поэтому используем while.const messages = [\"Привет\", \"Как дела?\", \"Пока\", \"Спасибо\"];\nlet i = 0; while (i &lt; messages.length &amp;&amp; messages[i] !== \"Пока\") { console.log(\"Обрабатываю: \" + messages[i]); i++;\n} console.log(\"Нашли 'Пока' на позиции \" + i);\nВывод:Обрабатываю: Привет\nОбрабатываю: Как дела?\nНашли 'Пока' на позиции 2\nЕсли условие никогда не станет false — цикл никогда не завершится. Это приведёт к зависанию приложения.// ОШИБКА — бесконечный цикл\nwhile (true) { console.log(\"Это никогда не остановится!\");\n}\nВсегда убедитесь, что внутри цикла есть изменение, которое ведёт к завершению условия.\nКогда количество итераций зависит от внешних условий: загрузка сети, ожидание ответа API, ввод пользователя.\nПри работе с потоками данных, где элементы приходят динамически.\nВ мобильных приложениях — например, повторная попытка отправки запроса при ошибке, пока не будет успеха или превышено лимит попыток. <a data-href=\"Цикл `do...while`\" href=\"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`do...while`.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Цикл `do...while`</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Синтаксис","level":2,"id":"Синтаксис_0"},{"heading":"Пример: ожидание загрузки данных","level":2,"id":"Пример_ожидание_загрузки_данных_0"},{"heading":"Пример: обработка списка до определённого элемента","level":2,"id":"Пример_обработка_списка_до_определённого_элемента_0"},{"heading":"Важно: избегайте бесконечных циклов","level":2,"id":"Важно_избегайте_бесконечных_циклов_0"},{"heading":"Когда использовать <code>while</code>","level":2,"id":"Когда_использовать_`while`_0"},{"heading":"Разновидности","level":2,"id":"Разновидности_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`do...while`.html"],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-while.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434734881,"modifiedTime":1760434734881,"sourceSize":2911,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Цикл while.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-while.html","showInTree":true,"treeOrder":87,"backlinks":["лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№8/циклы-и-производительность.html":{"title":"Циклы и производительность","icon":"","description":"Производительность циклов критична в JavaScript — особенно при обработке больших списков, частых обновлений или ресурсоёмких операций. Даже небольшая неоптимизированная операция внутри цикла может замедлить выполнение скрипта.Любая операция, которая не зависит от итерации, не должна выполняться на каждой итерации.const items = getLargeItemList(); // 10 000 элементов for (let i = 0; i &lt; items.length; i++) { // items.length вызывается 10 000 раз — даже если массив не меняется processItem(items[i]);\n}\nitems.length — это свойство. В JavaScript оно вычисляется каждый раз, даже если массив статичен. Это лишняя нагрузка.const items = getLargeItemList();\nconst length = items.length; // вычисляем один раз for (let i = 0; i &lt; length; i++) { processItem(items[i]);\n}\nТеперь length — это просто число, и его не нужно пересчитывать.for (let item of items) { if (item.name.toLowerCase().includes(searchTerm.toLowerCase())) { //toLowerCase() вызывается дважды на каждой итерации result.push(item); }\n}\nКаждый вызов toLowerCase() — это новая строка, которая создаётся и сравнивается. Это лишние выделения памяти и вычисления.const lowerSearchTerm = searchTerm.toLowerCase(); for (let item of items) { if (item.name.toLowerCase().includes(lowerSearchTerm)) { result.push(item); }\n} Избегайте сложных вычислений внутри цикла: математика, регулярные выражения, вызовы JSON.parse, querySelector.\nВыносите константы за пределы цикла: например, Math.PI, config.threshold, RegExp-шаблоны.\nНе модифицируйте массив, который перебираете — это может вызвать неожиданное поведение, особенно при использовании for...of.\nИспользуйте for...of вместо for с индексами, если вам не нужны индексы — меньше кода, меньше рисков. Всё, что не меняется на каждой итерации — выносите за цикл.\nВсё, что влияет на производительность (вычисления, вызовы функций) — минимизируйте внутри цикла.\nОптимизация циклов напрямую влияет на скорость выполнения скрипта и отзывчивость приложения.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Избегать тяжёлых операций внутри тела цикла","level":2,"id":"Избегать_тяжёлых_операций_внутри_тела_цикла_0"},{"heading":"❌ Плохо — вычисление длины массива на каждой итерации","level":3,"id":"❌_Плохо_—_вычисление_длины_массива_на_каждой_итерации_0"},{"heading":"✅ Хорошо — вычислить один раз до цикла","level":3,"id":"✅_Хорошо_—_вычислить_один_раз_до_цикла_0"},{"heading":"❌ Плохо — вызов функции или сложных вычислений внутри цикла","level":3,"id":"❌_Плохо_—_вызов_функции_или_сложных_вычислений_внутри_цикла_0"},{"heading":"✅ Хорошо — вынести константные операции за цикл","level":3,"id":"✅_Хорошо_—_вынести_константные_операции_за_цикл_0"},{"heading":"Дополнительные оптимизации","level":2,"id":"Дополнительные_оптимизации_0"},{"heading":"Правило","level":2,"id":"Правило_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№8/циклы-и-производительность.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434742486,"modifiedTime":1760434742486,"sourceSize":3755,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Циклы и производительность.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№8/циклы-и-производительность.html","showInTree":true,"treeOrder":88,"backlinks":["лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№8/что-такое-цикл.html":{"title":"Что такое цикл","icon":"","description":"Цикл — это конструкция, которая повторяет выполнение блока кода, пока выполняется заданное условие.Каждое повторение называется итерацией. Например, если вы перебираете 10 элементов массива — это 10 итераций.Циклы нужны, чтобы не писать один и тот же код десятки раз. Без них пришлось бы вручную обрабатывать каждый элемент списка, что невозможно при динамических данных.Пример: у вас есть список задач. Вы хотите вывести каждую в консоль. Без цикла — 10 строк кода. С циклом — одна.const tasks = [\"Починить кнопку\", \"Обновить API\", \"Проверить стиль\"]; for (let i = 0; i &lt; tasks.length; i++) { console.log(tasks[i]);\n}\nТакже циклы используются для генерации данных: например, создание 100 случайных чисел, или заполнение списка пунктов меню.Циклы — это основа работы с коллекциями. Без них невозможно построить интерактивный интерфейс с динамическим содержимым.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№8/что-такое-цикл.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434715405,"modifiedTime":1760434715405,"sourceSize":1531,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Что такое цикл.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№8/что-такое-цикл.html","showInTree":true,"treeOrder":89,"backlinks":["лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№9/возвращаемое-значение.html":{"title":"Возвращаемое значение","icon":"","description":"Функция может возвращать результат с помощью оператора return. Это значение передаётся обратно в место, откуда функция была вызвана.function calculateDiscount(price, discountPercent) { return price - (price * discountPercent / 100);\n} const finalPrice = calculateDiscount(1000, 15);\nconsole.log(finalPrice); // 850\nЗдесь return отправляет вычисленную сумму обратно в переменную finalPrice.Если в функции нет return, она возвращает undefined:function logMessage(message) { console.log(message);\n} const result = logMessage('Привет');\nconsole.log(result); // undefined\nДаже если функция что-то делает — например, выводит в консоль — она не возвращает ничего, если не указан return.return можно использовать для преждевременного завершения работы функции — это полезно для проверки условий.Пример: проверка наличия данных перед обработкойfunction updateUserProfile(userData) { if (!userData || !userData.name) { return; // выход, если данные не переданы или нет имени } // Эта часть выполнится только если условия выше не сработали console.log('Обновление профиля для:', userData.name); // ... логика обновления\n} updateUserProfile(); // ничего не делает, функция завершается на return\nupdateUserProfile({ name: 'Анна' }); // обновление профиля\nТакой подход упрощает код: вы не пишете вложенные if-else, а сразу отсеиваете невалидные случаи.function loadUserSettings() { if (!userIsAuthenticated) { return; // не продолжаем, если пользователь не авторизован } const settings = api.getSettings(); updateUI(settings);\n}\nЗдесь return предотвращает выполнение дорогостоящих операций — обращение к API, обновление интерфейса — если это бессмысленно. Это улучшает производительность и снижает риск ошибок.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Ранний выход из функции","level":2,"id":"Ранний_выход_из_функции_0"},{"heading":"Пример: проверка авторизации перед загрузкой данных","level":2,"id":"Пример_проверка_авторизации_перед_загрузкой_данных_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№9/возвращаемое-значение.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434734012,"modifiedTime":1760434734012,"sourceSize":2834,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Возвращаемое значение.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№9/возвращаемое-значение.html","showInTree":true,"treeOrder":91,"backlinks":["лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№9/объявление-функции-(function-declaration).html":{"title":"Объявление функции (Function Declaration)","icon":"","description":"Объявление функции (Function Declaration)Синтаксис объявления функции:function calculateSum(a, b) { return a + b;\n}\nЗдесь calculateSum — имя функции, a и b — параметры. Функция вычисляет сумму и возвращает результат.Особенность функций, объявленных таким образом — поднятие (hoisting). Это значит, что JavaScript перемещает объявление функции в начало текущей области видимости при компиляции кода. Поэтому вы можете вызвать функцию до её объявления:// Это сработает!\nconsole.log(calculateSum(5, 3)); // 8 function calculateSum(a, b) { return a + b;\n}\nЭто работает только с объявлениями функций. Функциональные выражения и стрелочные функции таким свойством не обладают.Пример: форматирование даты для отображения в интерфейсеfunction formatDateString(dateString) { const date = new Date(dateString); return date.toLocaleDateString('ru-RU', { day: 'numeric', month: 'long', year: 'numeric' });\n} console.log(formatDateString('2024-06-15')); // 15 июня 2024 г.\nТакая функция может использоваться в любом месте приложения, где нужно отобразить дату в понятном виде — например, в списке уведомлений или истории действий пользователя.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№9/объявление-функции-(function-declaration).html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434720553,"modifiedTime":1760434720553,"sourceSize":1835,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Объявление функции (Function Declaration).md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№9/объявление-функции-(function-declaration).html","showInTree":true,"treeOrder":92,"backlinks":["лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№9/параметры-и-аргументы.html":{"title":"Параметры и аргументы","icon":"","description":"Параметры — это имена переменных, которые указываются в скобках при объявлении функции. Они определяют, какие данные функция ожидает получить.Аргументы — это реальные значения, которые передаются функции при её вызове.Пример:function greet(name, age) { // name и age — параметры return 'Привет, ' + name + ', тебе ' + age + ' лет';\n} console.log(greet('Анна', 25)); // 'Анна' и 25 — аргументы\nЗдесь name и age — параметры. При вызове greet('Анна', 25) передаются аргументы 'Анна' и 25. Каждый аргумент присваивается соответствующему параметру.Если аргументов меньше, чем параметров — остальные получат значение undefined:console.log(greet('Иван')); // Привет, Иван, тебе undefined лет\nЧтобы избежать undefined, можно задать значения по умолчанию:function greet(name, age = 18) { return 'Привет, ' + name + ', тебе ' + age + ' лет';\n} console.log(greet('Иван')); // Привет, Иван, тебе 18 лет\nconsole.log(greet('Мария', 22)); // Привет, Мария, тебе 22 лет\nЗначения по умолчанию работают для любого параметра — не только последнего:function createTask(title = 'Новая задача', priority = 'средний', completed = false) { return { title, priority, completed };\n} console.log(createTask()); // { title: 'Новая задача', priority: 'средний', completed: false }\nconsole.log(createTask('Удалить кеш')); // { title: 'Удалить кеш', priority: 'средний', completed: false }\nЭто особенно полезно в приложениях, где параметры часто не обязательны — например, настройки темы, уведомления, таймауты. Вы можете задать разумные значения по умолчанию и не проверять каждый аргумент вручную.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№9/параметры-и-аргументы.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434729637,"modifiedTime":1760434729637,"sourceSize":2518,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Параметры и аргументы.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№9/параметры-и-аргументы.html","showInTree":true,"treeOrder":93,"backlinks":["лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№9/рекурсия.html":{"title":"Рекурсия","icon":"","description":"Рекурсия — это когда функция вызывает саму себя внутри своего тела. Это способ решить задачу, разбив её на более мелкие подзадачи того же типа.Она удобна, когда задача естественно разбивается на аналогичные подзадачи — например, обход дерева каталогов, вычисление чисел Фибоначчи, работа с вложенными структурами данных.Базовый случай — это условие, при котором рекурсия перестаёт вызывать саму себя и начинает возвращать результат. Рекурсия работает по принципу «разделяй и властвуй»: задача разбивается на меньшие копии самой себя. Но в какой-то момент этот процесс должен остановиться — иначе не будет точки входа в обратный путь.Факториал числа n — это произведение всех натуральных чисел от 1 до n.\nОбозначается как n!\nПример: 5! = 5 × 4 × 3 × 2 × 1 = 120Рекурсивное определение:\nn! = n × (n-1)!\nБазовый случай: 0! = 1Реализация:function factorial(n) { if (n === 0 || n === 1) { return 1; // базовый случай } return n * factorial(n - 1); // рекурсивный вызов\n} console.log(factorial(5)); // 120\nЗдесь factorial(5) вызывает factorial(4), который вызывает factorial(3) и так далее, пока не дойдёт до factorial(1). После этого цепочка возвратов начинает вычислять результат снизу вверх.Каждый рекурсивный вызов занимает память в стеке вызовов. Если рекурсия слишком глубокая — стек переполняется, и браузер или приложение падает с ошибкой Stack Overflow.Пример опасного случая:function infiniteRecursion() { return infiniteRecursion(); // вызов без условия остановки\n} infiniteRecursion(); // приведёт к Stack Overflow\nПоэтому всегда убедитесь, что рекурсия имеет базовый случай, который остановит вызовы, и что с каждым шагом вы приближаетесь к нему.Используйте рекурсию только тогда, когда она делает код понятнее. В большинстве случаев лучше заменять её циклами — они эффективнее и безопаснее.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Пример: вычисление факториала числа","level":2,"id":"Пример_вычисление_факториала_числа_0"},{"heading":"Ограничения","level":2,"id":"Ограничения_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№9/рекурсия.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434738554,"modifiedTime":1760434738554,"sourceSize":3223,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Рекурсия.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№9/рекурсия.html","showInTree":true,"treeOrder":94,"backlinks":["лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№9/стрелочные-функции-(arrow-function).html":{"title":"Стрелочные функции (Arrow Function)","icon":"","description":"const multiply = (a, b) =&gt; { return a * b;\n};\nОна состоит из двух частей: параметры в скобках, затем стрелка =&gt;, и тело функции в фигурных скобках.Если параметр один — скобки можно опустить:const square = x =&gt; x * x;\nЕсли тело функции — одно выражение — фигурные скобки и return можно опустить:const formatName = (first, last) =&gt; first + ' ' + last;\nЭто называется краткой формой. Она возвращает результат выражения автоматически.Стрелочные функции часто называют анонимными, потому что они не имеют имени в своём определении. Их имя — это переменная, в которую они присваиваются.Стрелочные функции идеальны для простых преобразований и коллбэков — особенно в мобильных приложениях, где код должен быть лаконичным.const tasks = [ { id: 1, title: 'Починить экран', completed: false }, { id: 2, title: 'Обновить приложение', completed: true }\n]; const pendingTasks = tasks.filter(task =&gt; !task.completed);\nconsole.log(pendingTasks); // [{ id: 1, title: 'Починить экран', completed: false }]\nЗдесь стрелочная функция task =&gt; !task.completed передаётся в filter. Она короткая, читаемая и выполняет одну задачу — проверяет, не выполнена ли задача.Пример: обработчик клика в React Native или веб-интерфейсеbutton.addEventListener('click', () =&gt; { showNotification('Данные сохранены');\n}); Важно: стрелочные функции не имеют собственного this. Это полезно в классах и коллбэках, но не всегда очевидно для новичков — пока достаточно знать, что для простых операций они удобны, а для сложной логики с this лучше использовать функциональные выражения или объявления.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Синтаксис стрелочной функции:","level":2,"id":"Синтаксис_стрелочной_функции_0"},{"heading":"Когда использовать","level":2,"id":"Когда_использовать_0"},{"heading":"Пример: обработка списка задач","level":2,"id":"Пример_обработка_списка_задач_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№9/стрелочные-функции-(arrow-function).html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434733101,"modifiedTime":1760434733101,"sourceSize":2757,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Стрелочные функции (Arrow Function).md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№9/стрелочные-функции-(arrow-function).html","showInTree":true,"treeOrder":95,"backlinks":["лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№9/функциональное-выражение-(function-expression).html":{"title":"Функциональное выражение (Function Expression)","icon":"","description":"Функциональное выражение (Function Expression)Синтаксис функционального выражения:const calculateSum = function(a, b) { return a + b;\n};\nЗдесь функция не объявляется как отдельная сущность с именем в области видимости. Вместо этого она создаётся как анонимная функция и присваивается переменной calculateSum.Главное отличие от объявления функции — отсутствие поднятия. Вы не можете вызвать функцию до её присваивания:console.log(calculateSum(2, 3)); // Ошибка: TypeError: calculateSum is not a function const calculateSum = function(a, b) { return a + b;\n};\nЭто важно: функциональное выражение становится доступным только после строки, в которой оно присвоено.Использование: передача функции как аргументаЧасто функциональные выражения используются, когда функция передаётся в другую функцию — например, как коллбэк.Пример: обработка данных списка пользователейconst users = ['Анна', 'Иван', 'Мария']; const capitalizedUsers = users.map(function(name) { return name.charAt(0).toUpperCase() + name.slice(1);\n}); console.log(capitalizedUsers); // ['Анна', 'Иван', 'Мария']\nЗдесь анонимная функция передаётся в метод map. Она будет вызвана для каждого элемента массива. Такой подход часто используется в мобильных приложениях при фильтрации, сортировке или преобразовании данных из API.Функциональные выражения также полезны, когда вы хотите создать функцию динамически или условно:let getGreeting; if (isMorning) { getGreeting = function() { return 'Доброе утро'; };\n} else { getGreeting = function() { return 'Добрый день'; };\n} console.log(getGreeting()); // зависит от условия\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№9/функциональное-выражение-(function-expression).html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434730237,"modifiedTime":1760434730237,"sourceSize":2563,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Функциональное выражение (Function Expression).md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№9/функциональное-выражение-(function-expression).html","showInTree":true,"treeOrder":96,"backlinks":["лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№9/что-такое-функция.html":{"title":"Что такое функция","icon":"","description":"Функция — это именованный блок кода, который выполняет определённую задачу. Её можно вызывать несколько раз, передавая разные данные, и она всегда будет вести себя одинаково.Без функций код становился бы дублирующимся и неуправляемым. Например, если нужно проверить, заполнено ли поле ввода в трёх разных местах приложения — без функции вы скопировали бы один и тот же код три раза. С функцией — один раз написали, три раза вызвали.Функции помогают структурировать код: разбивают большую задачу на маленькие, понятные части. Это делает его легче тестировать, читать и поддерживать.Пример: обработчик клика по кнопке в HTML&lt;button id=\"loginBtn\"&gt;Войти&lt;/button&gt;\nfunction handleLoginClick() { const email = document.getElementById('email').value; if (email) { console.log('Почта введена, начинаем вход...'); } else { console.log('Введите почту'); }\n} document.getElementById('loginBtn').addEventListener('click', handleLoginClick);\nЗдесь handleLoginClick — функция. Она не выполняется сразу, а ждёт, пока пользователь кликнет. Когда клик происходит — функция вызывается. Это делает интерфейс реактивным. Без функции вы не смогли бы отделить логику от события.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№9/что-такое-функция.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434724385,"modifiedTime":1760434724385,"sourceSize":1943,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Что такое функция.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№9/что-такое-функция.html","showInTree":true,"treeOrder":97,"backlinks":["лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№10/блочная-область-видимости.html":{"title":"Блочная область видимости","icon":"","description":"Блочная область видимости — это когда переменная доступна только внутри блока кода, заключённого в фигурные скобки {} — например, внутри if, for, while, или любого другого блока.Переменные, объявленные с let и const, привязаны к блоку, а не к функции. Они не видны за пределами этого блока.Пример:if (true) { let isActive = true; const theme = \"dark\";\n} console.log(isActive); // ошибка: isActive is not defined\nconsole.log(theme); // ошибка: theme is not defined\nЗдесь isActive и theme существуют только внутри if. Как только блок завершён — переменные уничтожаются (в смысле недоступны).То же работает с циклами:for (let i = 0; i &lt; 3; i++) { console.log(i); // 0, 1, 2\n} console.log(i); // ошибка: i is not defined\nВ отличие от var, здесь i не выходит за пределы цикла — это предсказуемо и безопасно.С let в цикле for каждая итерация создаёт новую переменную. Это важно при использовании замыканий.Пример с var — проблема:for (var i = 0; i &lt; 3; i++) { setTimeout(() =&gt; console.log(i), 100);\n}\n// Выведет: 3, 3, 3 — потому что i — одна переменная, и к моменту запуска setTimeout она = 3\nПример с let — правильно:for (let i = 0; i &lt; 3; i++) { setTimeout(() =&gt; console.log(i), 100);\n}\n// Выведет: 0, 1, 2 — каждая итерация имеет свою i\nПочему так происходит:\nlet создаёт новую привязку переменной для каждой итерации цикла. var — одну и ту же переменную для всего цикла.\nВсегда используйте let и const вместо var.\nОни дают точный контроль: переменная существует только там, где вы её объявили — меньше ошибок, проще читать и отлаживать код.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Особенность: <code>let</code> в цикле <code>for</code>","level":2,"id":"Особенность_`let`_в_цикле_`for`_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№10/блочная-область-видимости.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434731297,"modifiedTime":1760434731297,"sourceSize":2597,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Блочная область видимости.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№10/блочная-область-видимости.html","showInTree":true,"treeOrder":99,"backlinks":["лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№10/вложенность-областей-видимости.html":{"title":"Вложенность областей видимости","icon":"","description":"Вложенность областей видимости означает, что внутренняя область кода (например, функция внутри другой функции) может обращаться к переменным внешней области, но не наоборот.Это работает по принципу «внутри видит наружу, но наружу не видит внутрь».Пример:function outerFunction() { const userName = \"Анна\"; function innerFunction() { console.log(userName); // доступна — из внутренней функции видна внешняя переменная const userRole = \"admin\"; } innerFunction(); console.log(userRole); // ошибка: userRole is not defined\n}\nЗдесь:\ninnerFunction может прочитать userName — потому что он объявлен во внешней функции\nouterFunction не может прочитать userRole — он существует только внутри innerFunction\nЭто естественное поведение, основанное на цепочке областей видимости — так называемой цепочке лексических окружений.Ещё один пример — вложенные блоки:function checkPermissions() { const userId = 123; if (userId &gt; 0) { const hasAccess = true; console.log(userId); // работает — видит внешнюю переменную console.log(hasAccess); // работает — своя переменная } console.log(hasAccess); // ошибка — hasAccess не видна за пределами блока if\n}\nПочему это важно:\nВы можете создавать локальные контексты: например, обработку авторизации внутри функции, не засоряя внешнюю область\nНе нужно бояться, что переменные внутри вспомогательных функций перезапишут глобальные\nЛегче тестировать: функция работает только с тем, что ей передано или что видно из внешней области Всегда объявляйте переменные как можно глубже — в том блоке, где они реально нужны. Это делает код чище, безопаснее и предсказуемее.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№10/вложенность-областей-видимости.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434731950,"modifiedTime":1760434731950,"sourceSize":2681,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Вложенность областей видимости.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№10/вложенность-областей-видимости.html","showInTree":true,"treeOrder":100,"backlinks":["лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№10/глобальная-область-видимости.html":{"title":"Глобальная область видимости","icon":"","description":"Глобальная область видимости — это область, в которой переменные доступны в любом месте файла, включая все функции и блоки.Переменные объявляются в глобальной области, если они созданы вне всех функций, циклов, условий — то есть на самом верхнем уровне скрипта.Пример:let appVersion = \"1.2.0\"; // глобальная переменная\nconst apiUrl = \"https://api.example.com\"; function loadUserData() { console.log(appVersion); // можно использовать — доступна\n} loadUserData();\nconsole.log(appVersion); // тоже доступна\nТакие переменные доступны везде — в любой функции, даже в файле, подключённом позже. Это удобно для настроек, которые нужны повсеместно: URL API, токен авторизации, флаги режима приложения.Но есть серьёзный риск — загрязнение глобального пространства.Когда много разработчиков пишут код в одном файле или подключают несколько скриптов, они могут случайно переопределить одну и ту же глобальную переменную.Пример проблемы:// Файл 1 (ваш код)\nlet user = { id: 1, name: \"Петр\" }; // Файл 2 (сторонний скрипт)\nlet user = \"guest\"; // ой — перезаписал ваш объект! console.log(user); // \"guest\" — ваша логика сломалась\nТакие ошибки сложно отловить: они проявляются не всегда, зависят от порядка загрузки файлов, и могут быть в продакшене.Поэтому:\nИзбегайте создания глобальных переменных без необходимости\nЕсли нужно хранить данные на уровне приложения — используйте модули или объекты-нэйспейсы\nВ современном JavaScript используйте import/export — они не создают глобальные переменные Лучшая практика: чем меньше глобальных переменных — тем стабильнее приложение.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№10/глобальная-область-видимости.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434732846,"modifiedTime":1760434732846,"sourceSize":2716,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Глобальная область видимости.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№10/глобальная-область-видимости.html","showInTree":true,"treeOrder":101,"backlinks":["лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№10/замыкания.html":{"title":"Замыкания","icon":"","description":"Замыкание — это когда функция запоминает и сохраняет доступ к переменным из внешней области видимости, даже после того как внешняя функция завершила свою работу.Это происходит потому, что в JavaScript каждая функция «запоминает» окружение, в котором она была создана — даже если она выполняется позже, в другом месте.Простой пример:function createUserManager() { let userCount = 0; return function() { userCount++; return `Пользователей: ${userCount}`; };\n} const addUser = createUserManager(); console.log(addUser()); // \"Пользователей: 1\"\nconsole.log(addUser()); // \"Пользователей: 2\"\nconsole.log(addUser()); // \"Пользователей: 3\"\nЗдесь:\ncreateUserManager создаёт переменную userCount и возвращает внутреннюю функцию\nПосле вызова createUserManager() внешняя функция завершается — её стек должен быть очищен\nНо внутренняя функция (addUser) продолжает «помнить» и использовать userCount\nЭто и есть замыкание: внутренняя функция замыкает на переменную из внешней области\nfunction createThemeManager() { let currentTheme = \"light\"; return { getTheme() { return currentTheme; }, setTheme(theme) { currentTheme = theme; }, toggleTheme() { currentTheme = currentTheme === \"light\" ? \"dark\" : \"light\"; } };\n} const theme = createThemeManager();\ntheme.setTheme(\"dark\");\nconsole.log(theme.getTheme()); // \"dark\"\ntheme.toggleTheme();\nconsole.log(theme.getTheme()); // \"light\"\nТема хранится в замыкании — не загрязняет глобальное пространство, доступна только через контролируемые методы.function setupButtonHandler(buttonId, userId) { document.getElementById(buttonId).addEventListener(\"click\", function() { console.log(`Кнопка ${buttonId} нажата пользователем ${userId}`); });\n} setupButtonHandler(\"profileBtn\", 456);\n// При клике выведет: \"Кнопка profileBtn нажата пользователем 456\"\n// Даже если функция setupButtonHandler уже завершилась — замыкание сохранило userId\n<a data-tooltip-position=\"top\" aria-label=\"Каррированные функции\" data-href=\"Каррированные функции\" href=\"материалы/подтемы/секция-1.-javascript/тема-№10/каррированные-функции.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Каррирование</a> — это преобразование функции, принимающей несколько аргументов, в последовательность функций, каждая из которых принимает один аргумент. Основано на замыканиях.function multiply(a) { return function(b) { return function(c) { return a * b * c; }; };\n} const multiplyBy2 = multiply(2);\nconst multiplyBy2And5 = multiplyBy2(5);\nconsole.log(multiplyBy2And5(3)); // 30 // Или в одну строку:\nconsole.log(multiply(2)(5)(3)); // 30\nЗдесь каждая вложенная функция «запоминает» значение a, затем b, используя замыкание. Это позволяет создавать переиспользуемые частичные версии функций — например, для форматирования, валидации или настройки API-запросов.\nЗамыкание не создаёт копию переменной — оно ссылается на неё\nЕсли переменная меняется — замыкание видит новое значение\nЗамыкания могут вызывать утечки памяти, если держат ссылки на большие объекты без необходимости Замыкания — мощный инструмент. Используйте их для инкапсуляции данных, создания приватных состояний, управления контекстом в обработчиках и реализации каррированных функций — особенно в React, Vue или чистом JavaScript без фреймворков.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Пример 1: Настройки темы приложения","level":2,"id":"Пример_1_Настройки_темы_приложения_0"},{"heading":"Пример 2: Обработчик событий с контекстом","level":2,"id":"Пример_2_Обработчик_событий_с_контекстом_0"},{"heading":"Пример 3: Каррированные функции","level":2,"id":"Пример_3_Каррированные_функции_0"},{"heading":"Важно понимать:","level":2,"id":"Важно_понимать_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№10/каррированные-функции.html"],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№10/замыкания.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434751008,"modifiedTime":1760434751008,"sourceSize":4932,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Замыкания.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№10/замыкания.html","showInTree":true,"treeOrder":102,"backlinks":["лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№10/каррированные-функции.html":{"title":"Каррированные функции","icon":"","description":"Каррирование — это преобразование функции, которая принимает несколько аргументов, в последовательность функций, каждая из которых принимает ровно один аргумент.Результат — функция, которую можно вызывать по частям, сохраняя промежуточные состояния через замыкания.Пример:function multiply(a) { return function(b) { return function(c) { return a * b * c; }; };\n} const result = multiply(2)(5)(3); // 30\nЗдесь:\nmultiply(2) возвращает функцию, запоминающую a = 2\nmultiply(2)(5) возвращает функцию, запоминающую a = 2 и b = 5\nmultiply(2)(5)(3) возвращает результат: 2 * 5 * 3 = 30\nКаждый уровень — это новая функция, которая замыкает на переменные внешнего уровня.Каррирование позволяет создавать переиспользуемые частичные версии функций:function greet(greeting, name) { return `${greeting}, ${name}!`;\n} function curry(fn) { return function(a) { return function(b) { return fn(a, b); }; };\n} const greetWith = curry(greet);\nconst sayHello = greetWith(\"Привет\"); console.log(sayHello(\"Анна\")); // \"Привет, Анна!\"\nconsole.log(sayHello(\"Иван\")); // \"Привет, Иван!\"\nТеперь sayHello — это готовая функция, которая всегда использует \"Привет\". Её можно передавать как колбэк, использовать в массивах:const users = [\"Анна\", \"Иван\", \"Мария\"];\nconst greetings = users.map(sayHello);\n// [\"Привет, Анна!\", \"Привет, Иван!\", \"Привет, Мария!\"] Форматирование данных: formatDate(locale, format) → formatDateRu = curry(formatDate)(\"ru-RU\")\nВалидация: validateLength(min, max, value) → validateMin5 = curry(validateLength)(5, 100)\nНастройка запросов: apiRequest(method, url, headers) → get = curry(apiRequest)(\"GET\") Каррирование — не синтаксическая фича JavaScript, а паттерн, основанный на замыканиях.\nОн особенно полезен в функциональном стиле программирования и для создания гибких, переиспользуемых утилит.\nИспользуйте его, когда нужно создавать специализированные версии функций с предустановленными параметрами.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Почему это полезно","level":2,"id":"Почему_это_полезно_0"},{"heading":"В реальных сценариях","level":2,"id":"В_реальных_сценариях_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№10/каррированные-функции.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434736718,"modifiedTime":1760434736718,"sourceSize":3085,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Каррированные функции.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№10/каррированные-функции.html","showInTree":true,"treeOrder":103,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№10/замыкания.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№10/практические-последствия-(var).html":{"title":"Практические последствия (var)","icon":"","description":"var устарел, потому что его поведение непредсказуемо и ведёт к ошибкам, которые сложно отловить. Нет блочной области видимости\nПеременные var видны во всей функции, даже если объявлены внутри if или for:\nfunction test() { if (true) { var x = 10; } console.log(x); // 10 — не ошибка, хотя x объявлена внутри if\n} Это нарушает ожидания: переменная должна быть локальной для блока, но var делает её функциональной. Поднятие (hoisting) без инициализации\nvar поднимается в начало функции, но инициализируется значением undefined:\nconsole.log(y); // undefined — не ошибка!\nvar y = 5; Это может скрыть ошибки: вы используете переменную до её объявления — и ничего не падает. Можно переобъявить\nvar позволяет объявить одну и ту же переменную несколько раз — без ошибки:\nvar name = \"Анна\";\nvar name = \"Иван\"; // перезапись — без предупреждения\nconsole.log(name); // \"Иван\" Это легко приводит к случайной потере данных. let — для переменных, которые меняются.\nБлочная область видимости. Нельзя переобъявить в одной области.\nlet count = 0;\ncount = 1; // ок\nlet count = 2; // ошибка: Identifier 'count' has already been declared const — для констант и значений, которые не должны меняться.\nОбязательно инициализировать при объявлении.\nНе позволяет переприсвоить, но позволяет менять свойства объектов и элементы массивов.\nconst user = { id: 1 };\nuser.id = 2; // ок — меняем свойство\nuser = { id: 3 }; // ошибка — нельзя переприсвоить Всегда используйте let и const — они предсказуемы, безопасны и соответствуют современным стандартам.\nИзбегайте глобальных переменных — они конфликтуют между файлами, усложняют отладку и ломают модульность.\nОбъявляйте переменные как можно глубже — в том блоке, где они реально нужны.\nИспользуйте const по умолчанию — если значение не меняется.\nТолько если нужно переприсвоить — используйте let. Современные инструменты (ESLint, TypeScript, Babel) и стандарты (Airbnb, Google) запрещают var в новом коде.\nИспользование let и const — не вопрос стиля, а вопрос надёжности.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Почему <code>var</code> не рекомендуется","level":2,"id":"Почему_`var`_не_рекомендуется_0"},{"heading":"Что использовать вместо <code>var</code>","level":2,"id":"Что_использовать_вместо_`var`_0"},{"heading":"Рекомендации","level":2,"id":"Рекомендации_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№10/практические-последствия-(var).html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434742256,"modifiedTime":1760434742256,"sourceSize":3746,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Практические последствия (var).md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№10/практические-последствия-(var).html","showInTree":true,"treeOrder":104,"backlinks":["лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№10/функциональная-область-видимости.html":{"title":"Функциональная область видимости","icon":"","description":"Функциональная область видимости означает, что переменная, объявленная с помощью var внутри функции, доступна только внутри этой функции и во всех вложенных блоках — но не за пределами функции.Пример:function checkUser() { var isLoggedIn = true; if (isLoggedIn) { var message = \"Пользователь авторизован\"; console.log(message); // работает — внутри if } console.log(message); // тоже работает — message доступна в функции\n} checkUser();\nconsole.log(isLoggedIn); // ошибка: isLoggedIn is not defined\nconsole.log(message); // ошибка: message is not defined\nЗдесь isLoggedIn и message видны только внутри функции checkUser. За её пределами — недоступны. Это защищает внешний код от случайных перезаписей.Но есть важная особенность var: он не имеет блочной области видимости.Даже если переменная объявлена внутри if, for или while — она всё равно будет доступна во всей функции.Пример:function processSettings() { if (true) { var theme = \"dark\"; } console.log(theme); // \"dark\" — доступна, хотя объявлена внутри if\n} processSettings();\nТо же самое с циклом:function loopExample() { for (var i = 0; i &lt; 3; i++) { console.log(i); } console.log(i); // 3 — i доступна даже после цикла\n} loopExample();\nЭто поведение — особенность var. Он поднимается (hoisting) и привязывается к функции, а не к блоку {}.Почему это проблема:\nСложно отслеживать, где именно переменная была объявлена\nМожно случайно использовать переменную до её ожидаемого объявления\nВедёт к ошибкам при рефакторинге\nПоэтому в современном JavaScript var не рекомендуется. Вместо него используйте let и const — они дают блочную область видимости и предсказуемое поведение.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№10/функциональная-область-видимости.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434731775,"modifiedTime":1760434731776,"sourceSize":2668,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Функциональная область видимости.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№10/функциональная-область-видимости.html","showInTree":true,"treeOrder":105,"backlinks":["лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№10/что-такое-область-видимости.html":{"title":"Что такое область видимости","icon":"","description":"Область видимости — это часть кода, в пределах которой переменная или функция доступна для использования.Если переменная объявлена внутри определённой области — она видна только в ней и во всех вложенных областях. Если объявлена вне — она доступна повсюду. Это позволяет изолировать данные, чтобы они не мешали друг другу.Без правильного управления областью видимости:\nПеременные случайно перезаписываются\nСложно отлаживать код\nВозникают неожиданные ошибки, особенно при росте приложения\nПример:let userName = \"Анна\"; // глобальная переменная function setUserName() { let userName = \"Иван\"; // локальная переменная, не перезаписывает глобальную console.log(userName); // \"Иван\"\n} setUserName();\nconsole.log(userName); // \"Анна\" — не изменилось\nЗдесь две переменные с одинаковым именем, но в разных областях. Они не мешают друг другу. Это и есть суть области видимости.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№10/что-такое-область-видимости.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434715240,"modifiedTime":1760434715240,"sourceSize":1526,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Что такое область видимости.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№10/что-такое-область-видимости.html","showInTree":true,"treeOrder":106,"backlinks":["лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№11/вложенные-структуры.html":{"title":"Вложенные структуры","icon":"","description":"Вложенные структуры — это когда один тип данных содержит другой: массив внутри объекта, объект внутри массива, или даже объект внутри массива внутри другого объекта. Это основа для представления реальных данных в приложениях: список задач, профили пользователей с контактами, ответы API.Часто используется для хранения списков, связанных с сущностью.Пример: профиль пользователя с его задачами:const user = { name: 'Иван', email: 'ivan@example.com', tasks: [ 'Починить свет', 'Записаться к врачу', 'Написать отчёт' ]\n};\nДоступ к элементам:console.log(user.tasks[0]); // \"Починить свет\" // Добавить новую задачу\nuser.tasks.push('Позвонить маме');\nКогда каждый элемент массива — это сложная сущность с несколькими полями.Пример: список задач с метаданными:const tasks = [ { id: 1, title: 'Починить свет', completed: false, priority: 'high' }, { id: 2, title: 'Записаться к врачу', completed: true, priority: 'medium' }, { id: 3, title: 'Написать отчёт', completed: false, priority: 'low' }\n];\nТакой формат — стандарт для API, баз данных, локального хранилища.Доступ к данным:console.log(tasks[0].title); // \"Починить свет\"\nconsole.log(tasks[1].completed); // true\nПеребор:for (const task of tasks) { if (!task.completed) { console.log(`Невыполнено: ${task.title}`); }\n}\nЭто базовый шаблон, который вы будете встречать повсеместно — в Todo-приложениях, CRM, админках.const todoList = [ { title: 'Сделать уроки', completed: false }, { title: 'Купить хлеб', completed: true }, { title: 'Позвонить коллеге', completed: false }\n];\nКак обновить статус задачи:const index = 0;\ntodoList[index].completed = true;\nКак отфильтровать невыполненные:const incomplete = todoList.filter(task =&gt; !task.completed);\nКак добавить новую:todoList.push({ title: 'Убраться в комнате', completed: false });\nВложенные структуры позволяют:\nОписывать реальные сущности (пользователь → задачи → подзадачи)\nСтруктурировать данные для хранения в JSON\nЛегко передавать их через API (REST, GraphQL)\nУдобно отображать в интерфейсе (например, список задач в списке React) Всегда структурируйте данные так, чтобы их было легко читать, изменять и передавать. Вложенные объекты и массивы — основа этого подхода.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Массивы внутри объектов","level":2,"id":"Массивы_внутри_объектов_0"},{"heading":"Объекты внутри массивов","level":2,"id":"Объекты_внутри_массивов_0"},{"heading":"Пример: список задач с полями <code>title</code>, <code>completed</code>","level":2,"id":"Пример_список_задач_с_полями_`title`,_`completed`_0"},{"heading":"Почему это важно","level":2,"id":"Почему_это_важно_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№11/вложенные-структуры.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434742873,"modifiedTime":1760434742873,"sourceSize":3848,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Вложенные структуры.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№11/вложенные-структуры.html","showInTree":true,"treeOrder":108,"backlinks":["лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№11/конструктор-массива-array.html":{"title":"Конструктор массива Array","icon":"","description":"Конструктор new Array() может вести себя неожиданно — и это опасно.Вот два случая:const numbers = new Array(1, 2, 3);\nconsole.log(numbers); // [1, 2, 3]\nЗдесь всё нормально: передали три числа — получили массив из трёх элементов.const empty = new Array(5);\nconsole.log(empty); // [empty × 5] — не [0, 0, 0, 0, 0]!\nconsole.log(empty[0]); // undefined\nЗдесь вы не создали массив с пятью нулями. Вы создали массив из пяти пустых ячеек. Это не то же самое, что заполненный нулями массив.Попробуйте перебрать его:for (const item of empty) { console.log(item); // ничего не выведется — все элементы undefined\n}\nИли попробуйте использовать map:const doubled = empty.map(x =&gt; x * 2);\nconsole.log(doubled); // [empty × 5] — всё ещё пусто\nОн не сработает, потому что map пропускает пустые ячейки.const numbers = [1, 2, 3]; // ясно, что будет: три числа\nconst filled = new Array(5).fill(0); // если реально нужны нули — явно заполняем\nconst simple = [0, 0, 0, 0, 0]; // проще и понятнее Читаемо — сразу видно, что это массив.\nБыстро — JavaScript обрабатывает его эффективнее.\nБез сюрпризов — не путает длину и значения.\nСтандарт — так пишут все профессионалы. ❌ Не пишите new Array(5) — вы рискуете создать не то, что думаете.\n✅ Пишите [ ] — и если нужно заполнить — используйте .fill().\nПример безопасного создания массива из 5 нулей:const zeros = Array(5).fill(0); // [0, 0, 0, 0, 0]\nНо даже здесь — если вы не уверены, лучше сразу написать:const zeros = [0, 0, 0, 0, 0];\nПроще, понятнее, надёжнее.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Случай 1: несколько аргументов — работает как ожидается","level":2,"id":"Случай_1_несколько_аргументов_—_работает_как_ожидается_0"},{"heading":"Случай 2: один числовой аргумент — создаёт “пустой” массив нужной длины","level":2,"id":"Случай_2_один_числовой_аргумент_—_создаёт_“пустой”_массив_нужной_длины_0"},{"heading":"А теперь сравните с литералом:","level":2,"id":"А_теперь_сравните_с_литералом_0"},{"heading":"Почему литерал <code>[]</code> лучше?","level":3,"id":"Почему_литерал_`[]`_лучше?_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№11/конструктор-массива-array.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434734237,"modifiedTime":1760434734238,"sourceSize":2836,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Конструктор массива Array.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№11/конструктор-массива-array.html","showInTree":true,"treeOrder":109,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№11/массивы.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№11/массивы.html":{"title":"Массивы","icon":"","description":"Массив — это упорядоченная коллекция значений. Каждый элемент имеет числовой индекс, начиная с 0. Массивы используются для хранения списков: списка задач, списка пользователей, списка элементов в списке приложения.Самый распространённый способ — через литерал:const tasks = ['Почитать книгу', 'Сделать уборку', 'Написать код'];\nМожно создать через <a data-tooltip-position=\"top\" aria-label=\"Конструктор массива Array\" data-href=\"Конструктор массива Array\" href=\"материалы/подтемы/секция-1.-javascript/тема-№11/конструктор-массива-array.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">конструктор</a>, но это редко используется:const numbers = new Array(1, 2, 3);\nconst empty = new Array(5); // массив из 5 пустых ячеек (не [0,0,0,0,0]!)\nЛитерал [] предпочтительнее: он быстрее, понятнее и безопаснее.Обращение по индексу:console.log(tasks[0]); // \"Почитать книгу\"\nconsole.log(tasks[2]); // \"Написать код\"\nЕсли индекс не существует — вернётся undefined:console.log(tasks[5]); // undefined\nМногомерные массивы — это массивы, элементами которых являются другие массивы. Они используются для представления структур с несколькими уровнями вложенности: таблицы, матрицы, сетки интерфейса, списки задач с подзадачами.Простейший пример — двумерный массив (матрица 3x3):const matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9]\n];\nЭто массив из трёх элементов, каждый из которых — массив чисел.Доступ к элементу осуществляется через два индекса: сначала — строка, потом — столбец:console.log(matrix[0][0]); // 1\nconsole.log(matrix[1][2]); // 6\nconsole.log(matrix[2][1]); // 8\nЕсли попытаться обратиться к несуществующему индексу — получите undefined:console.log(matrix[3][0]); // undefined\nconsole.log(matrix[0][5]); // undefined\nУ массивов в JS существует достаточно большое количество методов для управления данными.\nВ рамках темы мы изучим самые часто используемые. Остальные же - вам необходимо будет изучать самостоятельно! Добавить в конец — push():tasks.push('Сделать 47 практику');\nconsole.log(tasks.length); // 4\nУдалить из конца — pop():const lastTask = tasks.pop();\nconsole.log(lastTask); // \"Сделать 47 практику\"\nconsole.log(tasks.length); // 3\nДобавить в начало — unshift():tasks.unshift('Позавтракать');\nconsole.log(tasks[0]); // \"Позавтракать\"\nУдалить из начала — shift():const firstTask = tasks.shift();\nconsole.log(firstTask); // \"Позавтракать\"\nЭти методы (push, pop, unshift, shift) меняют исходный массив — это мутация.Мощный метод для вставки, удаления или замены элементов по индексу.Синтаксис: splice(начальный индекс, количество удаляемых, ...новые элементы)Удалить 1 элемент начиная с индекса 1:const fruits = ['яблоко', 'банан', 'апельсин'];\nfruits.splice(1, 1); // удаляем \"банан\"\nconsole.log(fruits); // ['яблоко', 'апельсин']\nВставить элемент:fruits.splice(1, 0, 'груша'); // вставляем \"груша\" на позицию 1\nconsole.log(fruits); // ['яблоко', 'груша', 'апельсин']\nЗаменить элемент:fruits.splice(1, 1, 'киви'); // заменяем \"груша\" на \"киви\"\nconsole.log(fruits); // ['яблоко', 'киви', 'апельсин']\nКопирует часть массива без изменения исходного.Синтаксис: slice(начало, конец) — конец не включается.const items = ['a', 'b', 'c', 'd', 'e'];\nconst subset = items.slice(1, 4); // с индекса 1 до 3\nconsole.log(subset); // ['b', 'c', 'd']\nconsole.log(items); // ['a', 'b', 'c', 'd', 'e'] — не изменился\nindexOf() — возвращает индекс первого совпадения, или -1, если не найдено:const colors = ['красный', 'зелёный', 'синий'];\nconsole.log(colors.indexOf('зелёный')); // 1\nconsole.log(colors.indexOf('жёлтый')); // -1\nincludes() — возвращает true или false:console.log(colors.includes('синий')); // true\nconsole.log(colors.includes('жёлтый')); // false\nincludes() удобнее для проверки наличия, indexOf() — если нужно знать позицию.Цикл for — классический, с индексом:for (let i = 0; i &lt; tasks.length; i++) { console.log(`${i + 1}. ${tasks[i]}`);\n}\nЦикл for...of — перебирает значения, индекс не нужен:for (const task of tasks) { console.log(task);\n}\nfor...of предпочтителен, когда вам не нужен индекс — читаемо и безопасно.\nНе используйте for...in для массивов — он перебирает ключи (индексы как строки), и может вести себя неожиданно с дополнительными свойствами.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Создание массива","level":2,"id":"Создание_массива_0"},{"heading":"Доступ к элементам","level":2,"id":"Доступ_к_элементам_0"},{"heading":"Многомерные массивов","level":2,"id":"Многомерные_массивов_0"},{"heading":"Создание многомерного массива","level":3,"id":"Создание_многомерного_массива_0"},{"heading":"Методы массива","level":2,"id":"Методы_массива_0"},{"heading":"Изменение длины: добавление и удаление","level":3,"id":"Изменение_длины_добавление_и_удаление_0"},{"heading":"Метод <code>splice()</code>","level":3,"id":"Метод_`splice()`_0"},{"heading":"Метод <code>slice()</code>","level":3,"id":"Метод_`slice()`_0"},{"heading":"Поиск элемента","level":3,"id":"Поиск_элемента_0"},{"heading":"Перебор массива","level":2,"id":"Перебор_массива_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№11/конструктор-массива-array.html"],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№11/массивы.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434760719,"modifiedTime":1760434760719,"sourceSize":6898,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Массивы.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№11/массивы.html","showInTree":true,"treeOrder":110,"backlinks":["лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№11/объекты.html":{"title":"Объекты","icon":"","description":"Объект — это неупорядоченная коллекция пар ключ-значение. Ключ — это строка (или символ), значение — любой тип данных: число, строка, массив, другой объект, функция.Объекты используются для хранения структурированных данных: профиль пользователя, настройки приложения, ответ от API, данные задачи с метаданными.Самый распространённый способ — через литерал:const user = { name: 'Анна', age: 28, isAdmin: false\n};\nМожно создать через конструктор, но это редко используется:const settings = new Object();\nsettings.theme = 'dark';\nsettings.language = 'ru';\nЛитерал {} предпочтительнее: короче, понятнее, быстрее.Если ключ — валидный идентификатор (без пробелов, спецсимволов, не начинается с цифры):console.log(user.name); // \"Анна\"\nconsole.log(user.age); // 28\nИспользуется, если ключ содержит пробелы, спецсимволы, или если имя свойства динамическое:console.log(user['name']); // \"Анна\"\nconsole.log(user['age']); // 28 const prop = 'isAdmin';\nconsole.log(user[prop]); // false\nТакже скобки нужны для ключей с пробелами:const person = { 'first name': 'Иван', 'last-name': 'Петров'\n}; console.log(person['first name']); // \"Иван\"\nconsole.log(person['last-name']); // \"Петров\" Используйте точечную запись, если возможно — она читаемее. Используйте скобочную, когда нужно динамическое имя свойства.\nПросто присваиваем значение новому ключу:user.email = 'anna@example.com';\nuser['phone'] = '+7 (999) 123-45-67';\nТеперь объект выглядит так:{ name: 'Анна', age: 28, isAdmin: false, email: 'anna@example.com', phone: '+7 (999) 123-45-67'\n}\nОператор delete:delete user.age;\nconsole.log(user.age); // undefined\nУдаление не влияет на структуру других свойств — просто убирает пару ключ-значение.Функция может быть значением свойства — тогда она называется методом:const calculator = { a: 5, b: 3, add() { return this.a + this.b; }, multiply() { return this.a * this.b; }\n}; console.log(calculator.add()); // 8\nconsole.log(calculator.multiply()); // 15\nthis внутри метода ссылается на сам объект — это важно для доступа к его свойствам.Это ключевая особенность в сравнении с примитивными типами данных.Когда вы присваиваете объект переменной, вы не копируете его содержимое — вы копируете ссылку на место в памяти.const user1 = { name: 'Игорь' };\nconst user2 = user1; // Это не копия — это та же самая ссылка user2.name = 'Мария';\nconsole.log(user1.name); // \"Мария\" — изменилось и в user1!\nЭто значит:\nИзменение одного объекта влияет на все переменные, ссылающиеся на него.\nПри передаче объекта в функцию — функция может изменить его содержимое.\nЧтобы избежать этого, нужно создавать копию объекта — об этом позже в разделе про распаковку.Пример опасности:function updateName(user) { user.name = 'Аноним';\n} const profile = { name: 'Сергей' };\nupdateName(profile);\nconsole.log(profile.name); // \"Аноним\" — исходный объект изменён! Всегда помните: объекты — ссылочные типы. Если вам нужна независимая копия — используйте клонирование.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Создание объекта","level":2,"id":"Создание_объекта_0"},{"heading":"Доступ к свойствам","level":2,"id":"Доступ_к_свойствам_0"},{"heading":"Точечная запись","level":3,"id":"Точечная_запись_0"},{"heading":"Скобочная запись","level":3,"id":"Скобочная_запись_0"},{"heading":"Динамическое добавление и удаление","level":2,"id":"Динамическое_добавление_и_удаление_0"},{"heading":"Добавление","level":3,"id":"Добавление_0"},{"heading":"Удаление","level":3,"id":"Удаление_0"},{"heading":"Методы объектов","level":2,"id":"Методы_объектов_0"},{"heading":"Объекты передаются по ссылке","level":2,"id":"Объекты_передаются_по_ссылке_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№11/объекты.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434752388,"modifiedTime":1760434752388,"sourceSize":5144,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Объекты.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№11/объекты.html","showInTree":true,"treeOrder":111,"backlinks":["лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№11/оператор-rest.html":{"title":"Оператор rest","icon":"","description":"Оператор rest (...) — это синтаксис, который собирает несколько элементов в один массив или объект. Он противоположен spread: spread раскрывает, rest собирает.Используется для сбора всех переданных аргументов, которые не были явно описаны в списке параметров.function sum(...numbers) { return numbers.reduce((acc, n) =&gt; acc + n, 0);\n} console.log(sum(1, 2, 3)); // 6\nconsole.log(sum(10, 20, 30, 40)); // 100\nЗдесь numbers — это массив, содержащий все аргументы, переданные в функцию.\n...args — общепринятое имя, но можно использовать любое: ...values, ...items.\nПолезно, когда количество аргументов неизвестно заранее — например, при обработке пользовательского ввода или API с динамическими параметрами.Позволяет извлечь первые элементы, а остальные собрать в отдельный массив.const colors = ['красный', 'зелёный', 'синий', 'жёлтый']; const [first, second, ...others] = colors; console.log(first); // \"красный\"\nconsole.log(second); // \"зелёный\"\nconsole.log(others); // [\"синий\", \"жёлтый\"]\nМожно пропустить элементы:const [, , third, ...rest] = colors;\nconsole.log(third); // \"синий\"\nconsole.log(rest); // [\"жёлтый\"]\nЭто удобно, когда нужно работать с началом массива, а остальное — передать дальше или игнорировать.Извлекает конкретные свойства, а остальные собирает в новый объект.const user = { name: 'Анна', age: 28, email: 'anna@example.com', role: 'user'\n}; const { name, role, ...profile } = user; console.log(name); // \"Анна\"\nconsole.log(role); // \"user\"\nconsole.log(profile); // { age: 28, email: 'anna@example.com' }\nЧасто используется в React для передачи «оставшихся» пропсов:function Button({ variant, ...rest }) { return &lt;button className={variant} {...rest} /&gt;;\n}\nЗдесь variant обрабатывается отдельно, а остальные пропсы (onClick, disabled и т.д.) передаются прямо в &lt;button&gt;.Один и тот же синтаксис ... — но смысл зависит от контекста:\nВ объявлении (параметры функции, деструктуризация) — это rest.\nВ выражении (присваивание, вызов функции) — это spread.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"В параметрах функции","level":2,"id":"В_параметрах_функции_0"},{"heading":"В деструктуризации массивов","level":2,"id":"В_деструктуризации_массивов_0"},{"heading":"В деструктуризации объектов","level":2,"id":"В_деструктуризации_объектов_0"},{"heading":"Отличие от spread","level":2,"id":"Отличие_от_spread_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№11/оператор-rest.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434741906,"modifiedTime":1760434741906,"sourceSize":3651,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Оператор rest.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№11/оператор-rest.html","showInTree":true,"treeOrder":112,"backlinks":["лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№11/практические-рекомендации-по-массивам-и-объектам.html":{"title":"Практические рекомендации по массивам и объектам","icon":"","description":"В реальных приложениях важно управлять состоянием предсказуемо. Мутация исходных данных — частая причина багов: один компонент меняет данные, а другой, который их использует, получает неожиданные изменения.Если вам нужно изменить данные, но сохранить оригинал — создавайте копию, а не меняйте исходный объект.❌ Плохо — мутация:const tasks = ['Почитать', 'Написать код']; function addTask(task) { tasks.push(task); // Изменяем исходный массив!\n} addTask('Сделать уборку');\nconsole.log(tasks); // ['Почитать', 'Написать код', 'Сделать уборку'] — оригинал изменён\n✅ Хорошо — создание копии:const tasks = ['Почитать', 'Написать код']; function addTask(tasksList, task) { return [...tasksList, task]; // Новый массив, оригинал не тронут\n} const updatedTasks = addTask(tasks, 'Сделать уборку');\nconsole.log(tasks); // ['Почитать', 'Написать код'] — не изменился\nconsole.log(updatedTasks); // ['Почитать', 'Написать код', 'Сделать уборку']\nТо же правило для объектов:❌ Плохо:const user = { name: 'Анна', theme: 'light' }; function updateTheme(user, theme) { user.theme = theme; // Мутируем исходный объект return user;\n}\n✅ Хорошо:function updateTheme(user, theme) { return { ...user, theme }; // Новый объект с обновлённым свойством\n} const newUser = updateTheme(user, 'dark');\nconsole.log(user.theme); // \"light\" — не изменился\nconsole.log(newUser.theme); // \"dark\"\nКопирование с помощью ..., Array.from(), Object.assign() — это поверхностное клонирование. Оно копирует только первый уровень вложенности.Пример:const original = { name: 'Анна', tasks: ['Задача 1', 'Задача 2']\n}; const copy = { ...original }; copy.tasks.push('Задача 3'); console.log(original.tasks); // ['Задача 1', 'Задача 2', 'Задача 3'] — изменился!\nПочему? Потому что tasks — это массив, и он передаётся по ссылке. Ссылка скопировалась, но сам массив — один и тот же.Эти методы безопасны для простых данных. Но если в объекте есть вложенные массивы или объекты — они остаются по ссылке.\nДанные не имеют глубокой вложенности.\nВы работаете с плоскими структурами: профиль пользователя, настройки, простые задачи.\nВы используете библиотеки вроде Redux, Zustand, где ожидается неизменяемость.\nЕсли нужно скопировать вложенные структуры полностью — используйте библиотеки (например, lodash.cloneDeep) или специальные методы. В базовом JavaScript это сложно и неэффективно.\nНе используйте JSON.parse(JSON.stringify(obj)) для глубокого клонирования — он ломает функции, undefined, Date, Map, Set, и циклические ссылки.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Не мутировать исходные массивы/объекты","level":2,"id":"Не_мутировать_исходные_массивы/объекты_0"},{"heading":"Клонирование поверхностное","level":2,"id":"Клонирование_поверхностное_0"},{"heading":"Какие методы делают поверхностное клонирование:","level":3,"id":"Какие_методы_делают_поверхностное_клонирование_0"},{"heading":"Когда использовать поверхностное клонирование:","level":3,"id":"Когда_использовать_поверхностное_клонирование_0"},{"heading":"Глубокое клонирование — отдельная тема","level":3,"id":"Глубокое_клонирование_—_отдельная_тема_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№11/практические-рекомендации-по-массивам-и-объектам.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434748426,"modifiedTime":1760434748426,"sourceSize":4642,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Практические рекомендации по массивам и объектам.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№11/практические-рекомендации-по-массивам-и-объектам.html","showInTree":true,"treeOrder":113,"backlinks":["лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№11/преобразование-типов-(массивы-и-объекты)-через-json.html":{"title":"Преобразование типов (Массивы и Объекты) через JSON","icon":"","description":"Преобразование типов между объектами/массивами и строками — это основа для хранения и передачи данных в приложении. В JavaScript для этого используются два метода: JSON.stringify() и JSON.parse().Превращает объект или массив в строку в формате JSON — текстовом формате, понятном и серверам, и клиентам.\nПро сам формат мы прочтем в следующей теме.\nconst user = { name: 'Анна', age: 28, isAdmin: false, tasks: ['Почитать', 'Написать код']\n}; const jsonString = JSON.stringify(user);\nconsole.log(jsonString);\n// '{\"name\":\"Анна\",\"age\":28,\"isAdmin\":false,\"tasks\":[\"Почитать\",\"Написать код\"]}' Важно: JSON.stringify() не работает с функциями, undefined, Symbol и Map/Set. Они будут проигнорированы или заменены на null.\nПример с игнорированием:const obj = { name: 'Иван', func: function() { return 'test'; }, secret: undefined\n}; console.log(JSON.stringify(obj));\n// '{\"name\":\"Иван\"}' — функция и undefined пропущены\nПревращает строку в формате JSON обратно в объект или массив.const json = '{\"name\":\"Анна\",\"age\":28,\"isAdmin\":false}'; const user = JSON.parse(json);\nconsole.log(user.name); // \"Анна\"\nconsole.log(user.age); // 28\nconsole.log(typeof user); // \"object\" Если строка не является корректным JSON — будет ошибка SyntaxError.\nПример ошибки:JSON.parse('{name: \"Иван\"}'); // Ошибка! Ключи должны быть в кавычках\nJSON.parse('{\"name\": \"Иван\"'); // Ошибка! Нет закрывающей скобки\nПри запросах к серверу (через fetch, axios и т.д.) данные приходят в виде строки в формате JSON. Чтобы работать с ними как с объектами — нужно их распарсить.fetch('/api/user') .then(response =&gt; response.json()) // автоматически вызывает JSON.parse() .then(user =&gt; { console.log(user.name); // теперь можно работать как с объектом });\nТакже при сохранении данных в localStorage — они должны быть строками:const tasks = [{ title: 'Убраться', completed: false }]; // Сохраняем\nlocalStorage.setItem('tasks', JSON.stringify(tasks)); // Загружаем\nconst saved = localStorage.getItem('tasks');\nconst tasksList = JSON.parse(saved);\nconsole.log(tasksList[0].title); // \"Убраться\" Всегда используйте JSON.stringify() перед сохранением объектов в localStorage или отправкой на сервер.\nВсегда используйте JSON.parse() после получения строки из localStorage или ответа API.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"<code>JSON.stringify()</code>","level":2,"id":"`JSON.stringify()`_0"},{"heading":"<code>JSON.parse()</code>","level":2,"id":"`JSON.parse()`_0"},{"heading":"Использование при работе с API","level":2,"id":"Использование_при_работе_с_API_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№11/преобразование-типов-(массивы-и-объекты)-через-json.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434740957,"modifiedTime":1760434740957,"sourceSize":3471,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Преобразование типов (Массивы и Объекты) через JSON.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№11/преобразование-типов-(массивы-и-объекты)-через-json.html","showInTree":true,"treeOrder":114,"backlinks":["лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№11/распаковка-(spread).html":{"title":"Распаковка (spread)","icon":"","description":"Распаковка (spread) — это оператор ..., который раскрывает элементы массива или свойства объекта на отдельные значения. Он используется для создания копий, объединения структур и передачи аргументов.Чтобы создать поверхностную копию массива, используйте spread в квадратных скобках:const original = ['яблоко', 'груша'];\nconst copy = [...original]; copy.push('апельсин');\nconsole.log(original); // ['яблоко', 'груша'] — не изменился\nconsole.log(copy); // ['яблоко', 'груша', 'апельсин']\nЭто безопасный способ избежать мутации исходного массива.Аналогично — для объектов:const user = { name: 'Анна', age: 28 };\nconst profile = { ...user, city: 'Москва' }; console.log(user); // { name: 'Анна', age: 28 }\nconsole.log(profile); // { name: 'Анна', age: 28, city: 'Москва' }\nЕсли свойство с таким же ключом уже есть — оно перезаписывается:const settings = { theme: 'light', lang: 'ru' };\nconst newSettings = { ...settings, theme: 'dark' }; console.log(newSettings.theme); // \"dark\" — перезаписано\nС помощью spread можно объединить несколько массивов в один:const fruits = ['яблоко', 'груша'];\nconst vegetables = ['морковь', 'огурец'];\nconst groceries = [...fruits, ...vegetables]; console.log(groceries); // ['яблоко', 'груша', 'морковь', 'огурец']\nЭто проще и читаемее, чем concat().Объединение двух объектов с разными ключами:const config1 = { host: 'localhost', port: 3000 };\nconst config2 = { ssl: true, timeout: 5000 };\nconst finalConfig = { ...config1, ...config2 }; console.log(finalConfig);\n// { host: 'localhost', port: 3000, ssl: true, timeout: 5000 }\nЕсли ключи совпадают — значение из второго объекта перезаписывает первое.Spread позволяет передать элементы массива в функцию как отдельные аргументы.Пример: Math.max() принимает несколько чисел, но не массив:const numbers = [10, 5, 23, 8]; // Неверно:\nconsole.log(Math.max(numbers)); // NaN // Верно:\nconsole.log(Math.max(...numbers)); // 23 Распаковка работает только на уровне первого уровня вложенности — это поверхностная копия. Если внутри объекта или массива есть вложенные структуры — они остаются по ссылке.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Распаковка массивов","level":2,"id":"Распаковка_массивов_0"},{"heading":"Распаковка объектов","level":2,"id":"Распаковка_объектов_0"},{"heading":"Объединение массивов","level":2,"id":"Объединение_массивов_0"},{"heading":"Объединение объектов","level":2,"id":"Объединение_объектов_0"},{"heading":"Передача элементов массива как аргументов","level":2,"id":"Передача_элементов_массива_как_аргументов_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№11/распаковка-(spread).html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434740257,"modifiedTime":1760434740258,"sourceSize":3417,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Распаковка (spread).md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№11/распаковка-(spread).html","showInTree":true,"treeOrder":115,"backlinks":["лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№12/вкратце-о-rest.html":{"title":"Вкратце о REST","icon":"","description":"REST — это архитектурный подход для построения веб-сервисов, основанный на использовании стандартных HTTP-методов для работы с ресурсами. Подробнее с ним мы познакомимся в соответствующей теме, но некоторые основы стоит показать сейчас:\nРесурсы — сущности, которые можно запросить: /users, /tasks, /products Методы HTTP — действия над ресурсами: GET — получить список или один элемент POST — создать новый ресурс PUT / PATCH — обновить существующий DELETE — удалить ресурс Состояние — сервер не хранит сессию клиента (stateless). Каждый запрос должен содержать всё необходимое для обработки (например, токен авторизации в заголовке).\nПример запросов:GET /api/users → список пользователей\nPOST /api/users → создать нового пользователя\nGET /api/users/123 → получить пользователя с id=123\nPUT /api/users/123 → обновить данные пользователя 123\nDELETE /api/users/123 → удалить пользователя 123\nОтветы приходят в формате JSON — структурированные данные, которые легко читает клиент (веб или мобильное приложение).","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Основные принципы","level":2,"id":"Основные_принципы_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№12/вкратце-о-rest.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434721248,"modifiedTime":1760434721248,"sourceSize":1853,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №12/Вкратце о REST.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№12/вкратце-о-rest.html","showInTree":true,"treeOrder":117,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№12/гидратация.html":{"title":"Гидратация","icon":"","description":"Гидратация — это процесс, при котором JavaScript-приложение на клиенте «подключается» к уже сгенерированному сервером HTML, добавляя интерактивность без пересоздания разметки.Сервер на NodeJS получает запрос, запрашивает данные (например, список задач из базы), генерирует полный HTML и отправляет его браузеру:&lt;!DOCTYPE html&gt;\n&lt;html&gt; &lt;body&gt; &lt;div id=\"root\"&gt; &lt;h1&gt;Задачи&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Почитать&lt;/li&gt; &lt;li&gt;Написать код&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=\"/app.js\"&gt;&lt;/script&gt; &lt;/body&gt;\n&lt;/html&gt;\nБраузер мгновенно отображает этот HTML — пользователь видит контент сразу.\nЭто хорошо для скорости и SEO.Но пока ничего не работает:\n— Кнопки не реагируют\n— Нельзя добавить задачу\n— Нет обработчиков событийПочему? Потому что HTML — это статичный результат. Он не знает, что должен быть интерактивным.Когда загружается и выполняется JavaScript-файл (app.js), фреймворк (например, React, Vue) анализирует уже существующий HTML, сравнивает его с тем, что он ожидает сгенерировать, и привязывает события, состояния и логику к уже отрисованным элементам.Это не перерисовка. Это присоединение поведения к существующей разметке.Пример (упрощённо):// В React\nReactDOM.hydrate(&lt;App /&gt;, document.getElementById('root'));\n— React видит: «В DOM уже есть &lt;ul&gt;&lt;li&gt;Почитать&lt;/li&gt;&lt;/ul&gt;»\n— Он проверяет: «А должен ли я сгенерировать именно это?» — да\n— Он не удаляет элементы\n— Он добавляет обработчики кликов, состояния, эффекты — к тем же DOM-узламРезультат:\n— Пользователь видит контент сразу\n— Через долю секунды — кнопки становятся кликабельными\n— Приложение работает как обычное SPA\nВ CSR — сервер отдаёт пустой index.html. Разметка создаётся полностью JS — нет HTML для «подключения», поэтому гидратация не применяется.\nВ статическом вебе (WEB 1.0) — вообще нет JavaScript. Нет интерактивности — нет и гидратации. Гидратация требует, чтобы HTML, сгенерированный на сервере, точно совпадал с тем, что сгенерирует клиент.\nЕсли сервер отдал &lt;li&gt;Почитать&lt;/li&gt;, а React ожидает &lt;li data-id=\"1\"&gt;Почитать&lt;/li&gt; — будет ошибка. Если в разметке есть динамические данные (например, время, токены, пользовательские данные), они должны быть одинаковыми на сервере и клиенте. Гидратация — не бесплатна: JS-файл должен загрузиться и выполниться. Если он тяжёлый — интерактивность появится с задержкой. Вы заходите на сайт новостей:\nСервер (NodeJS + Next.js) получает запрос Запрашивает статьи из БД Генерирует HTML с заголовками, текстами, картинками Отдаёт браузеру: &lt;article&gt;&lt;h1&gt;Новость&lt;/h1&gt;&lt;p&gt;Текст...&lt;/p&gt;&lt;/article&gt;\n&lt;script src=\"/_next/.../page.js\"&gt;&lt;/script&gt; Браузер отображает статью мгновенно page.js загружается — React запускает hydrate() Клик по кнопке «Лайк» — работает, потому что React привязал обработчик к этому элементу\n→ Пользователь не видит «прыжков», не ждёт загрузки JS, чтобы увидеть контент — и при этом может взаимодействовать с приложением.Это стандарт для современных фреймворков: Next.js, Nuxt.js, SvelteKit.\nВ NodeJS-приложениях гидратация — не опциональная фича, а ключевой механизм для создания быстрых, SEO-оптимизированных веб-приложений. Тем не менее, в основном в течении курса мы будет создавать только CSR-SPA приложения.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Что происходит при SSR (Server-Side Rendering)?","level":2,"id":"Что_происходит_при_SSR_(Server-Side_Rendering)?_0"},{"heading":"Что делает гидратация?","level":2,"id":"Что_делает_гидратация?_0"},{"heading":"Зачем это нужно?","level":2,"id":"Зачем_это_нужно?_0"},{"heading":"Когда гидратация не нужна?","level":2,"id":"Когда_гидратация_не_нужна?_0"},{"heading":"Важные ограничения","level":2,"id":"Важные_ограничения_0"},{"heading":"Пример в реальном приложении","level":2,"id":"Пример_в_реальном_приложении_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№12/гидратация.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434758840,"modifiedTime":1760434758840,"sourceSize":6493,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №12/Гидратация.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№12/гидратация.html","showInTree":true,"treeOrder":118,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№12/разница-между-web-1.0-и-web-2.0-в-контексте-nodejs.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№12/маршрутизация-в-nodejs.html":{"title":"Маршрутизация в NodeJS","icon":"","description":"Маршрутизация — это сопоставление URL-путей с соответствующими обработчиками. Каждый запрос приходит с определённым путём (например, /, /about, /api/users) — сервер должен понять, какой код запустить для каждого из них.Встроенного роутера в NodeJS нет — его нужно писать вручную. Для этого используется свойство req.url, содержащее путь запроса.Пример:const http = require('http'); const server = http.createServer((req, res) =&gt; { const path = req.url; if (path === '/') { res.writeHead(200, { 'Content-Type': 'text/html' }); res.end('&lt;h1&gt;Главная страница&lt;/h1&gt;'); } else if (path === '/about') { res.writeHead(200, { 'Content-Type': 'text/html' }); res.end('&lt;h1&gt;О нас&lt;/h1&gt;'); } else if (path === '/api/users') { res.writeHead(200, { 'Content-Type': 'application/json' }); res.end(JSON.stringify([{ id: 1, name: 'Анна' }])); } else { res.writeHead(404, { 'Content-Type': 'text/html' }); res.end('&lt;h1&gt;404 Not Found&lt;/h1&gt;'); }\n}); server.listen(3000);\nЗапросы:\nGET / → главная страница GET /about → страница \"О нас\" GET /api/users → список пользователей в JSON GET /anything-else → 404 Нет зависимостей — работает на чистом NodeJS Прозрачно: видно, что происходит под капотом Подходит для обучения и простых серверов Полный контроль над логикой С ростом количества маршрутов код становится громоздким Нет поддержки параметров: /user/123, /post/:id — нужно писать регулярки или split('/') Нет методов (GET/POST): нужно проверять req.method отдельно Нет валидации, обработки ошибок, middleware Сложно масштабировать — не подходит для реальных проектов\nВ реальных проектах маршрутизацию не пишут вручную. Используют фреймворки, например Express.js, где всё выглядит так:app.get('/', (req, res) =&gt; res.send('Главная'));\napp.get('/about', (req, res) =&gt; res.send('О нас'));\napp.get('/api/users', (req, res) =&gt; res.json(users));\napp.post('/api/users', (req, res) =&gt; { /* создать пользователя */ });\nНо важно понимать: Express просто упрощает то, что вы уже умеете делать через http.\nПонимание базовой логики (req.url, req.method, res.end) — фундамент. Без него фреймворки — чёрный ящик.\nМаршрутизация — это не про библиотеки. Это про то, как сервер решает: «Что делать, когда пришёл запрос по этому пути?» — и это вы должны уметь делать вручную. Когда мы начнем изучать React - мы так-же затронем тему маршрутизации, и не смотря на то что это будет выполняться на стороне клиента - логика останется той же.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Простая маршрутизация через <code>req.url</code> и <code>if/switch</code>","level":2,"id":"Простая_маршрутизация_через_`req.url`_и_`if/switch`_0"},{"heading":"Плюсы ручной маршрутизации","level":3,"id":"Плюсы_ручной_маршрутизации_0"},{"heading":"Минусы ручной маршрутизации","level":3,"id":"Минусы_ручной_маршрутизации_0"},{"heading":"Автоматическая маршрутизация:","level":2,"id":"Автоматическая_маршрутизация_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№12/маршрутизация-в-nodejs.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434744151,"modifiedTime":1760434744151,"sourceSize":4010,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №12/Маршрутизация в NodeJS.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№12/маршрутизация-в-nodejs.html","showInTree":true,"treeOrder":119,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№12/основы-сервера-на-nodejs.html":{"title":"Основы сервера на NodeJS","icon":"","description":"NodeJS позволяет создавать серверы без внешних зависимостей — с помощью встроенного модуля http.Для запуска сервера импортируем модуль http и вызываем createServer(), который принимает функцию обработчика запросов:const http = require('http'); const server = http.createServer((req, res) =&gt; { // req — объект запроса от клиента // res — объект ответа, который мы отправляем обратно\n}); server.listen(3000, () =&gt; { console.log('Сервер запущен на http://localhost:3000');\n});\nЗапускаем скрипт — сервер ждёт подключений на порту 3000.Каждый раз, когда браузер или приложение делает запрос (например, открывает http://localhost:3000), вызывается функция-обработчик. В неё передаются два объекта:\nreq — запрос от клиента. Содержит URL, метод (GET/POST), заголовки.\nres — ответ, который сервер отправляет обратно. Используется для отправки данных и установки статуса.\nЧтобы ответить клиенту, используем методы res.writeHead() и res.end().\nres.writeHead(statusCode, headers) — устанавливает статус и заголовки ответа.\nres.end(content) — отправляет тело ответа и завершает соединение.\nПример: отправка текста:const http = require('http'); const server = http.createServer((req, res) =&gt; { res.writeHead(200, { 'Content-Type': 'text/plain' }); res.end('Hello World');\n}); server.listen(3000, () =&gt; { console.log('Сервер запущен на http://localhost:3000');\n});\nЧто происходит:\nКлиент заходит на http://localhost:3000\nСервер получает запрос\nОтправляет заголовок: статус 200 (OK), тип содержимого — текст\nОтправляет тело: \"Hello World\"\nЗакрывает соединение\nОткрываем браузер — видим просто текст: Hello World.\nВажно: если не вызвать res.end(), соединение останется висеть — клиент будет ждать ответа \"бесконечно\". Также важно указывать Content-Type. Без него браузер может неправильно интерпретировать ответ (например, отправить JSON как текст, и он не распарсится).\nПример с JSON:res.writeHead(200, { 'Content-Type': 'application/json' });\nres.end(JSON.stringify({ message: 'Привет', status: 'ok' }));\nЭто — основа любого сервера на NodeJS. Всё, что сложнее (маршрутизация, файлы, API), строится на этих же принципах.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Создание сервера","level":2,"id":"Создание_сервера_0"},{"heading":"Обработка запроса: <code>req</code> и <code>res</code>","level":2,"id":"Обработка_запроса_`req`_и_`res`_0"},{"heading":"Отправка ответа","level":2,"id":"Отправка_ответа_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№12/основы-сервера-на-nodejs.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434741145,"modifiedTime":1760434741145,"sourceSize":3491,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №12/Основы сервера на NodeJS.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№12/основы-сервера-на-nodejs.html","showInTree":true,"treeOrder":120,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№12/отправка-файлов-с-сервера.html":{"title":"Отправка файлов с сервера","icon":"","description":"Отправка статических файлов — HTML, CSS, JS, изображений — это основа любого веб-сервера. NodeJS позволяет отдавать их через модуль fs (file system).Это файлы, которые не генерируются динамически — они лежат на диске и просто читаются и отправляются клиенту.Пример структуры проекта:project/\n├── server.js\n├── index.html\n├── styles/\n│ └── style.css\n├── scripts/\n│ └── app.js\n└── images/ └── logo.png\nЗадача сервера: При запросе / → отдать index.html При запросе /styles/style.css → отдать style.css При запросе /images/logo.png → отдать logo.png\nИспользуем асинхронный метод fs.readFile() — он не блокирует поток выполнения.const http = require('http');\nconst fs = require('fs');\nconst path = require('path'); const server = http.createServer((req, res) =&gt; { // Преобразуем URL в путь к файлу let filePath = '.' + req.url; if (filePath === './') { filePath = './index.html'; } // Определяем MIME-тип по расширению файла const extname = path.extname(filePath); let contentType = 'text/html'; switch (extname) { case '.js': contentType = 'text/javascript'; break; case '.css': contentType = 'text/css'; break; case '.json': contentType = 'application/json'; break; case '.png': contentType = 'image/png'; break; case '.jpg': contentType = 'image/jpg'; break; case '.gif': contentType = 'image/gif'; break; } // Читаем файл fs.readFile(filePath, (error, content) =&gt; { if (error) { if (error.code === 'ENOENT') { // Файл не найден res.writeHead(404, { 'Content-Type': 'text/html' }); res.end('&lt;h1&gt;404 Not Found&lt;/h1&gt;'); } else { // Другая ошибка (например, доступ запрещён) res.writeHead(500, { 'Content-Type': 'text/html' }); res.end('&lt;h1&gt;500 Internal Server Error&lt;/h1&gt;'); } } else { // Успешно: отправляем содержимое res.writeHead(200, { 'Content-Type': contentType }); res.end(content); } });\n}); server.listen(3000);\nБраузер использует Content-Type, чтобы понять, как обработать ответ:\ntext/html — отображает как страницу text/css — применяет как стиль text/javascript — исполняет как скрипт image/png — показывает как изображение application/json — ожидает JSON-структуру\nЕсли Content-Type не указан или указан неверно — браузер может не загрузить CSS, не запустить JS или не показать картинку.\nENOENT — файл не найден → 404 Not Found Другие ошибки (например, нет прав на чтение) → 500 Internal Server Error\nВажно: никогда не показывайте пользователю технические детали ошибок — только общие сообщения.readFileSync() — синхронный метод. Он блокирует весь сервер, пока файл не прочитан.Пример:const content = fs.readFileSync('./index.html'); // 💥 Блокирует поток!\nres.end(content);\nПри одновременном запросе 100 пользователей — сервер на 100 мс будет «зависать» на каждом чтении. Это приведёт к полной остановке ответов.\nВ продакшене всегда используйте асинхронные методы: fs.readFile(), fs.promises.readFile()\nСинхронные методы (readFileSync, writeFileSync) — только для инициализации, скриптов, конфигов при запуске.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Статические файлы","level":2,"id":"Статические_файлы_0"},{"heading":"Чтение файлов: <code>fs.readFile()</code>","level":2,"id":"Чтение_файлов_`fs.readFile()`_0"},{"heading":"Почему важно правильно устанавливать <code>Content-Type</code>","level":2,"id":"Почему_важно_правильно_устанавливать_`Content-Type`_0"},{"heading":"Обработка ошибок","level":2,"id":"Обработка_ошибок_0"},{"heading":"Почему не использовать <code>fs.readFileSync()</code>","level":2,"id":"Почему_не_использовать_`fs.readFileSync()`_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№12/отправка-файлов-с-сервера.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434749989,"modifiedTime":1760434749989,"sourceSize":4796,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №12/Отправка файлов с сервера.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№12/отправка-файлов-с-сервера.html","showInTree":true,"treeOrder":121,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№12/разница-между-web-1.0-и-web-2.0-в-контексте-nodejs.html":{"title":"Разница между WEB 1.0 и WEB 2.0 в контексте NodeJS","icon":"","description":"В контексте NodeJS разница между WEB 1.0 и WEB 2.0 проявляется в том, как сервер формирует ответ и кто отвечает за отображение контента.Сервер просто читает файл с диска и отправляет его как есть.const fs = require('fs');\nconst http = require('http'); http.createServer((req, res) =&gt; { if (req.url === '/') { fs.readFile('./index.html', (err, data) =&gt; { if (err) { res.writeHead(404, { 'Content-Type': 'text/html' }); res.end('&lt;h1&gt;404 Not Found&lt;/h1&gt;'); } else { res.writeHead(200, { 'Content-Type': 'text/html' }); res.end(data); } }); }\n}).listen(3000);\n— index.html — это готовый HTML-документ, написанный заранее.\n— Нет данных из базы. Нет персонализации.\n— При изменении контента — нужно менять файл на диске.\n— Это статика. NodeJS здесь выступает как простой файловый сервер.Сервер не отдаёт HTML — он отдаёт данные.http.createServer((req, res) =&gt; { if (req.url === '/api/tasks') { res.writeHead(200, { 'Content-Type': 'application/json' }); res.end(JSON.stringify([ { id: 1, title: 'Почитать', completed: false }, { id: 2, title: 'Написать код', completed: true } ])); }\n}).listen(3000);\n— Клиент (браузер или мобильное приложение) делает запрос: fetch('/api/tasks')\n— Получает JSON\n— С помощью JavaScript (React, Vue, Vanilla JS) строит список задач в DOM\n— При обновлении — новый запрос, новый JSON, обновление интерфейсаЭто — чистый CSR (Client-Side Rendering).Сервер динамически создаёт HTML на основе данных, и отправляет его уже готовым.http.createServer((req, res) =&gt; { if (req.url === '/') { const tasks = [ { id: 1, title: 'Почитать', completed: false }, { id: 2, title: 'Написать код', completed: true } ]; let html = ` &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;Задачи&lt;/h1&gt; &lt;ul&gt; ${tasks.map(t =&gt; `&lt;li ${t.completed ? 'style=\"text-decoration:line-through\"' : ''}&gt;${t.title}&lt;/li&gt;`).join('')} &lt;/ul&gt; &lt;script src=\"/app.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `; res.writeHead(200, { 'Content-Type': 'text/html' }); res.end(html); }\n}).listen(3000);\n— Браузер получает полный HTML — сразу видит контент.\n— После загрузки скрипта app.js — React (или другой фреймворк) «подключается» к этому HTML и добавляет интерактивность — это называется <a data-tooltip-position=\"top\" aria-label=\"Гидратация\" data-href=\"Гидратация\" href=\"материалы/подтемы/секция-1.-javascript/тема-№12/гидратация.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">гидратация</a>.\n— SEO работает: поисковики видят полный контент.\n— Пример: Next.js, Nuxt.js — NodeJS-сервер генерирует HTML на лету.Сервер отдаёт минимальный HTML — без контента.http.createServer((req, res) =&gt; { if (req.url === '/') { res.writeHead(200, { 'Content-Type': 'text/html' }); res.end(` &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script src=\"/bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `); }\n}).listen(3000);\n— Браузер получает пустой div#root\n— Загружается bundle.js (мега-файл с React, логикой, компонентами)\n— Только после загрузки и выполнения JS — рендерится список задач\n— Пока JS не загрузился — пользователь видит пустую страницу\n— SEO сложный: поисковики могут не дождаться выполнения JS\nWEB 1.0 — HTML как файл. CSR — HTML как результат работы JS на клиенте. SSR — HTML как результат работы JS на сервере (с последующей гидратацией). NodeJS позволяет реализовывать все три подхода.\nWEB 1.0 — для статики.\nCSR — для SPA и мобильных веб-приложений.\nSSR — для SEO-чувствительных сайтов (магазины, новости, лендинги). Выбор зависит от цели: скорость отображения, SEO, сложность, масштабируемость.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"WEB 1.0: сервер отдаёт HTML-файл","level":2,"id":"WEB_1.0_сервер_отдаёт_HTML-файл_0"},{"heading":"WEB 2.0: сервер отдаёт JSON, клиент рендерит UI","level":2,"id":"WEB_2.0_сервер_отдаёт_JSON,_клиент_рендерит_UI_0"},{"heading":"SSR (Server-Side Rendering): HTML генерируется на сервере","level":2,"id":"SSR_(Server-Side_Rendering)_HTML_генерируется_на_сервере_0"},{"heading":"CSR (Client-Side Rendering): сервер отдаёт только оболочку","level":2,"id":"CSR_(Client-Side_Rendering)_сервер_отдаёт_только_оболочку_0"},{"heading":"Ключевое отличие","level":2,"id":"Ключевое_отличие_0"}],"links":["материалы/подтемы/секция-1.-javascript/тема-№12/гидратация.html"],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№12/разница-между-web-1.0-и-web-2.0-в-контексте-nodejs.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434753997,"modifiedTime":1760434753997,"sourceSize":5447,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №12/Разница между WEB 1.0 и WEB 2.0 в контексте NodeJS.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№12/разница-между-web-1.0-и-web-2.0-в-контексте-nodejs.html","showInTree":true,"treeOrder":122,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№12/web-1.0-(статический-веб).html":{"title":"WEB 1.0 (статический веб)","icon":"","description":"WEB 1.0 — это статический веб: сервер хранит файлы (HTML, CSS, JS, изображения) на диске и отдаёт их клиенту «как есть» при запросе.Когда пользователь вводит URL — например, http://example.com/index.html — веб-сервер (например, Apache или Nginx) находит файл index.html в папке сайта и отправляет его браузеру. Браузер просто отображает содержимое.Нет никакой логики на сервере. Нет баз данных. Нет обработки данных. Нет ответов в формате JSON. Сервер не «думает» — он только достаёт и отдаёт.Пример: сайт-визитка 2005 года\n— 5 страниц: index.html, about.html, contact.html, styles.css, script.js\n— Все файлы лежат в папке /var/www/html\n— При переходе на contact.html сервер находит файл и отправляет его целиком\n— Если нужно обновить текст — нужно загрузить новый HTML-файл на серверОграничения:\nНельзя показать разный контент для разных пользователей без создания отдельных файлов\nНельзя обновить часть страницы — только полная перезагрузка\nНет форм, отправки данных, динамических списков\nМасштабирование: добавление новой страницы = создание нового файла\nЭто был стандарт до середины 2000-х.\nСегодня такой подход используется только для статических сайтов (например, GitHub Pages, Vercel для статики), но без серверной логики. Например сайт, на котором вы сейчас читаете лекционный материал - относится именно к статическим сайтам.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№12/web-1.0-(статический-веб).html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434727396,"modifiedTime":1760434727396,"sourceSize":2316,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №12/WEB 1.0 (статический веб).md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№12/web-1.0-(статический-веб).html","showInTree":true,"treeOrder":123,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown"},"материалы/подтемы/секция-1.-javascript/тема-№12/web-2.0-(интерактивный-веб).html":{"title":"WEB 2.0 (интерактивный веб)","icon":"","description":"WEB 2.0 — это веб как платформа, а не набор статических страниц. Сервер больше не отдаёт HTML-файлы целиком — он отдаёт данные, а браузер (или мобильное приложение) сам строит интерфейс.Основа WEB 2.0 — асинхронные запросы: клиент (через JavaScript) отправляет запросы на сервер, получает ответ в формате JSON, и динамически обновляет часть страницы без перезагрузки. Это называется AJAX (Asynchronous JavaScript and XML).\nНо сейчас данные передаются в основном как JSON.\nСервер становится API-бэкендом: он не знает, как выглядит страница — он только обрабатывает запросы и возвращает данные.Пример: Gmail\n— Вы открываете mail.google.com — сервер отдаёт минимальный HTML и JS-файл\n— Браузер загружает JavaScript\n— JS отправляет запрос: GET /api/emails\n— Сервер отвечает: [ { \"id\": 123, \"from\": \"boss@company.com\", \"subject\": \"Отчёт\", \"read\": false }, { \"id\": 124, \"from\": \"friend@gmail.com\", \"subject\": \"Вечеринка\", \"read\": true }\n]\n— JavaScript получает список писем и рендерит их в список на странице\n— Когда вы нажимаете «Обновить» — снова запрос, снова JSON, снова обновление спискаПример: мобильное приложение с бэкендом\n— Приложение на React Native или Flutter\n— При запуске делает запрос: GET /api/user\n— Получает: { \"name\": \"Анна\", \"avatar\": \"https://example.com/avatar.jpg\", \"tasks\": 5 }\n— Отображает данные в интерфейсе\n— При нажатии кнопки «Создать задачу» — POST-запрос на /api/tasks с даннымиКлючевое отличие:\nДанные и представление разделены.\n— Сервер: только логика, база данных, API.\n— Клиент: только отображение, взаимодействие, UI. Это позволяет: Одному API обслуживать веб, мобильное приложение, десктоп Обновлять интерфейс без перезагрузки Работать оффлайн (с кэшированием) Масштабировать: серверы могут быть только для данных, клиенты — на любом устройстве\nWEB 2.0 — основа всех современных приложений: от VK до мобильных корпоративных систем.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-1.-javascript/тема-№12/web-2.0-(интерактивный-веб).html","pathToRoot":"../../../..","attachments":[],"createdTime":1760434737773,"modifiedTime":1760434737773,"sourceSize":3161,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №12/WEB 2.0 (интерактивный веб).md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№12/web-2.0-(интерактивный-веб).html","showInTree":true,"treeOrder":124,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown"},"материалы/файлы/pasted-image-20240923235323.html":{"title":"Pasted image 20240923235323","icon":"","description":"<img src=\"материалы/файлы/pasted-image-20240923235323.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/файлы/pasted-image-20240923235323.html","pathToRoot":"../..","attachments":["материалы/файлы/pasted-image-20240923235323.html"],"createdTime":1760434978750,"modifiedTime":1760434978792,"sourceSize":400632,"sourcePath":"Материалы/Файлы/Pasted image 20240923235323.png","exportPath":"материалы/файлы/pasted-image-20240923235323.html","showInTree":true,"treeOrder":155,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№4/примитивные-типы-данных-javascript.html"],"type":"attachment"},"материалы/файлы/pasted-image-20240928221620.html":{"title":"Pasted image 20240928221620","icon":"","description":"<img src=\"материалы/файлы/pasted-image-20240928221620.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/файлы/pasted-image-20240928221620.html","pathToRoot":"../..","attachments":["материалы/файлы/pasted-image-20240928221620.html"],"createdTime":1760434786268,"modifiedTime":1760434786283,"sourceSize":24101,"sourcePath":"Материалы/Файлы/Pasted image 20240928221620.png","exportPath":"материалы/файлы/pasted-image-20240928221620.html","showInTree":true,"treeOrder":156,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№4/установка-и-базовое-использование-node.js.html"],"type":"attachment"},"материалы/файлы/pasted-image-20240928222139.html":{"title":"Pasted image 20240928222139","icon":"","description":"<img src=\"материалы/файлы/pasted-image-20240928222139.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/файлы/pasted-image-20240928222139.html","pathToRoot":"../..","attachments":["материалы/файлы/pasted-image-20240928222139.html"],"createdTime":1760434810167,"modifiedTime":1760434810186,"sourceSize":78566,"sourcePath":"Материалы/Файлы/Pasted image 20240928222139.png","exportPath":"материалы/файлы/pasted-image-20240928222139.html","showInTree":true,"treeOrder":157,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№4/установка-и-базовое-использование-node.js.html"],"type":"attachment"},"материалы/файлы/pasted-image-20240928222237.html":{"title":"Pasted image 20240928222237","icon":"","description":"<img src=\"материалы/файлы/pasted-image-20240928222237.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/файлы/pasted-image-20240928222237.html","pathToRoot":"../..","attachments":["материалы/файлы/pasted-image-20240928222237.html"],"createdTime":1760434687819,"modifiedTime":1760434687832,"sourceSize":621,"sourcePath":"Материалы/Файлы/Pasted image 20240928222237.png","exportPath":"материалы/файлы/pasted-image-20240928222237.html","showInTree":true,"treeOrder":158,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№4/установка-и-базовое-использование-node.js.html"],"type":"attachment"},"материалы/файлы/pasted-image-20250912205946.html":{"title":"Pasted image 20250912205946","icon":"","description":"<img src=\"материалы/файлы/pasted-image-20250912205946.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/файлы/pasted-image-20250912205946.html","pathToRoot":"../..","attachments":["материалы/файлы/pasted-image-20250912205946.html"],"createdTime":1760434817865,"modifiedTime":1760434817874,"sourceSize":102416,"sourcePath":"Материалы/Файлы/Pasted image 20250912205946.png","exportPath":"материалы/файлы/pasted-image-20250912205946.html","showInTree":true,"treeOrder":159,"backlinks":["index.html"],"type":"attachment"},"материалы/файлы/pasted-image-20250912212732.html":{"title":"Pasted image 20250912212732","icon":"","description":"<img src=\"материалы/файлы/pasted-image-20250912212732.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/файлы/pasted-image-20250912212732.html","pathToRoot":"../..","attachments":["материалы/файлы/pasted-image-20250912212732.html"],"createdTime":1760434818431,"modifiedTime":1760434818438,"sourceSize":105027,"sourcePath":"Материалы/Файлы/Pasted image 20250912212732.png","exportPath":"материалы/файлы/pasted-image-20250912212732.html","showInTree":true,"treeOrder":160,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№3/самое-простое-использование-javascript.html"],"type":"attachment"},"материалы/файлы/pasted-image-20250912212810.html":{"title":"Pasted image 20250912212810","icon":"","description":"<img src=\"материалы/файлы/pasted-image-20250912212810.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/файлы/pasted-image-20250912212810.html","pathToRoot":"../..","attachments":["материалы/файлы/pasted-image-20250912212810.html"],"createdTime":1760434746634,"modifiedTime":1760434746634,"sourceSize":4324,"sourcePath":"Материалы/Файлы/Pasted image 20250912212810.png","exportPath":"материалы/файлы/pasted-image-20250912212810.html","showInTree":true,"treeOrder":161,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№3/самое-простое-использование-javascript.html"],"type":"attachment"},"материалы/файлы/pasted-image-20250912212840.html":{"title":"Pasted image 20250912212840","icon":"","description":"<img src=\"материалы/файлы/pasted-image-20250912212840.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/файлы/pasted-image-20250912212840.html","pathToRoot":"../..","attachments":["материалы/файлы/pasted-image-20250912212840.html"],"createdTime":1760434770458,"modifiedTime":1760434770458,"sourceSize":11213,"sourcePath":"Материалы/Файлы/Pasted image 20250912212840.png","exportPath":"материалы/файлы/pasted-image-20250912212840.html","showInTree":true,"treeOrder":162,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№3/самое-простое-использование-javascript.html"],"type":"attachment"},"материалы/файлы/pasted-image-20250912214611.html":{"title":"Pasted image 20250912214611","icon":"","description":"<img src=\"материалы/файлы/pasted-image-20250912214611.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/файлы/pasted-image-20250912214611.html","pathToRoot":"../..","attachments":["материалы/файлы/pasted-image-20250912214611.html"],"createdTime":1760434785185,"modifiedTime":1760434785185,"sourceSize":21467,"sourcePath":"Материалы/Файлы/Pasted image 20250912214611.png","exportPath":"материалы/файлы/pasted-image-20250912214611.html","showInTree":true,"treeOrder":163,"backlinks":["материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html"],"type":"attachment"},"материалы/файлы/pasted-image-20250912214624.html":{"title":"Pasted image 20250912214624","icon":"","description":"<img src=\"материалы/файлы/pasted-image-20250912214624.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/файлы/pasted-image-20250912214624.html","pathToRoot":"../..","attachments":["материалы/файлы/pasted-image-20250912214624.html"],"createdTime":1760434798143,"modifiedTime":1760434798145,"sourceSize":46166,"sourcePath":"Материалы/Файлы/Pasted image 20250912214624.png","exportPath":"материалы/файлы/pasted-image-20250912214624.html","showInTree":true,"treeOrder":164,"backlinks":["материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html"],"type":"attachment"},"материалы/файлы/pasted-image-20250912214643.html":{"title":"Pasted image 20250912214643","icon":"","description":"<img src=\"материалы/файлы/pasted-image-20250912214643.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/файлы/pasted-image-20250912214643.html","pathToRoot":"../..","attachments":["материалы/файлы/pasted-image-20250912214643.html"],"createdTime":1760434789622,"modifiedTime":1760434789624,"sourceSize":29457,"sourcePath":"Материалы/Файлы/Pasted image 20250912214643.png","exportPath":"материалы/файлы/pasted-image-20250912214643.html","showInTree":true,"treeOrder":165,"backlinks":["материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html"],"type":"attachment"},"материалы/файлы/pasted-image-20250912214649.html":{"title":"Pasted image 20250912214649","icon":"","description":"<img src=\"материалы/файлы/pasted-image-20250912214649.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/файлы/pasted-image-20250912214649.html","pathToRoot":"../..","attachments":["материалы/файлы/pasted-image-20250912214649.html"],"createdTime":1760434746608,"modifiedTime":1760434746609,"sourceSize":4311,"sourcePath":"Материалы/Файлы/Pasted image 20250912214649.png","exportPath":"материалы/файлы/pasted-image-20250912214649.html","showInTree":true,"treeOrder":166,"backlinks":["материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html"],"type":"attachment"},"материалы/файлы/pasted-image-20250912214653.html":{"title":"Pasted image 20250912214653","icon":"","description":"<img src=\"материалы/файлы/pasted-image-20250912214653.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/файлы/pasted-image-20250912214653.html","pathToRoot":"../..","attachments":["материалы/файлы/pasted-image-20250912214653.html"],"createdTime":1760434742670,"modifiedTime":1760434742671,"sourceSize":3794,"sourcePath":"Материалы/Файлы/Pasted image 20250912214653.png","exportPath":"материалы/файлы/pasted-image-20250912214653.html","showInTree":true,"treeOrder":167,"backlinks":["материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html"],"type":"attachment"},"материалы/файлы/pasted-image-20250917202240.html":{"title":"Pasted image 20250917202240","icon":"","description":"<img src=\"материалы/файлы/pasted-image-20250917202240.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/файлы/pasted-image-20250917202240.html","pathToRoot":"../..","attachments":["материалы/файлы/pasted-image-20250917202240.html"],"createdTime":1760434786268,"modifiedTime":1760434786289,"sourceSize":24101,"sourcePath":"Материалы/Файлы/Pasted image 20250917202240.png","exportPath":"материалы/файлы/pasted-image-20250917202240.html","showInTree":true,"treeOrder":168,"backlinks":[],"type":"attachment"},"материалы/файлы/qrcod_72k5.html":{"title":"qrcod_72k5","icon":"","description":"<img src=\"материалы/файлы/qrcod_72k5.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"материалы/файлы/qrcod_72k5.png","fullURL":"материалы/файлы/qrcod_72k5.html","pathToRoot":"../..","attachments":["материалы/файлы/qrcod_72k5.html"],"createdTime":1760434791609,"modifiedTime":1760434791609,"sourceSize":34656,"sourcePath":"Материалы/Файлы/qrcod_72k5.png","exportPath":"материалы/файлы/qrcod_72k5.html","showInTree":true,"treeOrder":169,"backlinks":["index.html"],"type":"attachment"},"index.html":{"title":"index","icon":"","description":"<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://t.me/+3RqHSkYzaXUyMTUy\" target=\"_self\">https://t.me/+3RqHSkYzaXUyMTUy</a><br><img alt=\"Pasted image 20250912205946.png\" src=\"материалы/файлы/pasted-image-20250912205946.png\" target=\"_self\"><br><img alt=\"qrcod_72k5.png\" src=\"материалы/файлы/qrcod_72k5.png\" target=\"_self\"><br><a data-href=\"Тема №1. Как создаются мобильные приложения\" href=\"лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №1. Как создаются мобильные приложения</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Разработка мобильных приложений","level":1,"id":"Разработка_мобильных_приложений_0"},{"heading":"Ссылка в канал","level":2,"id":"Ссылка_в_канал_0"},{"heading":"Ссылка на этот же сайт","level":2,"id":"Ссылка_на_этот_же_сайт_0"},{"heading":"Лекции начинаются тут","level":2,"id":"Лекции_начинаются_тут_0"}],"links":["лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html"],"author":"","coverImageURL":".","fullURL":"index.html","pathToRoot":".","attachments":["материалы/файлы/pasted-image-20250912205946.html","материалы/файлы/qrcod_72k5.html"],"createdTime":1760434673798,"modifiedTime":1760434673798,"sourceSize":361,"sourcePath":"index.md","exportPath":"index.html","showInTree":true,"treeOrder":170,"backlinks":[],"type":"markdown"},"задания/секция-1.-javascript/практика-№9.-csr-с-гидратацией.-интерактивный-счётчик.html":{"title":"Практика №9. CSR с гидратацией. Интерактивный счётчик","icon":"","description":"В рамках этого задания вам необходимо создать веб-приложение, использующее Client-Side Rendering (CSR) с последующей гидратацией. Сервер отдаёт минимальный HTML-шаблон без содержимого — только контейнер и скрипт. Всё поведение (счётчик, управление значениями, стили) реализуется исключительно на клиенте через JavaScript. Приложение — интерактивный счётчик с возможностью задавать начальное значение, минимальное и максимальное значение через атрибуты HTML. Сервер не участвует в логике — он только отдаёт статический index.html и app.js. Задание обязано быть опубликовано в новом приватном репозитории организации GitHub с названием Группа_Фамилия_task-9.index.html&lt;!DOCTYPE html&gt;\n&lt;html lang=\"ru\"&gt;\n&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Счётчик&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/style.css\"&gt;\n&lt;/head&gt;\n&lt;body&gt; &lt;div id=\"counter\" data-initial=\"0\" data-min=\"-5\" data-max=\"10\"&gt; &lt;/div&gt; &lt;script src=\"/app.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nstyle.cssbody { font-family: sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background-color: #f5f5f5;\n} #counter { text-align: center; padding: 2rem; border-radius: 12px; background-color: white; box-shadow: 0 4px 12px rgba(0,0,0,0.1); min-width: 200px;\n} #counter button { padding: 0.5rem 1rem; margin: 0 0.5rem; font-size: 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background-color 0.2s;\n} #counter button.decrease { background-color: #ff6b6b; color: white;\n} #counter button.reset { background-color: #f7b731; color: white;\n} #counter button.increase { background-color: #4ecdc4; color: white;\n} #counter span { font-size: 2rem; font-weight: bold; margin: 1rem 0; display: block;\n} #counter button:disabled { opacity: 0.5; cursor: not-allowed;\n}\nСоздайте HTTP-сервер на NodeJS, который:\nОтвечает на запрос GET / — отдаёт файл index.html\nОтвечает на запрос GET /app.js — отдаёт файл app.js\nДля всех остальных путей — отдаёт 404 с сообщением &lt;h1&gt;404 Not Found&lt;/h1&gt;\nИспользует только встроенные модули: http, path, fs\nНе использует readFileSync — только readFile\nУстанавливает правильный Content-Type: text/html для /\ntext/javascript для /app.js Сервер слушает порт 3000\nСоздайте файл index.html с минимальной структурой:\nИспользуйте &lt;div id=\"counter\"&gt; как контейнер для счётчика\nДобавьте три data-атрибута: data-initial — начальное значение (по умолчанию 0)\ndata-min — минимальное допустимое значение (по умолчанию -5)\ndata-max — максимальное допустимое значение (по умолчанию 10) Подключите стили из /style.css\nПодключите скрипт /app.js в конце &lt;body&gt;\nСоздайте файл style.css с базовыми стилями:\nСтили должны применяться только через классы — не через inline-стили\nКнопки должны иметь цвета и переходы\nСчётчик должен быть центрирован на странице\nСоздайте файл app.js, который:\nНаходит элемент #counter\nСчитывает значения из data-initial, data-min, data-max (преобразует в числа)\nЕсли атрибуты не заданы — использует значения по умолчанию: initial=0, min=-5, max=10\nГенерирует внутри #counter: &lt;span&gt; с текущим значением (изначально = initial)\nТри кнопки: «Уменьшить», «Сбросить», «Увеличить» При нажатии: «Уменьшить» — уменьшает значение на 1, но не ниже min\n«Увеличить» — увеличивает значение на 1, но не выше max\n«Сбросить» — возвращает значение к initial Кнопки «Уменьшить» и «Увеличить» должны отключаться, если достигнуты границы: min → кнопка «Уменьшить» → disabled\nmax → кнопка «Увеличить» → disabled Все изменения отображаются мгновенно — без перезагрузки\nНикаких внешних библиотек — только чистый JavaScript (ES5+)\nНикаких fetch(), innerHTML.\nПосле загрузки страницы:\nВ HTML: &lt;div id=\"counter\" data-initial=\"0\" data-min=\"-5\" data-max=\"10\"&gt;&lt;/div&gt;\nПосле выполнения app.js:\n&lt;div id=\"counter\" data-initial=\"0\" data-min=\"-5\" data-max=\"10\"&gt; &lt;span&gt;0&lt;/span&gt; &lt;button class=\"decrease\"&gt;Уменьшить&lt;/button&gt; &lt;button class=\"reset\"&gt;Сбросить&lt;/button&gt; &lt;button class=\"increase\"&gt;Увеличить&lt;/button&gt;\n&lt;/div&gt; При нажатии «Увеличить» 12 раз — значение станет 10, кнопка «Увеличить» станет disabled\nПри нажатии «Уменьшить» — значение упадёт до -5, кнопка «Уменьшить» станет disabled\nПри нажатии «Сбросить» — значение вернётся к 0, кнопки снова активны Сервер отдаёт только index.html, app.js и style.css — никаких других файлов\nВсе логика — на клиенте\nНикаких React, Vue, jQuery — только чистый JS\nСкрипт должен работать сразу после загрузки — без DOMContentLoaded (можно использовать defer или просто поместить в конец &lt;body&gt;)\nСтили — только в style.css, не в JS\nНикаких alert(), console.log() в финальной версии\nНа выполнение выделяется 4 практических пары.\nГрадация баллов после дедлайна: 1 пара: 50% 2 пара: 25% 3 пара: 0% ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Общее описание","level":2,"id":"Общее_описание_0"},{"heading":"Ресурсы","level":2,"id":"Ресурсы_0"},{"heading":"Техническое задание","level":2,"id":"Техническое_задание_0"},{"heading":"1. Серверная часть (NodeJS)","level":3,"id":"1._Серверная_часть_(NodeJS)_0"},{"heading":"2. HTML-шаблон (index.html)","level":3,"id":"2._HTML-шаблон_(`index.html`)_0"},{"heading":"3. Стили (style.css)","level":3,"id":"3._Стили_(`style.css`)_0"},{"heading":"4. Клиентский скрипт (app.js)","level":3,"id":"4._Клиентский_скрипт_(`app.js`)_0"},{"heading":"5. Пример работы","level":3,"id":"5._Пример_работы_0"},{"heading":"6. Технические требования","level":3,"id":"6._Технические_требования_0"},{"heading":"Время на выполнение","level":2,"id":"Время_на_выполнение_0"},{"heading":"Баллы","level":2,"id":"Баллы_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"задания/секция-1.-javascript/практика-№9.-csr-с-гидратацией.-интерактивный-счётчик.html","pathToRoot":"../..","attachments":[],"createdTime":1760434765167,"modifiedTime":1760434765167,"sourceSize":7896,"sourcePath":"Задания/Секция 1. JavaScript/Практика №9. CSR с гидратацией. Интерактивный счётчик.md","exportPath":"задания/секция-1.-javascript/практика-№9.-csr-с-гидратацией.-интерактивный-счётчик.html","showInTree":true,"treeOrder":10,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown"},"задания/секция-2.-react/практика-№10.-интерактивный-счётчик-с-изменением-темы.html":{"title":"Практика №10. Интерактивный счётчик с изменением темы","icon":"","description":"В рамках этого задания вам необходимо создать одностраничное веб-приложение с интерактивным счётчиком и возможностью смены темы. Оно обязано быть сделано при помощи React (vite), следовать правильному неймингу и иметь правильную структуру.Задание обязано быть опубликовано в новом приватном репозитории организации GitHub с названием Группа_Фамилия_task-10.Рекомендуется использовать заготовку из ресурсов.Заготовка проекта react-project.\n(Материалы/Заготовки под практики/react-project.zip)\nСоздайте новый компонент который реализует интерактивный счётчик со следующими параметрами: min\nmax\ninitial (по умолчанию должен стать min если не указано) Отобразите текущее значение счётчика в элементе и добавьте компонент в App (с заданными значениями). min = 0\nmax = 10\ninitial = 5 Под значением разместите три кнопки в одном контейнере: Кнопка «Уменьшить»\nКнопка «Сбросить»\nКнопка «Увеличить» Реализуйте логику: При нажатии «Уменьшить» значение уменьшается на 1, но не ниже min.\nПри нажатии «Увеличить» значение увеличивается на 1, но не выше max.\nПри нажатии «Сбросить» значение возвращается к initial. Кнопки должны автоматически отключаться при достижении границ: Если текущее значение равно min, кнопка «Уменьшить» имеет атрибут disabled.\nЕсли текущее значение равно max, кнопка «Увеличить» имеет атрибут disabled. Все изменения должны отображаться мгновенно без перезагрузки страницы.\nИспользуйте только встроенные средства React (хуки useState и JSX). Запрещено использовать innerHTML, сторонние библиотеки или глобальные переменные вне компонента.\nЗначения не должны сохраняться между сессиями.\nРеализуйте переключение между светлой и тёмной темой:\nДобавьте кнопку «Сменить тему» как отдельный компонент.\nПри первом запуске приложение использует светлую тему.\nПри нажатии на кнопку тема переключается: светлая ↔ тёмная.\nВ тёмной теме фон страницы — тёмно-серый (#121212), текст — белый (#ffffff).\nВ светлой теме фон — белый (#ffffff), текст — чёрный (#000000).\nСостояние темы должно восстанавливаться при перезагрузке страницы даже после перезагрузки браузера.\nПомимо фона, оно должно влиять и на компоненты счётчика и саму кнопку переключения.\nНа выполнение выделяется 3 практических пары.\nГрадация баллов после дедлайна:\n1 пара: 50%\n2 пара: 25%\n3 пара: 10%\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Общее описание","level":2,"id":"Общее_описание_0"},{"heading":"Ресурсы","level":2,"id":"Ресурсы_0"},{"heading":"Техническое задание","level":2,"id":"Техническое_задание_0"},{"heading":"Дополнительная часть","level":2,"id":"Дополнительная_часть_0"},{"heading":"Время на выполнение","level":2,"id":"Время_на_выполнение_0"},{"heading":"Баллы","level":2,"id":"Баллы_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"задания/секция-2.-react/практика-№10.-интерактивный-счётчик-с-изменением-темы.html","pathToRoot":"../..","attachments":[],"createdTime":1760713615782,"modifiedTime":1760725367842,"sourceSize":4635,"sourcePath":"Задания/Секция 2. React/Практика №10. Интерактивный счётчик с изменением темы.md","exportPath":"задания/секция-2.-react/практика-№10.-интерактивный-счётчик-с-изменением-темы.html","showInTree":true,"treeOrder":12,"backlinks":["лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html"],"type":"markdown"},"лекции/секция-2.-react/тема-№13.-основы-react.html":{"title":"Тема №13. Основы React","icon":"","description":"В этой теме вы познакомитесь с библиотекой React — инструментом для создания пользовательских интерфейсов в веб-приложениях на JavaScript. Изучите ключевые концепции: компоненты, JSX и как создавать проекты React. Это фундамент для разработки интерфейсов в приложениях на React Native.\n<a data-href=\"Что такое React\" href=\"материалы/подтемы/секция-2.-react/тема-№13/что-такое-react.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Что такое React</a>\n<br><a data-href=\"JSX\" href=\"материалы/подтемы/секция-2.-react/тема-№13/jsx.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">JSX</a>\n<br><a data-href=\"Компоненты\" href=\"материалы/подтемы/секция-2.-react/тема-№13/компоненты.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Компоненты</a>\n<br><a data-href=\"Создание и запуск React-проекта\" href=\"материалы/подтемы/секция-2.-react/тема-№13/создание-и-запуск-react-проекта.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Создание и запуск React-проекта</a>\n<br><a data-href=\"Типичная структура React-приложения\" href=\"материалы/подтемы/секция-2.-react/тема-№13/типичная-структура-react-приложения.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Типичная структура React-приложения</a>\n(пусто)<br><a data-href=\"Тема №14. Работа со стилями, изображениями и файлами в React\" href=\"лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №14. Работа со стилями, изображениями и файлами в React</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-2.-react/тема-№13/что-такое-react.html","материалы/подтемы/секция-2.-react/тема-№13/jsx.html","материалы/подтемы/секция-2.-react/тема-№13/компоненты.html","материалы/подтемы/секция-2.-react/тема-№13/создание-и-запуск-react-проекта.html","материалы/подтемы/секция-2.-react/тема-№13/типичная-структура-react-приложения.html","лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-2.-react/тема-№13.-основы-react.html","pathToRoot":"../..","attachments":[],"createdTime":1760704333534,"modifiedTime":1760715448464,"sourceSize":958,"sourcePath":"Лекции/Секция 2. React/Тема №13. Основы React.md","exportPath":"лекции/секция-2.-react/тема-№13.-основы-react.html","showInTree":true,"treeOrder":28,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown"},"лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html":{"title":"Тема №14. Работа со стилями, изображениями и файлами в React","icon":"","description":"В этой теме вы научитесь правильно подключать изображения, шрифты и другие ресурсы в React-приложении через импорт, поймёте, как работает сборщик (Webpack/Vite), почему файлы кажутся исчезающими после сборки и как избежать ошибок, связанных с неправильным путём. Это фундамент для создания стабильных, корректно собранных приложений — где всё отображается, как задумано.\n<a data-href=\"Импорт функций и переменных JS\" href=\"материалы/подтемы/секция-2.-react/тема-№14/импорт-функций-и-переменных-js.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Импорт функций и переменных JS</a>\n<br><a data-href=\"Как React обрабатывает импорт файлов\" href=\"материалы/подтемы/секция-2.-react/тема-№14/как-react-обрабатывает-импорт-файлов.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Как React обрабатывает импорт файлов</a>\n<br><a data-href=\"Какие файлы можно импортировать\" href=\"материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Какие файлы можно импортировать</a>\n<br><a data-href=\"Что делать с файлами в папке public\" href=\"материалы/подтемы/секция-2.-react/тема-№14/что-делать-с-файлами-в-папке-public.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Что делать с файлами в папке public</a>\n<br><a data-href=\"Работа со стилями и файлами\" href=\"материалы/подтемы/секция-2.-react/тема-№14/работа-со-стилями-и-файлами.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Работа со стилями и файлами</a>\n<br><a data-href=\"Практические ошибки и как их избежать\" href=\"материалы/подтемы/секция-2.-react/тема-№14/практические-ошибки-и-как-их-избежать.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Практические ошибки и как их избежать</a>\n(пусто)<br><a data-href=\"Тема №15. Хранение и передача данных в React\" href=\"лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №15. Хранение и передача данных в React</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-2.-react/тема-№14/импорт-функций-и-переменных-js.html","материалы/подтемы/секция-2.-react/тема-№14/как-react-обрабатывает-импорт-файлов.html","материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html","материалы/подтемы/секция-2.-react/тема-№14/что-делать-с-файлами-в-папке-public.html","материалы/подтемы/секция-2.-react/тема-№14/работа-со-стилями-и-файлами.html","материалы/подтемы/секция-2.-react/тема-№14/практические-ошибки-и-как-их-избежать.html","лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html","pathToRoot":"../..","attachments":[],"createdTime":1760715494814,"modifiedTime":1760717797893,"sourceSize":1298,"sourcePath":"Лекции/Секция 2. React/Тема №14. Работа со стилями, изображениями и файлами в React.md","exportPath":"лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html","showInTree":true,"treeOrder":29,"backlinks":["лекции/секция-2.-react/тема-№13.-основы-react.html"],"type":"markdown"},"лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html":{"title":"Тема №15. Хранение и передача данных в React","icon":"","description":"В этой теме вы изучите механизмы управления состоянием и передачи данных между компонентами в React — основу для построения интерактивных интерфейсов. Поймёте, как хранить данные внутри компонента с помощью хуков, как передавать их через свойства и как сохранять их между сессиями — что критично для обеспечения постоянства пользовательских настроек и кэширования информации.\n<a data-href=\"Состояние и хук useState\" href=\"материалы/подтемы/секция-2.-react/тема-№15/состояние-и-хук-usestate.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Состояние и хук useState</a>\n<br><a data-href=\"Передача данных через props\" href=\"материалы/подтемы/секция-2.-react/тема-№15/передача-данных-через-props.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Передача данных через props</a>\n<br><a data-href=\"Хранение данных между сессиями\" href=\"материалы/подтемы/секция-2.-react/тема-№15/хранение-данных-между-сессиями.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Хранение данных между сессиями</a>\n(пусто)<br><a data-href=\"Тема №16. События и Ref в React\" href=\"лекции/секция-2.-react/тема-№16.-события-и-ref-в-react.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №16. События и Ref в React</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-2.-react/тема-№15/состояние-и-хук-usestate.html","материалы/подтемы/секция-2.-react/тема-№15/передача-данных-через-props.html","материалы/подтемы/секция-2.-react/тема-№15/хранение-данных-между-сессиями.html","лекции/секция-2.-react/тема-№16.-события-и-ref-в-react.html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html","pathToRoot":"../..","attachments":[],"createdTime":1760711594461,"modifiedTime":1768934440848,"sourceSize":1062,"sourcePath":"Лекции/Секция 2. React/Тема №15. Хранение и передача данных в React.md","exportPath":"лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html","showInTree":true,"treeOrder":30,"backlinks":["лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№13/компоненты.html":{"title":"Компоненты","icon":"","description":"Компонент в React — это самостоятельная, переиспользуемая часть пользовательского интерфейса. Он инкапсулирует свою разметку (через JSX), логику и стили, и может использоваться как отдельный элемент в других частях приложения.Самый простой способ создать компонент — объявить функцию. Такие компоненты называются функциональными:function Button() { return &lt;button&gt;Нажми меня&lt;/button&gt;;\n}\nФункция-компонент должна возвращать JSX. Этот JSX описывает, что будет отображаться в DOM. Возвращаемое значение может быть одним элементом, фрагментом (&lt;&gt;...&lt;/&gt;) или даже null, если компонент ничего не должен рендерить.Имена компонентов всегда начинаются с заглавной буквы. Это правило позволяет React отличать пользовательские компоненты от встроенных HTML-тегов. Например:\n&lt;div /&gt; — это HTML-элемент.\n&lt;Button /&gt; — это компонент.\nЕсли назвать компонент с маленькой буквы (button), React обработает его как обычный DOM-тег, и код не сработает как ожидается.Компоненты можно вкладывать друг в друга, создавая сложные интерфейсы из простых частей:function App() { return ( &lt;div&gt; &lt;Header /&gt; &lt;MainContent /&gt; &lt;Footer /&gt; &lt;/div&gt; );\n}\nКаждый из этих компонентов (Header, MainContent, Footer) может быть определён отдельно и использован в других местах.Разбиение интерфейса на мелкие компоненты упрощает разработку, тестирование и поддержку кода. Вместо одного большого файла с тысячей строк вы работаете с множеством маленьких, понятных и независимых блоков.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Именование компонентов","level":2,"id":"Именование_компонентов_0"},{"heading":"Переиспользование и композиция","level":2,"id":"Переиспользование_и_композиция_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№13/компоненты.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760709835652,"modifiedTime":1760709880963,"sourceSize":2649,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №13/Компоненты.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№13/компоненты.html","showInTree":true,"treeOrder":127,"backlinks":["лекции/секция-2.-react/тема-№13.-основы-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№13/создание-и-запуск-react-проекта.html":{"title":"Создание и запуск React-проекта","icon":"","description":"Чтобы начать разработку на React, нужно создать проект с помощью инструмента сборки. Современные React-приложения не запускаются напрямую в браузере — они требуют транспиляции (например, преобразования JSX в обычный JavaScript), сборки модулей и запуска локального сервера для разработки.Существует несколько способов создать такой проект. Наиболее популярные — Create React App (CRA) и Vite. Оба автоматически настраивают окружение, но отличаются подходом, скоростью и гибкостью.Независимо от выбранного инструмента, после создания проекта вы получаете:\nЛокальный сервер разработки с поддержкой горячей перезагрузки (изменения в коде мгновенно отображаются в браузере без полной перезагрузки страницы).\nАвтоматическую транспиляцию JSX и современного JavaScript.\nГотовую конфигурацию для запуска, сборки и тестирования. Убедитесь, что установлен Node.js (версия 18 или выше рекомендуется).\nВыберите инструмент: CRA или Vite.\nВыполните команду создания проекта в терминале.\nПерейдите в папку проекта и запустите dev-сервер.\nДетали по каждому инструменту вынесены в отдельные подстраницы.<a data-href=\"Create React App (CRA)\" href=\"материалы/подтемы/секция-2.-react/тема-№13/create-react-app-(cra).html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Create React App (CRA)</a><br>\n<a data-href=\"Vite\" href=\"материалы/подтемы/секция-2.-react/тема-№13/vite.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Vite</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Основные шаги","level":2,"id":"Основные_шаги_0"}],"links":["материалы/подтемы/секция-2.-react/тема-№13/create-react-app-(cra).html","материалы/подтемы/секция-2.-react/тема-№13/vite.html"],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№13/создание-и-запуск-react-проекта.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760709853189,"modifiedTime":1760709983253,"sourceSize":2023,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №13/Создание и запуск React-проекта.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№13/создание-и-запуск-react-проекта.html","showInTree":true,"treeOrder":128,"backlinks":["лекции/секция-2.-react/тема-№13.-основы-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№13/типичная-структура-react-приложения.html":{"title":"Типичная структура React-приложения","icon":"","description":"Структура React-приложения определяется инструментом сборки (например, Vite или Create React App), но вы можете организовать файлы как угодно. Однако со временем в сообществе сложились общепринятые практики, которые делают код читаемым, поддерживаемым и масштабируемым.Вот типичная структура всего проекта:my-app/\n├── node_modules/ # Установленные зависимости (не редактируется вручную)\n├── public/ # Статические файлы, которые копируются \"как есть\" в сборку\n│ ├── index.html # Основной HTML-файл с контейнером для React (&lt;div id=\"root\"&gt;)\n│ ├── favicon.ico # Иконка вкладки браузера\n│ └── ... # Другие файлы, доступные напрямую по пути (robots.txt, manifest.json и т.п.)\n├── src/ # Исходный код приложения\n│ ├── main.jsx # Точка входа: инициализация React и рендеринг корневого компонента\n│ ├── App.jsx # Корневой компонент приложения\n│ ├── components/ # Переиспользуемые UI-элементы: кнопки, карточки, инпуты\n│ ├── pages/ # Крупные компоненты, представляющие отдельные экраны или разделы\n│ ├── assets/ # Изображения, шрифты, иконки, используемые в компонентах\n│ ├── styles/ # Глобальные CSS-файлы, переменные темы, общие стили\n│ ├── hooks/ # Кастомные хуки (если используются)\n│ └── utils/ # Вспомогательные функции: форматирование, валидация и т.п.\n├── .gitignore # Файлы и папки, исключённые из системы контроля версий\n├── package.json # Зависимости, скрипты запуска и метаданные проекта\n├── vite.config.js # Конфигурация Vite (или webpack.config.js в CRA)\n└── ... # Другие конфигурационные файлы (если есть)\nФайлы из public/ не обрабатываются сборщиком. Они копируются в корень итоговой сборки без изменений. Например, public/favicon.ico будет доступен как /favicon.ico в браузере. Используйте эту папку только для файлов, которые должны сохранять точное имя и путь (например, манифест PWA или файлы для SEO).Вся логика приложения живёт в src/. Именно отсюда начинается сборка. Файлы вне src/ (кроме public/) обычно не участвуют в работе приложения напрямую.В React вы можете использовать два основных подхода к стилям:Хранятся в папке styles/ или подключаются напрямую в main.jsx или index.html. Они применяются ко всему приложению:/* src/styles/global.css */\nbody { margin: 0; font-family: sans-serif;\n}\nТакие стили полезны для сброса браузерных значений, настройки шрифтов или цветовой палитры.Часто каждый компонент имеет свой собственный CSS-файл, размещённый рядом с ним:components/\n├── Button.jsx\n└── Button.css\nВ компоненте стили импортируются как модуль:// Button.jsx\nimport './Button.css'; export function Button() { return &lt;button className=\"primary-button\"&gt;Нажми&lt;/button&gt;;\n}\nТакой подход инкапсулирует стили внутри компонента, но классы всё ещё глобальны — если два компонента используют одинаковое имя класса, они могут конфликтовать.Чтобы избежать конфликтов имён, можно использовать CSS Modules. Для этого файл стилей называют с расширением .module.css:/* Button.module.css */\n.btn { background: blue; color: white;\n}\nИмпорт происходит как объект:// Button.jsx\nimport styles from './Button.module.css'; export function Button() { return &lt;button className={styles.btn}&gt;Нажми&lt;/button&gt;;\n}\nСборщик автоматически генерирует уникальные имена классов (например, Button_btn__abc123), гарантируя изоляцию стилей.Чёткое разделение упрощает:\nПоиск нужного файла.\nПонимание ответственности каждой части кода.\nДобавление новых экранов или компонентов без хаоса.\nСовместную работу в команде.\nДаже в небольших проектах полезно сразу придерживаться этой структуры — это экономит время при масштабировании.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Роль папки <code>public</code>","level":2,"id":"Роль_папки_`public`_0"},{"heading":"Роль папки <code>src</code>","level":2,"id":"Роль_папки_`src`_0"},{"heading":"Глобальные и локальные стили","level":2,"id":"Глобальные_и_локальные_стили_0"},{"heading":"Глобальные стили","level":3,"id":"Глобальные_стили_0"},{"heading":"Локальные (компонентные) стили","level":3,"id":"Локальные_(компонентные)_стили_0"},{"heading":"CSS Modules (рекомендуется для изоляции)","level":3,"id":"CSS_Modules_(рекомендуется_для_изоляции)_0"},{"heading":"Зачем такая структура","level":2,"id":"Зачем_такая_структура_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№13/типичная-структура-react-приложения.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760710242056,"modifiedTime":1760710659795,"sourceSize":6373,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №13/Типичная структура React-приложения.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№13/типичная-структура-react-приложения.html","showInTree":true,"treeOrder":129,"backlinks":["лекции/секция-2.-react/тема-№13.-основы-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№13/что-такое-react.html":{"title":"Что такое React","icon":"","description":"React — это библиотека с открытым исходным кодом, созданная компанией Meta (ранее Facebook), для построения пользовательских интерфейсов. Она позволяет разбивать интерфейс на независимые, переиспользуемые части — компоненты — и управлять ими с помощью JavaScript.Основная цель React — сделать разработку UI предсказуемой и эффективной. Вместо того чтобы вручную обновлять DOM при каждом изменении данных, вы описываете, как должен выглядеть интерфейс в зависимости от текущего состояния. React сам определяет, какие части DOM нужно обновить, и делает это минимально необходимым способом.В традиционном императивном подходе (например, с чистым DOM API) вы пишете шаги: «найди элемент», «измени его текст», «добавь класс». В React вы говорите: «вот как должен выглядеть интерфейс при таких данных». Это упрощает рассуждение о коде и снижает количество ошибок.Каждый компонент в React — это изолированная единица интерфейса со своей логикой и внешним видом. Например, кнопка, карточка товара или целая форма могут быть компонентами. Их можно использовать многократно в разных частях приложения, передавая разные данные через пропсы.React использует виртуальный DOM — легковесную копию реального DOM в памяти. При изменении состояния React сначала обновляет виртуальный DOM, сравнивает его с предыдущей версией (процесс называется reconciliation), а затем применяет только те изменения, которые действительно нужны в браузере. Это делает обновления быстрыми и плавными.React не управляет состоянием приложения целиком (в отличие от фреймворков вроде Angular или Vue). Он фокусируется исключительно на слое представления (view layer), что делает его гибким и легко интегрируемым с другими инструментами.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Декларативный подход","level":2,"id":"Декларативный_подход_0"},{"heading":"Переиспользуемые компоненты","level":2,"id":"Переиспользуемые_компоненты_0"},{"heading":"Эффективное обновление DOM","level":2,"id":"Эффективное_обновление_DOM_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№13/что-такое-react.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760709726219,"modifiedTime":1760709729183,"sourceSize":3178,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №13/Что такое React.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№13/что-такое-react.html","showInTree":true,"treeOrder":130,"backlinks":["лекции/секция-2.-react/тема-№13.-основы-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№13/create-react-app-(cra).html":{"title":"Create React App (CRA)","icon":"","description":"Create React App (CRA) — это официальный инструмент от команды React для быстрого старта проекта без необходимости настраивать сборку вручную. Он скрывает всю конфигурацию Webpack, Babel и других инструментов «под капотом», позволяя сразу писать код.Чтобы создать проект с помощью CRA, выполните в терминале:npx create-react-app my-app\nЭта команда:\nСкачивает необходимые зависимости.\nСоздаёт структуру проекта в папке my-app.\nНастраивает скрипты для запуска, сборки и тестирования.\nПосле создания перейдите в папку проекта и запустите сервер разработки:cd my-app\nnpm start\nБраузер автоматически откроет приложение по адресу http://localhost:3000.\nВсё настроено «из коробки»: поддержка JSX, импорт CSS, обработка изображений, линтер.\nПодходит для обучения и небольших проектов.\nНе требует знания Webpack или Babel. Большая и медленная сборка при росте проекта.\nСложно кастомизировать конфигурацию без «eject» (однократной команды, которая раскрывает всю конфигурацию, но делает её необратимой).\nМедленный старт dev-сервера по сравнению с современными альтернативами.\nCRA долгое время был стандартом, но сегодня многие разработчики выбирают более быстрые и гибкие инструменты, такие как Vite.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Создание проекта","level":2,"id":"Создание_проекта_0"},{"heading":"Запуск проекта","level":2,"id":"Запуск_проекта_0"},{"heading":"Особенности CRA","level":2,"id":"Особенности_CRA_0"},{"heading":"Минусы","level":2,"id":"Минусы_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№13/create-react-app-(cra).html","pathToRoot":"../../../..","attachments":[],"createdTime":1760710031446,"modifiedTime":1760710032642,"sourceSize":2231,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №13/Create React App (CRA).md","exportPath":"материалы/подтемы/секция-2.-react/тема-№13/create-react-app-(cra).html","showInTree":true,"treeOrder":131,"backlinks":["материалы/подтемы/секция-2.-react/тема-№13/создание-и-запуск-react-проекта.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№13/jsx.html":{"title":"JSX","icon":"","description":"JSX — это синтаксическое расширение JavaScript, которое позволяет писать HTML-подобный код внутри JavaScript-файлов. Оно используется в React для описания того, как должен выглядеть интерфейс.Хотя JSX выглядит как HTML, на самом деле это синтаксический сахар. Под капотом каждый JSX-элемент преобразуется в вызов функции React.createElement(). Например, запись:const element = &lt;h1&gt;Привет, мир!&lt;/h1&gt;;\nна этапе сборки превращается в:const element = React.createElement('h1', null, 'Привет, мир!');\nЭто позволяет React эффективно создавать и управлять элементами интерфейса.Компонент должен возвращать один корневой элемент. Если нужно вернуть несколько соседних элементов, их следует обернуть в общий тег (например, &lt;div&gt;) или использовать фрагмент:// С фрагментом (рекомендуется, если не нужен лишний div)\nreturn ( &lt;&gt; &lt;h1&gt;Заголовок&lt;/h1&gt; &lt;p&gt;Текст&lt;/p&gt; &lt;/&gt;\n);\nЧтобы вставить значение переменной или результат выражения в JSX, используйте фигурные скобки {}:function Welcome({ name }) { const isLoggedIn = true; return ( &lt;div&gt; &lt;h1&gt;Привет, {name}!&lt;/h1&gt; {isLoggedIn &amp;&amp; &lt;p&gt;Вы вошли в систему.&lt;/p&gt;} &lt;/div&gt; );\n}\nВнутри {} можно использовать любые JavaScript-выражения: переменные, вызовы функций, тернарные операторы. Но нельзя использовать if или for напрямую — для этого нужно выносить логику за пределы JSX.JSX не является обязательным для использования React, но он значительно упрощает чтение и написание компонентов, делая структуру интерфейса визуально похожей на HTML.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Обязательный корневой элемент","level":2,"id":"Обязательный_корневой_элемент_0"},{"heading":"Вставка переменных и выражений","level":2,"id":"Вставка_переменных_и_выражений_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№13/jsx.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760709818801,"modifiedTime":1760709869931,"sourceSize":2631,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №13/JSX.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№13/jsx.html","showInTree":true,"treeOrder":132,"backlinks":["лекции/секция-2.-react/тема-№13.-основы-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№13/vite.html":{"title":"Vite","icon":"","description":"Vite — это современный инструмент сборки, созданный Эваном Ю (автором Vue.js), который использует нативные ES-модули браузера для обеспечения мгновенного старта сервера разработки. Он стал популярной альтернативой Create React App благодаря скорости и простоте.Чтобы создать React-проект с Vite, выполните:npm create vite@latest my-app -- --template react\nЭта команда:\nЗапрашивает имя проекта и шаблон.\nСоздаёт папку my-app с минимальной структурой.\nУстанавливает зависимости для React и Vite.\nПерейдите в папку проекта и запустите сервер:cd my-app\nnpm install\nnpm run dev\nПриложение откроется по адресу, например, http://localhost:5173. Сервер запускается почти мгновенно, даже в крупных проектах.\nИспользует нативные ES-модули: не собирает весь проект при старте, а подгружает файлы по запросу.\nПоддерживает горячую замену модулей (HMR) на уровне отдельных компонентов — изменения отображаются быстрее.\nВключает встроенную поддержку TypeScript, JSX, CSS-модулей и PostCSS без дополнительной настройки.\nПроизводит лёгкую и быструю production-сборку с помощью Rollup. Значительно быстрее запускается и перезагружается.\nМеньше зависимостей и «мёртвого» кода в проекте.\nПроще кастомизировать конфигурацию через файл vite.config.js.\nАктивно развивается и поддерживает современные веб-стандарты.\nVite подходит как для обучения, так и для коммерческой разработки, особенно когда важна скорость и гибкость.\nВ рамках этого курса - для выполнения заданий мы будем использовать Vite\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Создание проекта","level":2,"id":"Создание_проекта_0"},{"heading":"Запуск проекта","level":2,"id":"Запуск_проекта_0"},{"heading":"Особенности Vite","level":2,"id":"Особенности_Vite_0"},{"heading":"Преимущества перед CRA","level":2,"id":"Преимущества_перед_CRA_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№13/vite.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760710094613,"modifiedTime":1760710197285,"sourceSize":2723,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №13/Vite.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№13/vite.html","showInTree":true,"treeOrder":133,"backlinks":["материалы/подтемы/секция-2.-react/тема-№13/создание-и-запуск-react-проекта.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№14/аудио-и-видео.html":{"title":"Аудио и видео","icon":"","description":"Аудио- и видеофайлы (.mp3, .wav, .ogg, .mp4, .webm и др.) в React-приложениях импортируются так же, как изображения: через import. Сборщик (Webpack или Vite) копирует файл в папку сборки, добавляет хеш к имени и возвращает строку с корректным путём, который можно использовать в элементах &lt;audio&gt; и &lt;video&gt;.import clickSound from './assets/sounds/click.mp3';\nimport introVideo from './assets/videos/intro.mp4'; function MediaPlayer() { return ( &lt;&gt; &lt;audio controls src={clickSound} /&gt; &lt;video controls src={introVideo} width=\"640\" /&gt; &lt;/&gt; );\n}\nПеременные clickSound и introVideo содержат абсолютные пути к скомпилированным файлам (например, /static/media/click.a1b2c3.mp3). Это гарантирует, что файлы будут включены в сборку и доступны в продакшене.Запись вида &lt;audio src=\"./assets/sounds/click.mp3\" /&gt; не работает после сборки, потому что:\nСборщик не распознаёт строку как зависимость,\nФайл не копируется в папку dist/ или build/,\nВ браузере возникает ошибка 404.\nТолько импорт через import делает файл частью зависимостей приложения.\nРазмер файлов: аудио и видео часто имеют большой объём. Сборщик может встроить очень маленькие файлы прямо в JavaScript-бандл (base64), но для больших файлов всегда создаётся отдельный ресурс. Уточните настройки assetSizeLimit в конфигурации сборщика, если нужно изменить это поведение.\nФорматы: используйте современные и эффективные форматы: Аудио: .mp3 (широкая поддержка) или .ogg (лучшее сжатие),\nВидео: .mp4 с кодеком H.264 (универсальный) или .webm (лучшее сжатие для веба). Загрузка по требованию: для больших видео рассмотрите ленивую загрузку или размещение на CDN, чтобы не увеличивать размер начальной сборки.\nПуть к файлу: всегда используйте относительные пути при импорте (начинаются с ./ или ../).\nИмпорт через import — единственный надёжный способ подключить медиафайлы, управляемые сборщиком.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Как импортировать аудио или видео","level":2,"id":"Как_импортировать_аудио_или_видео_0"},{"heading":"Почему нельзя использовать строку напрямую","level":2,"id":"Почему_нельзя_использовать_строку_напрямую_0"},{"heading":"Ограничения и рекомендации","level":2,"id":"Ограничения_и_рекомендации_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№14/аудио-и-видео.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760716726228,"modifiedTime":1760716773156,"sourceSize":3273,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/Аудио и видео.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/аудио-и-видео.html","showInTree":true,"treeOrder":135,"backlinks":["материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№14/изображения.html":{"title":"Изображения","icon":"","description":"Изображения — один из самых частых типов ресурсов в веб-приложениях. В React-проектах, собранных с помощью Webpack или Vite, изображения (.png, .jpg, .jpeg, .gif, .webp) можно импортировать напрямую в компоненты. При импорте сборщик копирует файл в папку сборки, добавляет хеш к имени для эффективного кэширования и возвращает строку с корректным путём к изображению.import logo from './assets/logo.png'; function App() { return &lt;img src={logo} alt=\"Логотип\" /&gt;;\n}\nПеременная logo содержит абсолютный путь к скомпилированному файлу (например, /static/media/logo.abcd1234.png). Этот путь безопасно использовать в атрибуте src.Запись вида &lt;img src=\"./assets/logo.png\" /&gt; не работает в продакшене, потому что:\nСборщик не распознаёт строку как зависимость,\nФайл не копируется в папку сборки,\nВ итоге браузер получает путь к несуществующему ресурсу.\nТолько импорт гарантирует, что изображение будет включено в бандл и доступно после сборки.\nХраните изображения в папке src/assets/images/ или подобной — это упрощает навигацию и поддержку.\nИспользуйте относительные пути при импорте (начинаются с ./ или ../).\nДля иконок и простых графических элементов рассмотрите использование SVG как компонента — это даёт больше контроля над стилями.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Как импортировать изображение","level":2,"id":"Как_импортировать_изображение_0"},{"heading":"Почему нельзя использовать строку напрямую","level":2,"id":"Почему_нельзя_использовать_строку_напрямую_0"},{"heading":"Рекомендации","level":2,"id":"Рекомендации_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№14/изображения.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760716226766,"modifiedTime":1760716271183,"sourceSize":2289,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/Изображения.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/изображения.html","showInTree":true,"treeOrder":136,"backlinks":["материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№14/импорт-функций-и-переменных-js.html":{"title":"Импорт функций и переменных JS","icon":"","description":"Импорт функций и переменных из JavaScript-файлов — это основа модульной архитектуры в React. В отличие от статических ресурсов (изображений, шрифтов и т.д.), код импортируется и выполняется как часть приложения, а не как внешний ассет. Это достигается с помощью стандарта ES-модулей, поддерживаемого всеми современными сборщиками.В одном файле (например, utils.js) вы объявляете и экспортируете функции или переменные:// utils.js\nexport const API_URL = 'https://api.example.com';\nexport function formatDate(date) { return date.toLocaleDateString();\n}\nВ компоненте или другом модуле вы импортируете их:import { API_URL, formatDate } from './utils'; function App() { return &lt;div&gt;Адрес API: {API_URL}&lt;/div&gt;;\n} Именованный экспорт (export const x = ...) — позволяет экспортировать несколько значений из одного файла. Импортируется в фигурных скобках. Экспорт по умолчанию (export default function ...) — один экспорт на файл. Импортируется без скобок:\n// logger.js\nexport default function log(message) { console.log('[APP]', message);\n} // App.jsx\nimport log from './logger'; Когда вы импортируете JS-модуль:\nСборщик выполняет код файла (а не просто копирует его),\nЗначения становятся частью JavaScript-бандла,\nНет генерации хешей в именах — модуль встраивается в общий код,\nПоддерживается tree-shaking: неиспользуемые именованные экспорты могут быть удалены из финальной сборки.\nВ отличие от изображений или JSON, вы не получаете строку с путём — вы получаете сами значения (функции, объекты, примитивы).\nВынос логики в утилиты (formatDate, validateEmail),\nЦентрализованное хранение констант (API_URL, THEME_COLORS),\nРазделение компонентов и бизнес-логики,\nСоздание переиспользуемых хуков (useLocalStorage, useDebounce).\nИмпорт JS-модулей — это не «работа с файлами» в смысле ресурсов, а основа структуры кода. Он не требует специальной обработки сборщиком, кроме объединения и оптимизации модулей.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Как экспортировать и импортировать","level":2,"id":"Как_экспортировать_и_импортировать_0"},{"heading":"Виды экспорта","level":2,"id":"Виды_экспорта_0"},{"heading":"Отличие от импорта статических файлов","level":2,"id":"Отличие_от_импорта_статических_файлов_0"},{"heading":"Практическое применение","level":2,"id":"Практическое_применение_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№14/импорт-функций-и-переменных-js.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760717693350,"modifiedTime":1760717699334,"sourceSize":3355,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/Импорт функций и переменных JS.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/импорт-функций-и-переменных-js.html","showInTree":true,"treeOrder":137,"backlinks":["лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№14/как-react-обрабатывает-импорт-файлов.html":{"title":"Как React обрабатывает импорт файлов","icon":"","description":"React не работает напрямую с файлами — он делегирует эту задачу сборщику (Webpack или Vite). Когда вы пишете import logo from './assets/logo.png', сборщик копирует файл в папку сборки (dist/ или build/), переименовывает его, добавляя хеш для кэширования (например, logo.abcd1234.png), и возвращает в переменную logo строку с новым путём, например /static/media/logo.abcd1234.png. Этот путь — уже не относительная ссылка, а абсолютный URL к скомпилированному ресурсу. Именно поэтому использование строк напрямую в атрибутах, как &lt;img src=\"./assets/logo.png\" /&gt;, приводит к проблемам: сборщик не распознаёт такие ссылки как зависимости, не включает файл в бандл, и в продакшене изображение просто не загружается.В режиме разработки многие файлы по относительным путям могут отображаться корректно благодаря встроенному серверу сборщика (Vite или Webpack Dev Server), который динамически разрешает статические ресурсы. Однако при сборке приложения (npm run build) сборщик включает в бандл только те файлы, которые явно импортированы в коде. Если вы используете строку напрямую в атрибуте, например &lt;img src=\"./logo.png\" /&gt;, сборщик не распознаёт эту ссылку как зависимость и не копирует файл в папку сборки. В результате в продакшене изображение не загружается — оно «исчезает».Всегда импортируйте ресурсы, используемые в компонентах:import logo from './assets/logo.png';\n// ...\n&lt;img src={logo} alt=\"Логотип\" /&gt;\nТакой подход гарантирует, что сборщик:\nувидит зависимость,\nскопирует файл в папку сборки,\nпереименует его (обычно с хешем для кэширования),\nподставит корректный путь в переменную logo.\nЭто не только предотвращает «исчезновение» файлов, но и обеспечивает контроль над используемыми ресурсами: неиспользуемые файлы не попадут в финальную сборку, что уменьшает её размер.Хеш в имени файла (например, logo.abcd1234.png) решает проблему кэширования в браузере. Когда файл попадает на сервер, браузер может сохранить его локально, чтобы не загружать повторно при следующем посещении. Если имя файла не меняется, браузер продолжит использовать старую версию даже после обновления контента на сервере. Сборщик генерирует хеш на основе содержимого файла: при любом изменении (даже одного пикселя) хеш меняется, и имя файла становится новым. Это заставляет браузер загрузить обновлённую версию, потому что путь теперь другой. Таким образом, хеширование обеспечивает:\nдолгосрочное кэширование (браузер кэширует файлы на годы, если имя не меняется),\nмгновенное обновление при изменении контента (новое имя → новая загрузка).\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Почему файлы «исчезают» — и как этого избежать","level":2,"id":"Почему_файлы_«исчезают»_—_и_как_этого_избежать_0"},{"heading":"Как избежать проблемы","level":3,"id":"Как_избежать_проблемы_0"},{"heading":"Для чего нужен хеш?","level":3,"id":"Для_чего_нужен_хеш?_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№14/как-react-обрабатывает-импорт-файлов.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760715942964,"modifiedTime":1760716077806,"sourceSize":4605,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/Как React обрабатывает импорт файлов.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/как-react-обрабатывает-импорт-файлов.html","showInTree":true,"treeOrder":138,"backlinks":["лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html":{"title":"Какие файлы можно импортировать","icon":"","description":"React-приложения, собранные с помощью Webpack или Vite, поддерживают импорт различных типов файлов напрямую в JavaScript- или TypeScript-код. Сборщик автоматически обрабатывает такие импорты: копирует файлы в папку сборки, генерирует корректные пути и, при необходимости, преобразует содержимое. Это позволяет работать с ресурсами как с модулями, обеспечивая предсказуемость и контроль над зависимостями.Сборщики по умолчанию распознают и обрабатывают следующие форматы:\nИзображения: .png, .jpg, .jpeg, .gif, .webp SVG: как изображение или как React-компонент Шрифты: .woff, .woff2, .ttf Аудио и видео: .mp3, .wav, .ogg, .mp4, .webm JSON: .json Переменные окружения: .env (не импортируются напрямую, но доступны через process.env)\nКаждый тип имеет свои особенности использования, которые подробно описаны на отдельных подстраницах:\n<a data-href=\"Изображения\" href=\"материалы/подтемы/секция-2.-react/тема-№14/изображения.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Изображения</a> <br><a data-href=\"SVG\" href=\"материалы/подтемы/секция-2.-react/тема-№14/svg.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">SVG</a> <br><a data-href=\"Шрифты\" href=\"материалы/подтемы/секция-2.-react/тема-№14/шрифты.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Шрифты</a> <br><a data-href=\"Аудио и видео\" href=\"материалы/подтемы/секция-2.-react/тема-№14/аудио-и-видео.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Аудио и видео</a> <br><a data-href=\"JSON-файлы\" href=\"материалы/подтемы/секция-2.-react/тема-№14/json-файлы.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">JSON-файлы</a> <br><a data-href=\"env-файлы\" href=\"материалы/подтемы/секция-2.-react/тема-№14/env-файлы.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">env-файлы</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Поддерживаемые типы файлов","level":2,"id":"Поддерживаемые_типы_файлов_0"}],"links":["материалы/подтемы/секция-2.-react/тема-№14/изображения.html","материалы/подтемы/секция-2.-react/тема-№14/svg.html","материалы/подтемы/секция-2.-react/тема-№14/шрифты.html","материалы/подтемы/секция-2.-react/тема-№14/аудио-и-видео.html","материалы/подтемы/секция-2.-react/тема-№14/json-файлы.html","материалы/подтемы/секция-2.-react/тема-№14/env-файлы.html"],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760716156418,"modifiedTime":1760716956296,"sourceSize":1674,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/Какие файлы можно импортировать.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html","showInTree":true,"treeOrder":139,"backlinks":["лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№14/практические-ошибки-и-как-их-избежать.html":{"title":"Практические ошибки и как их избежать","icon":"","description":"При работе с файлами и ресурсами в React-приложениях часто возникают ошибки, связанные с непониманием того, как сборщик (Webpack/Vite) обрабатывает зависимости. Большинство проблем проявляются только в продакшене, что усложняет отладку.Ошибка: &lt;img src=\"./assets/logo.png\" /&gt;\nПочему плохо:\nСборщик не видит зависимость → файл не копируется в сборку → изображение не загружается в продакшене.\nРешение:\nВсегда импортируйте: import logo from './assets/logo.png';\n&lt;img src={logo} /&gt;\nОшибка: &lt;img src={require('./logo.png')} /&gt;\nПочему плохо:\nrequire — часть CommonJS, не поддерживается в Vite и не рекомендуется в современных проектах.\nРешение:\nИспользуйте ES-модули: import logo from './logo.png';.Ошибка:\nКладёте logo.png в public/ и используете &lt;img src=\"/logo.png\" /&gt;.\nПочему плохо: Нет хеширования → кэширование ломается при обновлении,\nСборщик не проверяет наличие файла → опечатка = 404 в продакшене,\nНарушается модульность компонентов.\nРешение:\nИспользуйте public/ только для favicon.ico, robots.txt, manifest.json. Остальное — через импорт из src/.\nОшибка: background: url('assets/bg.jpg');\nПочему плохо:\nПуть не относительный от CSS-файла → сборщик не находит файл.\nРешение:\nВсегда используйте относительные пути: background: url('../assets/images/bg.jpg');\nОшибка: const icon = `./icons/${name}.png`;\n// или\nimport(`./icons/${name}.png`);\nПочему плохо:\nСборщик не может определить, какие файлы нужны → либо ошибка, либо в бандл попадают все файлы из папки.\nРешение:\nИспользуйте маппинг или заранее импортируйте нужные файлы: const icons = { home: require('./icons/home.png'), user: require('./icons/user.png')\n};\n// или с import (в верхнем уровне модуля)\nimport homeIcon from './icons/home.png';\nimport userIcon from './icons/user.png'; Всегда проверяйте сборку: запускайте npm run build и открывайте build/ или dist/ локально.\nНе полагайтесь на поведение dev-сервера: то, что работает в разработке, может сломаться в продакшене.\nИспользуйте IDE-подсказки: если путь в import подсвечивается как ошибка — файл не найден.\nХраните все ресурсы в src/, кроме тех, что явно требуют размещения в public/.\nПонимание границ ответственности сборщика — ключ к стабильной работе с файлами в React.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Типичные ошибки и решения","level":2,"id":"Типичные_ошибки_и_решения_0"},{"heading":"1. Использование строк вместо импорта для ресурсов","level":3,"id":"1._Использование_строк_вместо_импорта_для_ресурсов_0"},{"heading":"2. Попытка использовать require() для изображений","level":3,"id":"2._Попытка_использовать_`require()`_для_изображений_0"},{"heading":"3. Хранение обычных изображений в public/","level":3,"id":"3._Хранение_обычных_изображений_в_`public/`_0"},{"heading":"4. Неправильные пути в CSS (url())","level":3,"id":"4._Неправильные_пути_в_CSS_(`url()`)_0"},{"heading":"5. Динамический импорт ресурсов по переменной","level":3,"id":"5._Динамический_импорт_ресурсов_по_переменной_0"},{"heading":"Как избежать ошибок","level":2,"id":"Как_избежать_ошибок_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№14/практические-ошибки-и-как-их-избежать.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760717715087,"modifiedTime":1760717761341,"sourceSize":4213,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/Практические ошибки и как их избежать.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/практические-ошибки-и-как-их-избежать.html","showInTree":true,"treeOrder":140,"backlinks":["лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№14/работа-со-стилями-и-файлами.html":{"title":"Работа со стилями и файлами","icon":"","description":"Стили в React-приложениях тесно связаны с обработкой файлов: CSS-файлы импортируются как зависимости, а ссылки на ресурсы внутри CSS (например, шрифты или фоновые изображения) также проходят через сборщик. Это обеспечивает целостность проекта — все ресурсы управляются единообразно.Глобальные стили подключаются через импорт в JavaScript:import './styles/global.css';\nСборщик обрабатывает этот файл, включает его в бандл и гарантирует, что стили применятся к приложению. Путь должен быть относительным (начинаться с ./ или ../).Для изоляции стилей компонентов используйте CSS-модули:import styles from './Button.module.css'; function Button() { return &lt;button className={styles.primary}&gt;Клик&lt;/button&gt;;\n}\nИмена классов автоматически хешируются, что предотвращает конфликты. Файл должен иметь расширение .module.css.Шрифты подключаются внутри CSS-файлов с помощью @font-face:/* src/styles/fonts.css */\n@font-face { font-family: 'Inter'; src: url('../assets/fonts/Inter.woff2') format('woff2'); font-weight: 400; font-style: normal; font-display: swap;\n}\nВажно: путь в url() — относительный от CSS-файла к файлу шрифта. Сборщик распознаёт эту ссылку, копирует шрифт в папку сборки и подставляет корректный путь.Аналогично шрифтам, фоновые изображения указываются через url():.header { background-image: url('../assets/images/bg.jpg');\n}\nСборщик обработает путь, скопирует изображение и заменит url() на хешированный путь. Это работает только если CSS импортирован в JavaScript. Если CSS подключён через &lt;link&gt; из public/, сборщик не увидит зависимость — изображение не попадёт в сборку.\nВсе ресурсы, используемые в CSS (url(...)), должны находиться в src/, а не в public/.\nНе подключайте CSS через &lt;link href=\"/styles.css\"&gt; в public/index.html, если этот CSS ссылается на локальные файлы — сборщик их проигнорирует.\nИспользуйте относительные пути в url() — они разрешаются относительно расположения CSS-файла.\nТакой подход обеспечивает, что стили и связанные с ними ресурсы обрабатываются как единая зависимость, что критично для корректной работы в продакшене.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Импорт CSS-файлов","level":2,"id":"Импорт_CSS-файлов_0"},{"heading":"CSS-модули","level":2,"id":"CSS-модули_0"},{"heading":"Подключение шрифтов через CSS","level":2,"id":"Подключение_шрифтов_через_CSS_0"},{"heading":"Фоновые изображения в CSS","level":2,"id":"Фоновые_изображения_в_CSS_0"},{"heading":"Важные правила","level":2,"id":"Важные_правила_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№14/работа-со-стилями-и-файлами.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760717389952,"modifiedTime":1760717432074,"sourceSize":3594,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/Работа со стилями и файлами.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/работа-со-стилями-и-файлами.html","showInTree":true,"treeOrder":141,"backlinks":["лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№14/что-делать-с-файлами-в-папке-public.html":{"title":"Что делать с файлами в папке public","icon":"","description":"Папка public/ — это особое место в React-проекте: файлы в ней копируются в корень сборки без обработки, без хеширования и без анализа зависимостей. Они доступны по корневому пути (/filename.ext) и не проходят через сборщик (Webpack/Vite).Если у вас есть файл public/logo.png, обращайтесь к нему напрямую через корневой путь:&lt;img src=\"/logo.png\" alt=\"Логотип\" /&gt;\nОбратите внимание: путь начинается с /, а не с ./. Это означает, что браузер запросит файл по адресу https://ваш-сайт.com/logo.png.Папка public/ предназначена только для файлов, которые не импортируются в JavaScript-код:\nfavicon.ico — иконка сайта,\nrobots.txt — инструкции для поисковых роботов,\nmanifest.json — метаданные для PWA,\nsitemap.xml — карта сайта,\nСтатические файлы, доступные по прямой ссылке (например, public/docs/instruction.pdf).\nЭти файлы должны быть доступны по фиксированному пути и не зависят от логики приложения.Не кладите в public/ изображения, шрифты, аудио или другие ресурсы, используемые в компонентах. Причины:\nСборщик не знает, что они нужны — не проверяет наличие, не удаляет неиспользуемые,\nНет хеширования → браузер может кэшировать старую версию навсегда,\nНарушается модульность: компонент зависит от глобального состояния файловой системы,\nПри переименовании файла — ошибка обнаружится только вручную, не на этапе сборки.\nНапример, &lt;img src=\"/assets/logo.png\" /&gt; с файлом в public/assets/logo.png — плохая практика. Правильно: импортировать из src/assets/.Задайте себе вопрос: «Будет ли этот файл запрашиваться напрямую по URL, без участия React-кода?»\nЕсли да — кладите в public/.\nЕсли нет — импортируйте из src/.Использование public/ должно быть исключением, а не правилом.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Как использовать файлы из public/","level":2,"id":"Как_использовать_файлы_из_public/_0"},{"heading":"Когда использовать public/","level":2,"id":"Когда_использовать_public/_0"},{"heading":"Когда НЕ использовать public/","level":2,"id":"Когда_НЕ_использовать_public/_0"},{"heading":"Как проверить, нужен ли файл в public/","level":2,"id":"Как_проверить,_нужен_ли_файл_в_public/_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№14/что-делать-с-файлами-в-папке-public.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760717254105,"modifiedTime":1760717310892,"sourceSize":3122,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/Что делать с файлами в папке public.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/что-делать-с-файлами-в-папке-public.html","showInTree":true,"treeOrder":142,"backlinks":["лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№14/шрифты.html":{"title":"Шрифты","icon":"","description":"Шрифты в React-приложениях подключаются не напрямую в компонентах, а через CSS-файлы с использованием правила @font-face. Это стандартный веб-подход, который корректно интегрируется со сборщиками (Webpack, Vite): при импорте CSS-файла сборщик обнаруживает ссылки на шрифты, копирует их в папку сборки и подставляет правильные пути.\nПоместите файл шрифта в папку проекта, например src/assets/fonts/Inter.woff2.\nСоздайте CSS-файл (например, src/styles/fonts.css) и опишите шрифт:\n@font-face { font-family: 'Inter'; src: url('../assets/fonts/Inter.woff2') format('woff2'); font-weight: 400; font-style: normal; font-display: swap;\n} Важно: путь в url() должен быть относительным от CSS-файла к файлу шрифта.\nИмпортируйте CSS в корневой компонент или точку входа:\nimport './styles/fonts.css'; Теперь шрифт зарегистрирован, и его можно использовать в любых стилях.\nСборщики по умолчанию обрабатывают:\n.woff2 — современный, сжатый формат (рекомендуется как основной),\n.woff — более старый, но широко поддерживаемый,\n.ttf — TrueType, используется редко из-за большого размера.\nИспользуйте .woff2 как основной формат. Для максимальной совместимости можно указать несколько источников:@font-face { font-family: 'MyFont'; src: url('../fonts/MyFont.woff2') format('woff2'), url('../fonts/MyFont.woff') format('woff'); font-weight: normal; font-style: normal;\n}\nВ отличие от изображений, шрифты не используются как значения в JSX. Они применяются через CSS, поэтому импорт в JavaScript (import font from './font.woff2') бесполезен — вы получите строку с путём, но не сможете зарегистрировать шрифт в браузере. Единственный корректный способ — через @font-face в CSS.\nВсегда указывайте font-display: swap; — это улучшает показатели Core Web Vitals, позволяя тексту отображаться сразу с резервным шрифтом, а затем подгружать кастомный.\nХраните шрифты в src/assets/fonts/, чтобы они обрабатывались сборщиком и попадали в бандл.\nНе кладите шрифты в public/, если только они не подключаются через CDN или не используются вне сборки (например, в email-шаблонах).\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Как подключить шрифт","level":2,"id":"Как_подключить_шрифт_0"},{"heading":"Поддерживаемые форматы","level":2,"id":"Поддерживаемые_форматы_0"},{"heading":"Почему нельзя импортировать шрифт напрямую в JS","level":2,"id":"Почему_нельзя_импортировать_шрифт_напрямую_в_JS_0"},{"heading":"Рекомендации","level":2,"id":"Рекомендации_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№14/шрифты.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760716484736,"modifiedTime":1760716590288,"sourceSize":3588,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/Шрифты.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/шрифты.html","showInTree":true,"treeOrder":143,"backlinks":["материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№14/env-файлы.html":{"title":"env-файлы","icon":"","description":".env-файлы в React-приложениях не импортируются напрямую, как обычные модули. Вместо этого они обрабатываются сборщиком (Webpack в Create React App, Vite в Vite-проектах) на этапе сборки, и их содержимое становится доступно через глобальную переменную process.env.Создайте файл .env в корне проекта (рядом с package.json):REACT_APP_API_URL=https://api.example.com\nREACT_APP_VERSION=1.2.0\nВажно: В Create React App переменные должны начинаться с REACT_APP_. В Vite — с VITE_ (или VITE_SOME_VAR), а в коде доступны как import.meta.env.VITE_SOME_VAR.\nПример для CRA:// .env\nREACT_APP_API_URL=https://api.example.com\n// Компонент\nfunction App() { console.log(process.env.REACT_APP_API_URL); // \"https://api.example.com\" return null;\n}\nПример для Vite:# .env\nVITE_API_URL=https://api.example.com\n// Компонент\nfunction App() { console.log(import.meta.env.VITE_API_URL); // \"https://api.example.com\" return null;\n}\nФайл .env никогда не попадает в клиентский бандл. Сборщик читает его на этапе сборки, подставляет значения переменных в код (инлайнит их как строки), а сам файл игнорирует. Это сделано специально:\nЧтобы избежать утечки чувствительных данных (хотя на клиенте всё равно видно),\nЧтобы обеспечить статическую замену значений, что позволяет оптимизировать код.\nПопытка написать import env from './.env' приведёт к ошибке — сборщик не обрабатывает .env как ресурс.Сборщики поддерживают разные файлы в зависимости от режима:\n.env — общие значения для всех режимов,\n.env.local — локальные переопределения (игнорируются в Git),\n.env.development, .env.production — значения для конкретных режимов.\nПриоритет: .env.local &gt; .env.development.local &gt; .env.development &gt; .env.\nНикаких секретов: всё, что попадает в process.env или import.meta.env, будет видно в браузере. Используйте .env только для публичных данных (URL API, флаги функций, версии).\nТолько строки: значения всегда интерпретируются как строки. Для чисел или булевых значений преобразуйте вручную: const timeout = Number(process.env.REACT_APP_TIMEOUT).\nПеременные должны быть объявлены явно: динамический доступ вроде process.env[variableName] не работает — сборщик не может определить, какие переменные нужны.\n.env-файлы — удобный способ управлять конфигурацией между средами, но помните: они предназначены только для публичных, несекретных данных.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Как работают .env-файлы","level":2,"id":"Как_работают_.env-файлы_0"},{"heading":"Почему нельзя импортировать .env как файл","level":2,"id":"Почему_нельзя_импортировать_.env_как_файл_0"},{"heading":"Поддерживаемые файлы окружения","level":2,"id":"Поддерживаемые_файлы_окружения_0"},{"heading":"Важные ограничения","level":2,"id":"Важные_ограничения_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№14/env-файлы.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760716959344,"modifiedTime":1760717173411,"sourceSize":3941,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/env-файлы.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/env-файлы.html","showInTree":true,"treeOrder":144,"backlinks":["материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№14/json-файлы.html":{"title":"JSON-файлы","icon":"","description":"JSON-файлы в React-приложениях можно импортировать напрямую, как обычные JavaScript-модули. Сборщики (Webpack и Vite) по умолчанию поддерживают такой импорт: содержимое JSON автоматически парсится и становится доступным как обычный объект или массив в коде.Предположим, у вас есть файл src/config/settings.json:{ \"apiUrl\": \"https://api.example.com\", \"features\": [\"darkMode\", \"notifications\"], \"version\": \"1.2.0\"\n}\nВы можете импортировать его в компоненте или модуле:import settings from './config/settings.json'; function App() { console.log(settings.apiUrl); // \"https://api.example.com\" return &lt;div&gt;Версия: {settings.version}&lt;/div&gt;;\n}\nПеременная settings — это уже готовый JavaScript-объект, не строка. Никакого дополнительного парсинга (JSON.parse) не требуется.\nТипобезопасность: при использовании TypeScript типы можно автоматически выводить или задавать через декларации.\nСтатический анализ: сборщик видит зависимость, и если файл удалён или переименован, вы получите ошибку на этапе сборки.\nTree-shaking: если вы используете только часть данных, современные сборщики могут исключить неиспользуемые поля (в ограниченных случаях).\nКэширование и хеширование: как и другие ресурсы, JSON-файлы получают хеш в имени при сборке, что обеспечивает корректное кэширование. Конфигурации, которые известны на этапе сборки (не секреты!),\nСтатические данные: списки, переводы, моки для разработки,\nМетаданные компонентов или страниц. Не храните секреты (API-ключи, пароли) в JSON-файлах — они попадут в клиентский бандл и будут видны любому.\nДинамические данные (например, ответы от сервера) должны загружаться через fetch, а не через импорт.\nПуть при импорте должен быть статическим: import data from ./data/${name}.json`` не сработает, так как сборщик не может определить имя файла во время сборки.\nИмпорт JSON — простой и надёжный способ включить структурированные статические данные в ваше React-приложение.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Как импортировать JSON","level":2,"id":"Как_импортировать_JSON_0"},{"heading":"Преимущества импорта JSON","level":2,"id":"Преимущества_импорта_JSON_0"},{"heading":"Когда использовать","level":2,"id":"Когда_использовать_0"},{"heading":"Важные ограничения","level":2,"id":"Важные_ограничения_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№14/json-файлы.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760716799753,"modifiedTime":1760716873170,"sourceSize":3373,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/JSON-файлы.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/json-файлы.html","showInTree":true,"treeOrder":145,"backlinks":["материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№14/svg.html":{"title":"SVG","icon":"","description":"SVG — масштабируемый векторный формат, особенно удобный в React благодаря двум способам импорта: как изображение и как React-компонент. Это даёт гибкость: можно либо просто вставить картинку, либо управлять её содержимым программно.Если вам нужно просто отобразить SVG-файл без изменения его содержимого:import logo from './logo.svg'; function App() { return &lt;img src={logo} alt=\"Логотип\" /&gt;;\n}\nСборщик обрабатывает файл как обычное изображение: копирует в папку сборки, добавляет хеш и возвращает путь. Такой подход подходит для сложных SVG или когда не требуется стилизация.Для простых иконок или логотипов, которые нужно стилизовать (менять цвет, размер, анимировать), используйте специальный синтаксис:import { ReactComponent as Logo } from './logo.svg'; function App() { return &lt;Logo fill=\"blue\" width=\"100\" height=\"40\" /&gt;;\n}\nЗдесь ReactComponent — это зарезервированное имя, распознаваемое сборщиком. В результате Logo становится полноценным React-компонентом, встроенным в JSX. Это позволяет:\nМенять цвет через fill или stroke,\nУправлять размерами через пропсы,\nПрименять CSS-классы или инлайновые стили,\nАнимировать отдельные части через JavaScript. Как изображение: сложные SVG, внешние логотипы, когда не нужна интерактивность.\nКак компонент: иконки, простые графические элементы, где важна гибкость стилей и интеграция с React-состоянием.\nВ большинстве современных шаблонов (Create React App, Vite с @vitejs/plugin-react) поддержка импорта SVG как компонента включена по умолчанию. Однако если вы настраиваете сборку вручную, потребуется соответствующий лоадер или плагин: Webpack: используется @svgr/webpack. В конфигурации нужно добавить правило:\n{ test: /\\.svg$/, use: ['@svgr/webpack', 'url-loader']\n} Порядок важен: @svgr/webpack обрабатывает импорт с ReactComponent, а url-loader — обычные импорты. Vite: достаточно установить vite-plugin-svgr:\nnpm install -D vite-plugin-svgr И подключить в vite.config.js:\nimport svgr from 'vite-plugin-svgr'; export default { plugins: [svgr()]\n}; После этого синтаксис import { ReactComponent as Icon } from './icon.svg' будет работать корректно. Без такой настройки попытка импорта как компонента вызовет ошибку: сборщик не распознает ReactComponent и вернёт только строку с путём.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Импорт SVG как изображения","level":2,"id":"Импорт_SVG_как_изображения_0"},{"heading":"Импорт SVG как React-компонента","level":2,"id":"Импорт_SVG_как_React-компонента_0"},{"heading":"Когда что использовать","level":2,"id":"Когда_что_использовать_0"},{"heading":"Как выглядит настройка","level":2,"id":"Как_выглядит_настройка_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№14/svg.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760716272890,"modifiedTime":1760716440205,"sourceSize":3914,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/SVG.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/svg.html","showInTree":true,"treeOrder":146,"backlinks":["материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№15/передача-данных-через-props.html":{"title":"Передача данных через props","icon":"","description":"Передача данных через props — основной механизм обмена информацией между компонентами в React. Все данные передаются строго сверху вниз: от родительского компонента к дочернему. Это обеспечивает предсказуемость и упрощает отладку, так как источник данных всегда можно проследить по иерархии компонентов.Props (сокращение от «properties») — это аргументы, которые передаются в функциональный компонент, как параметры в обычную функцию. Они могут содержать любые типы данных: строки, числа, булевы значения, массивы, объекты, а также функции.В JSX props указываются как атрибуты:&lt;UserCard name=\"Алиса\" age={30} /&gt;\nВнутри компонента они доступны через параметр функции:function UserCard(props) { return &lt;div&gt;{props.name}, {props.age} лет&lt;/div&gt;;\n}\nЧасто используется деструктуризация для удобства:function UserCard({ name, age }) { return &lt;div&gt;{name}, {age} лет&lt;/div&gt;;\n}\nОдна из ключевых практик — передача колбэков из родителя в дочерний компонент. Это позволяет дочернему компоненту запрашивать изменения состояния, не владея им напрямую.Пример:// Родитель\nfunction App() { const [count, setCount] = useState(0); return &lt;CounterButton onIncrement={() =&gt; setCount(count + 1)} /&gt;;\n} // Дочерний\nfunction CounterButton({ onIncrement }) { return &lt;button onClick={onIncrement}&gt;+1&lt;/button&gt;;\n}\nТакой подход сохраняет единственный источник истины (single source of truth) и избегает прямого мутирования данных.Работа с props в React подчиняется строгим правилам, которые обеспечивают предсказуемость, читаемость и стабильность компонентного дерева. Эти правила — основа архитектуры React и помогают избежать распространённых ошибок.Дочерний компонент никогда не должен мутировать полученные props. Любая попытка присвоить значение напрямую (props.value = newValue) нарушает иммутабельность и может привести к неожиданному поведению. Если компоненту нужно «изменить» данные, он должен вызвать переданную функцию-колбэк, а не трогать props.Данные в React текут строго от родителя к дочернему компоненту. Нельзя «подтянуть» данные снизу вверх без явного механизма (например, колбэка). Это упрощает отладку: чтобы понять, откуда пришло значение, достаточно подняться по иерархии компонентов.Когда дочернему компоненту требуется инициировать изменение состояния, родитель должен передать функцию через props. Дочерний компонент вызывает её, но не управляет самим состоянием. Это сохраняет единый источник истины и изолирует логику управления данными.Передавайте только те данные, которые действительно нужны компоненту. Не передавайте весь объект состояния, если используется лишь одно поле. Это улучшает переиспользуемость, упрощает тестирование и снижает риск ненужных ререндеров.Чёткое определение ожидаемых props помогает другим разработчикам (и вам в будущем) понимать интерфейс компонента. В JavaScript это можно делать через JSDoc, в TypeScript — через интерфейсы или типы.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Что такое props","level":2,"id":"Что_такое_props_0"},{"heading":"<a data-href=\"Передача функций как props\" href=\"Передача функций как props\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">Передача функций как props</a>","level":2,"id":"[[Передача_функций_как_props]]_0"},{"heading":"Правила работы с props","level":2,"id":"Правила_работы_с_props_0"},{"heading":"Props — только для чтения","level":3,"id":"Props_—_только_для_чтения_0"},{"heading":"Передача данных — только сверху вниз","level":3,"id":"Передача_данных_—_только_сверху_вниз_0"},{"heading":"Если нужно изменить данные — передайте функцию","level":3,"id":"Если_нужно_изменить_данные_—_передайте_функцию_0"},{"heading":"Избегайте избыточных или «мусорных» props","level":3,"id":"Избегайте_избыточных_или_«мусорных»_props_0"},{"heading":"Типизируйте props (в TypeScript) или документируйте (в JS)","level":3,"id":"Типизируйте_props_(в_TypeScript)_или_документируйте_(в_JS)_0"}],"links":["материалы/подтемы/секция-2.-react/тема-№15/передача-функций-как-props.html"],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№15/передача-данных-через-props.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760711801410,"modifiedTime":1760712208973,"sourceSize":5424,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №15/Передача данных через props.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№15/передача-данных-через-props.html","showInTree":true,"treeOrder":148,"backlinks":["лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№15/передача-функций-как-props.html":{"title":"Передача функций как props","icon":"","description":"Передача функций через props — ключевой паттерн в React для обеспечения взаимодействия между компонентами при сохранении одностороннего потока данных. Поскольку дочерние компоненты не могут напрямую изменять состояние родителя, они вызывают переданные функции-колбэки, чтобы запросить изменение.Родительский компонент определяет функцию (обычно с использованием useState или других хуков) и передаёт её как prop:function Parent() { const [isVisible, setIsVisible] = useState(false); return ( &lt;TogglePanel onToggle={() =&gt; setIsVisible(!isVisible)} /&gt; );\n}\nДочерний компонент получает эту функцию и вызывает её в ответ на событие:function TogglePanel({ onToggle }) { return &lt;button onClick={onToggle}&gt;Переключить&lt;/button&gt;;\n}\nТакой подход сохраняет единственный источник истины: состояние остаётся в том компоненте, которому оно принадлежит. Дочерний компонент лишь сигнализирует о намерении изменить данные, не зная и не контролируя их внутреннюю структуру. Это делает компоненты более переиспользуемыми и тестируемыми.Функции-props могут принимать аргументы, что особенно полезно в списках или формах:function TodoList({ todos, onDelete }) { return ( &lt;ul&gt; {todos.map(todo =&gt; ( &lt;li key={todo.id}&gt; {todo.text} &lt;button onClick={() =&gt; onDelete(todo.id)}&gt;Удалить&lt;/button&gt; &lt;/li&gt; ))} &lt;/ul&gt; );\n} // В родителе\n&lt;TodoList todos={todos} onDelete={(id) =&gt; setTodos(todos.filter(t =&gt; t.id !== id))} /&gt;\nЗдесь стрелочная функция () =&gt; onDelete(todo.id) оборачивает вызов, чтобы передать конкретный id.При каждом рендере родителя передаваемая функция создаётся заново, что может вызывать ненужные ререндеры дочерних компонентов. Для оптимизации используют useCallback:const handleToggle = useCallback(() =&gt; setIsVisible(v =&gt; !v), []);\nreturn &lt;TogglePanel onToggle={handleToggle} /&gt;;\nЭто особенно актуально при использовании React.memo или в производительных сценариях.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Как передать функцию в дочерний компонент","level":2,"id":"Как_передать_функцию_в_дочерний_компонент_0"},{"heading":"Почему это важно","level":2,"id":"Почему_это_важно_0"},{"heading":"Передача параметров в колбэк","level":2,"id":"Передача_параметров_в_колбэк_0"},{"heading":"Оптимизация: избегание лишних пересозданий","level":2,"id":"Оптимизация_избегание_лишних_пересозданий_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№15/передача-функций-как-props.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760712091580,"modifiedTime":1760712094340,"sourceSize":3260,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №15/Передача функций как props.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№15/передача-функций-как-props.html","showInTree":true,"treeOrder":149,"backlinks":["материалы/подтемы/секция-2.-react/тема-№15/передача-данных-через-props.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№15/состояние-и-хук-usestate.html":{"title":"Состояние и хук useState","icon":"","description":"Состояние в React — это данные, которые могут меняться со временем и напрямую влияют на то, как компонент отображается в интерфейсе. В отличие от обычных переменных, состояние «живёт» внутри компонента и сохраняется между рендерами. React отслеживает изменения состояния и автоматически обновляет DOM при его изменении, что лежит в основе интерактивности веб-приложений.Состояние позволяет компоненту реагировать на действия пользователя (например, клики, ввод текста), получать данные с сервера или изменять внешний вид в зависимости от условий. Без состояния компоненты были бы статичными — как обычный HTML.Важно помнить: состояние локально для конкретного компонента. Оно не сохраняется после перезагрузки страницы или перезапуска приложения — для долговременного хранения требуются дополнительные механизмы, такие как localStorage.Хук useState — основной способ добавления состояния в функциональные компоненты. Его синтаксис:const [state, setState] = useState(initialValue);\nЗдесь state — текущее значение состояния, а setState — функция для его обновления. Начальное значение (initialValue) может быть любого типа: строка, число, булево значение, массив, объект и даже null.Примеры инициализации:\nuseState(false) — для переключателей (например, темный режим)\nuseState('') — для текстовых полей\nuseState([]) — для списков\nuseState({ name: '', age: 0 }) — для объектов\nСостояние в React обновляется только через функцию-сеттер (setState). Прямое присваивание (state = newValue) не сработает — React не узнает об изменении.Есть два способа обновления:\nПрямое: setState(newValue) — когда новое значение не зависит от предыдущего.\nФункциональное: setState(prev =&gt; prev + 1) — когда новое значение зависит от текущего. Это особенно важно при частых или асинхронных обновлениях.\nReact полагается на иммутабельность: вы не должны мутировать существующие объекты или массивы. Вместо этого создаёте новую копию с изменениями.Неправильно:user.name = 'Алиса';\nsetUser(user);\nПравильно:setUser({ ...user, name: 'Алиса' });\nДля массивов:setItems([...items, newItem]); // добавление\nsetItems(items.filter(item =&gt; item.id !== id)); // удаление\nЭто гарантирует, что React корректно определит, изменились ли данные, и выполнит повторный рендер.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Что такое состояние и зачем оно нужно","level":2,"id":"Что_такое_состояние_и_зачем_оно_нужно_0"},{"heading":"Хук useState: синтаксис и инициализация","level":2,"id":"Хук_useState_синтаксис_и_инициализация_0"},{"heading":"Обновление состояния","level":2,"id":"Обновление_состояния_0"},{"heading":"Иммутабельность состояния","level":2,"id":"Иммутабельность_состояния_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№15/состояние-и-хук-usestate.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760711686137,"modifiedTime":1760711690530,"sourceSize":4112,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №15/Состояние и хук useState.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№15/состояние-и-хук-usestate.html","showInTree":true,"treeOrder":150,"backlinks":["лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№15/хранение-данных-между-сессиями.html":{"title":"Хранение данных между сессиями","icon":"","description":"Данные, хранящиеся в состоянии React-компонентов с помощью useState, теряются при перезагрузке страницы или перезапуске приложения. Чтобы сохранить информацию между сессиями — например, настройки пользователя, тему интерфейса или недозаполненную форму — необходимо использовать механизмы клиентского хранения данных.В вебе для этого доступны три основных инструмента:\n<a data-href=\"localStorage и sessionStorage\" href=\"материалы/подтемы/секция-2.-react/тема-№15/localstorage-и-sessionstorage.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">localStorage и sessionStorage</a> <br><a data-href=\"Cookies в React-приложениях\" href=\"материалы/подтемы/секция-2.-react/тема-№15/cookies-в-react-приложениях.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Cookies в React-приложениях</a>\nКаждый из них имеет своё назначение, ограничения и сценарии применения.\nlocalStorage — для всех клиентских данных, которые должны сохраняться между перезагрузками: настройки UI, кэш, offline-данные.\nsessionStorage — для временных данных в рамках одной вкладки.\nCookies — только если сервер требует их для аутентификации или сессионного управления. Не используйте cookies для хранения сложных клиентских состояний.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Когда что использовать","level":2,"id":"Когда_что_использовать_0"}],"links":["материалы/подтемы/секция-2.-react/тема-№15/localstorage-и-sessionstorage.html","материалы/подтемы/секция-2.-react/тема-№15/cookies-в-react-приложениях.html"],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№15/хранение-данных-между-сессиями.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760712229057,"modifiedTime":1760712502248,"sourceSize":1552,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №15/Хранение данных между сессиями.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№15/хранение-данных-между-сессиями.html","showInTree":true,"treeOrder":151,"backlinks":["лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№15/cookies-в-react-приложениях.html":{"title":"Cookies в React-приложениях","icon":"","description":"Cookies — это небольшие текстовые данные, хранящиеся в браузере и автоматически отправляемые на сервер с каждым HTTP-запросом к тому же домену. В React-приложениях они используются в первую очередь для аутентификации и сессионного управления, а не для хранения клиентского состояния.Когда сервер отвечает на запрос, он может установить cookie через заголовок Set-Cookie. Браузер сохраняет её и при последующих запросах к тому же домену автоматически добавляет в заголовок Cookie. Это позволяет серверу идентифицировать пользователя без передачи токена вручную.Пример:Set-Cookie: sessionId=abc123; Path=/; HttpOnly; Secure Размер: максимум 4 КБ на cookie.\nКоличество: обычно не более 50 cookies на домен.\nПроизводительность: каждая cookie отправляется со всеми запросами к домену, даже для изображений или статики — это увеличивает объём трафика.\nДоступ из JavaScript: если cookie помечена как HttpOnly, она недоступна через document.cookie — это мера защиты от XSS.\nЧтение и запись через JavaScript возможна только для не-HttpOnly cookies:// Чтение\nconst cookies = document.cookie; // строка вида \"key1=value1; key2=value2\" // Запись\ndocument.cookie = \"theme=dark; path=/\";\nОднако синтаксис неудобен: нет встроенного парсера или метода удаления. В рамках курса мы не будем использовать сторонние библиотеки (например js-cookie), поэтому вот пример кастомного хука для удобной работы с cookies:function useCookie(key, defaultValue = '') { // Чтение при монтировании const [cookie, setCookie] = useState(() =&gt; { const match = document.cookie .split('; ') .find(row =&gt; row.startsWith(key + '=')); return match ? decodeURIComponent(match.split('=')[1]) : defaultValue; }); // Функция для записи const updateCookie = (value, days = 7) =&gt; { const expires = new Date(Date.now() + days * 864e5).toUTCString(); document.cookie = `${key}=${encodeURIComponent(value)}; expires=${expires}; path=/`; setCookie(value); }; // Функция для удаления const deleteCookie = () =&gt; { document.cookie = `${key}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/`; setCookie(defaultValue); }; return [cookie, updateCookie, deleteCookie];\n}\nЭтот хук позволяет работать с cookie как с реактивным состоянием:const [theme, setTheme] = useCookie('theme', 'light');\n// ...\nsetTheme('dark'); // сохранит в cookie и обновит состояние Аутентификация через сессии: сервер выдаёт сессионный ID, сохраняет его в HttpOnly cookie — клиент не видит токен, но запросы аутентифицируются автоматически.\nМеждоменные сценарии: если API и фронтенд на разных поддоменах, cookies с флагом Domain могут быть общими.\nСовместимость с legacy-системами, где аутентификация завязана на cookies. Для хранения настроек UI, кэша или состояния приложения — используйте localStorage.\nДля данных, не нужных серверу — зачем отправлять их с каждым запросом?\nДля сложных структур — cookies работают только со строками и требуют ручной сериализации.\nВ большинстве современных React-приложений cookies используются только для аутентификации, управляемой сервером, а всё остальное хранится в localStorage или в состоянии приложения.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Как работают cookies","level":2,"id":"Как_работают_cookies_0"},{"heading":"Ограничения cookies","level":2,"id":"Ограничения_cookies_0"},{"heading":"Работа с cookies в React","level":2,"id":"Работа_с_cookies_в_React_0"},{"heading":"Когда использовать cookies в React","level":2,"id":"Когда_использовать_cookies_в_React_0"},{"heading":"Когда НЕ использовать","level":2,"id":"Когда_НЕ_использовать_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№15/cookies-в-react-приложениях.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760712863307,"modifiedTime":1760713114388,"sourceSize":5053,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №15/Cookies в React-приложениях.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№15/cookies-в-react-приложениях.html","showInTree":true,"treeOrder":152,"backlinks":["материалы/подтемы/секция-2.-react/тема-№15/хранение-данных-между-сессиями.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№15/localstorage-и-sessionstorage.html":{"title":"localStorage и sessionStorage","icon":"","description":"localStorage и sessionStorage — это встроенные в браузер механизмы для хранения данных на стороне клиента. Оба предоставляют простой API для сохранения пар «ключ-значение», но отличаются по времени жизни и области видимости.localStorage сохраняет данные бессрочно — они остаются даже после закрытия браузера и перезагрузки компьютера. Это делает его идеальным для:\nСохранения пользовательских настроек (тема, язык, размер шрифта)\nКэширования данных API для ускорения загрузки\nХранения состояния форм между визитами\nОсновные методы:\nlocalStorage.setItem(key, value) — сохраняет строку\nlocalStorage.getItem(key) — возвращает строку или null\nlocalStorage.removeItem(key) — удаляет запись\nlocalStorage.clear() — очищает всё хранилище\nВажно: localStorage хранит только строки. Для объектов и массивов используйте сериализацию:// Сохранение\nlocalStorage.setItem('user', JSON.stringify({ name: 'Алиса' })); // Загрузка\nconst user = JSON.parse(localStorage.getItem('user') || '{}');\nsessionStorage работает так же, как localStorage, но данные удаляются при закрытии вкладки (не браузера целиком). Это полезно для:\nВосстановления формы после обновления страницы\nХранения временных данных, не нужных после ухода с сайта\nAPI идентичен:sessionStorage.setItem('draft', text);\nconst draft = sessionStorage.getItem('draft');\nЧасто localStorage интегрируют с useState:function useLocalStorage(key, initialValue) { const [value, setValue] = useState(() =&gt; { const stored = localStorage.getItem(key); return stored ? JSON.parse(stored) : initialValue; }); useEffect(() =&gt; { localStorage.setItem(key, JSON.stringify(value)); }, [key, value]); return [value, setValue];\n}\nТакой кастомный хук позволяет работать с локальным хранилищем как с обычным состоянием.\nМаксимум ~5–10 МБ (зависит от браузера)\nДоступ только в том же origin (протокол + домен + порт)\nНе отправляются на сервер автоматически (в отличие от cookies)\nДанные видны пользователю — никогда не храните секреты (пароли, токены доступа)\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"localStorage: долговременное хранение","level":2,"id":"localStorage_долговременное_хранение_0"},{"heading":"sessionStorage: хранение на время сессии","level":2,"id":"sessionStorage_хранение_на_время_сессии_0"},{"heading":"Использование с React","level":2,"id":"Использование_с_React_0"},{"heading":"Ограничения","level":2,"id":"Ограничения_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№15/localstorage-и-sessionstorage.html","pathToRoot":"../../../..","attachments":[],"createdTime":1760712584579,"modifiedTime":1760712594311,"sourceSize":3333,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №15/localStorage и sessionStorage.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№15/localstorage-и-sessionstorage.html","showInTree":true,"treeOrder":153,"backlinks":["материалы/подтемы/секция-2.-react/тема-№15/хранение-данных-между-сессиями.html"],"type":"markdown"},"лекции/секция-2.-react/тема-№16.-события-и-ref-в-react.html":{"title":"Тема №16. События и Ref в React","icon":"","description":"В этой теме вы изучите обработку пользовательских событий и работу с референсами в React — ключевые механизмы для взаимодействия с DOM-элементами и управления состоянием, которое не требует перерисовки интерфейса. Поймёте, как реагировать на действия пользователя (клики, ввод, фокус) и когда использовать ref вместо состояния для доступа к элементам или их значениям.\n<a data-href=\"Обработка событий в React\" href=\"материалы/подтемы/секция-2.-react/тема-№16/обработка-событий-в-react.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Обработка событий в React</a>\n<br><a data-href=\"Что такое Ref\" href=\"материалы/подтемы/секция-2.-react/тема-№16/что-такое-ref.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Что такое Ref</a>\n<br><a data-href=\"Работа с формами\" href=\"материалы/подтемы/секция-2.-react/тема-№16/работа-с-формами.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Работа с формами</a> <br><a data-href=\"Практика №10. Интерактивный счётчик с изменением темы\" href=\"задания/секция-2.-react/практика-№10.-интерактивный-счётчик-с-изменением-темы.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Практика №10. Интерактивный счётчик с изменением темы</a>\n<br><a data-href=\"Тема №17. Hooks в React\" href=\"лекции/секция-2.-react/тема-№17.-hooks-в-react.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №17. Hooks в React</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-2.-react/тема-№16/обработка-событий-в-react.html","материалы/подтемы/секция-2.-react/тема-№16/что-такое-ref.html","материалы/подтемы/секция-2.-react/тема-№16/работа-с-формами.html","задания/секция-2.-react/практика-№10.-интерактивный-счётчик-с-изменением-темы.html","лекции/секция-2.-react/тема-№17.-hooks-в-react.html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-2.-react/тема-№16.-события-и-ref-в-react.html","pathToRoot":"../..","attachments":[],"createdTime":1768641559295,"modifiedTime":1768934439265,"sourceSize":1070,"sourcePath":"Лекции/Секция 2. React/Тема №16. События и Ref в React.md","exportPath":"лекции/секция-2.-react/тема-№16.-события-и-ref-в-react.html","showInTree":true,"treeOrder":31,"backlinks":["лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html"],"type":"markdown"},"лекции/секция-2.-react/тема-№17.-hooks-в-react.html":{"title":"Тема №17. Hooks в React","icon":"","description":"В этой теме вы изучите Hooks — функции, позволяющие использовать состояние и другие возможности React в функциональных компонентах. Поймёте, как работают основные встроенные хуки, когда и зачем их применять, а также принципы их использования: правила вызова, зависимостей и побочных эффектов. Это фундамент для написания чистого, переиспользуемого и эффективного кода в React-приложениях.\n<a data-href=\"Что такое Hooks\" href=\"материалы/подтемы/секция-2.-react/тема-№17/что-такое-hooks.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Что такое Hooks</a>\n<br><a data-href=\"Правила использования Hooks\" href=\"материалы/подтемы/секция-2.-react/тема-№17/правила-использования-hooks.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Правила использования Hooks</a>\n<br><a data-href=\"useEffect\" href=\"материалы/подтемы/секция-2.-react/тема-№17/useeffect.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">useEffect</a>\n<br><a data-href=\"useContext\" href=\"материалы/подтемы/секция-2.-react/тема-№17/usecontext.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">useContext</a>\n<br><a data-href=\"Пользовательские Hooks\" href=\"материалы/подтемы/секция-2.-react/тема-№17/пользовательские-hooks.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Пользовательские Hooks</a>\n(пусто)<br><a data-href=\"Тема №18. Routers в React\" href=\"лекции/секция-2.-react/тема-№18.-routers-в-react.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №18. Routers в React</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-2.-react/тема-№17/что-такое-hooks.html","материалы/подтемы/секция-2.-react/тема-№17/правила-использования-hooks.html","материалы/подтемы/секция-2.-react/тема-№17/useeffect.html","материалы/подтемы/секция-2.-react/тема-№17/usecontext.html","материалы/подтемы/секция-2.-react/тема-№17/пользовательские-hooks.html","лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-2.-react/тема-№17.-hooks-в-react.html","pathToRoot":"../..","attachments":[],"createdTime":1768643061201,"modifiedTime":1768931668144,"sourceSize":1060,"sourcePath":"Лекции/Секция 2. React/Тема №17. Hooks в React.md","exportPath":"лекции/секция-2.-react/тема-№17.-hooks-в-react.html","showInTree":true,"treeOrder":32,"backlinks":["лекции/секция-2.-react/тема-№16.-события-и-ref-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-хранения-значений.html":{"title":"Использование useRef для хранения значений","icon":"","description":"Хук useRef можно использовать не только для доступа к DOM-элементам, но и для хранения любых изменяемых значений, которые должны сохраняться между рендерами, но не должны вызывать перерисовку компонента.Значение, хранящееся в ref.current, остаётся неизменным в течение всего жизненного цикла компонента, если вы его явно не измените. При этом:\nИзменение ref.current не запускает повторный рендер.\nЗначение доступно во всех обработчиках, эффектах и даже внутри замыканий без потери актуальности (в отличие от переменных в теле компонента).\nПолезно для сравнения текущего и предыдущего состояния или пропса:function usePrevious(value) { const ref = useRef(); useEffect(() =&gt; { ref.current = value; }); return ref.current;\n} function Counter({ count }) { const prevCount = usePrevious(count); return &lt;p&gt;Сейчас: {count}, было: {prevCount}&lt;/p&gt;;\n}\nЧтобы избежать создания новых таймеров при каждом рендере:function Timer() { const intervalRef = useRef(null); useEffect(() =&gt; { intervalRef.current = setInterval(() =&gt; { console.log('Тик'); }, 1000); return () =&gt; clearInterval(intervalRef.current); }, []); function stopTimer() { clearInterval(intervalRef.current); } return &lt;button onClick={stopTimer}&gt;Остановить&lt;/button&gt;;\n}\nЕсли вычисление зависит от внешних данных и не должно зависеть от ререндера:function ExpensiveComponent({ data }) { const cacheRef = useRef(null); if (!cacheRef.current || cacheRef.current.input !== data) { cacheRef.current = { input: data, output: heavyComputation(data) }; } return &lt;div&gt;{cacheRef.current.output}&lt;/div&gt;;\n} useState — для данных, влияющих на UI (изменение → рендер).\nuseRef — для данных, нужных «внутри» логики, но не отображаемых напрямую.\nНапример, счётчик попыток авторизации, который не отображается, но используется в фоне — хороший кандидат для ref.\nНе мутируйте ref.current во время рендера (например, внутри основного тела компонента). Это может привести к непредсказуемому поведению.\nЗначение в ref не сериализуется и не сохраняется при горячей перезагрузке (HMR), если не предусмотрена дополнительная логика.\nИспользование useRef для хранения значений — это способ сохранить \"память\" компонента без лишних ререндеров.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Как это работает","level":2,"id":"Как_это_работает_0"},{"heading":"Типичные сценарии","level":2,"id":"Типичные_сценарии_0"},{"heading":"Хранение предыдущего значения","level":3,"id":"Хранение_предыдущего_значения_0"},{"heading":"Управление таймерами","level":3,"id":"Управление_таймерами_0"},{"heading":"Кэширование дорогих вычислений","level":3,"id":"Кэширование_дорогих_вычислений_0"},{"heading":"Отличие от useState","level":2,"id":"Отличие_от_useState_0"},{"heading":"Важные особенности","level":2,"id":"Важные_особенности_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-хранения-значений.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768642309999,"modifiedTime":1768642383557,"sourceSize":3738,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/Использование useRef для хранения значений.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-хранения-значений.html","showInTree":true,"treeOrder":157,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/что-такое-ref.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-dom-элементов.html":{"title":"Использование useRef для DOM-элементов","icon":"","description":"Хук useRef позволяет получить прямую ссылку на реальный DOM-элемент, что бывает необходимо, когда стандартного управления через состояние недостаточно.Чтобы связать ref с DOM-элементом, передайте его в атрибут ref:const inputRef = useRef(null); return &lt;input ref={inputRef} type=\"text\" /&gt;;\nПосле монтирования компонента inputRef.current будет содержать настоящий HTML-элемент &lt;input&gt;.Автоматически установить фокус на поле ввода при открытии формы:function AutoFocusInput() { const inputRef = useRef(null); useEffect(() =&gt; { inputRef.current.focus(); }, []); return &lt;input ref={inputRef} /&gt;;\n}\nИногда удобно прочитать значение поля напрямую, особенно в неконтролируемых компонентах:function Form() { const inputRef = useRef(null); function handleSubmit() { console.log('Значение:', inputRef.current.value); } return ( &lt;form onSubmit={(e) =&gt; { e.preventDefault(); handleSubmit(); }}&gt; &lt;input ref={inputRef} defaultValue=\"\" /&gt; &lt;button type=\"submit\"&gt;Отправить&lt;/button&gt; &lt;/form&gt; );\n}\nПример с видео:function VideoPlayer() { const videoRef = useRef(null); function play() { videoRef.current.play(); } function pause() { videoRef.current.pause(); } return ( &lt;&gt; &lt;video ref={videoRef} src=\"movie.mp4\" /&gt; &lt;button onClick={play}&gt;▶️&lt;/button&gt; &lt;button onClick={pause}&gt;⏸️&lt;/button&gt; &lt;/&gt; );\n} ref.current становится доступен только после того, как React создаст соответствующий DOM-узел (обычно внутри useEffect).\nНе пытайтесь читать или изменять ref.current во время рендера — это может привести к ошибкам.\nRef работает только с DOM-элементами и классовыми компонентами. Для функциональных компонентов требуется forwardRef.\nПрямой доступ к DOM через useRef — мощный инструмент, но его следует использовать только тогда, когда невозможно обойтись state и props.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Привязка ref к элементу","level":2,"id":"Привязка_ref_к_элементу_0"},{"heading":"Типичные сценарии","level":2,"id":"Типичные_сценарии_0"},{"heading":"Фокусировка при монтировании","level":3,"id":"Фокусировка_при_монтировании_0"},{"heading":"Получение значения без состояния","level":3,"id":"Получение_значения_без_состояния_0"},{"heading":"Управление медиа или анимациями","level":3,"id":"Управление_медиа_или_анимациями_0"},{"heading":"Важные особенности","level":2,"id":"Важные_особенности_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-dom-элементов.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768642266128,"modifiedTime":1768642291997,"sourceSize":2955,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/Использование useRef для DOM-элементов.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-dom-элементов.html","showInTree":true,"treeOrder":158,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/что-такое-ref.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№16/когда-использовать-ref,-а-когда-—-state.html":{"title":"Когда использовать Ref, а когда — State","icon":"","description":"Выбор между useRef и useState определяется одной простой идеей: нужно ли, чтобы изменение значения вызывало перерисовку компонента?Значение влияет на то, что пользователь видит. Например:\nТекст в поле ввода, который отображается где-то ещё\nСостояние кнопки (активна/неактивна)\nВыбранная вкладка или тема интерфейса\nСписок задач, фильтры, ошибки валидации\nconst [count, setCount] = useState(0);\n// При setCount(1) компонент перерисуется — это необходимо,\n// если, например, вы показываете \"Счётчик: 1\"\nuseState — основной инструмент для управления данными, которые определяют внешний вид приложения.Значение нужно только для логики, но не влияет на отображение. Например:\nСсылка на DOM-элемент (для фокуса, прокрутки, измерения)\nХранение предыдущего значения пропса или состояния\nИдентификатор таймера (setTimeout, setInterval)\nКэш дорогих вычислений\nСчётчик попыток, логирование, технические данные\nconst timerIdRef = useRef(null);\n// Изменение timerIdRef.current не должно перерисовывать UI —\n// оно нужно только для остановки таймера позже Если вы используете значение внутри JSX ({value}), — это состояние.\nЕсли вы используете значение только в функциях, эффектах или обработчиках, — это ref. Контролируемая форма: useState — потому что вы можете показывать ошибку, кнопку активировать/деактивировать, делать предпросмотр.\nНеконтролируемая форма: useRef — если вы просто читаете данные при отправке и ничего не отображаете на основе ввода. Использовать ref для данных в JSX — компонент не обновится, даже если значение изменилось.\nИспользовать state для таймеров или DOM-ссылок — это вызовет лишние ререндеры и усложнит код.\nВ подавляющем большинстве случаев начинайте с useState. Переходите к useRef только тогда, когда убедитесь, что перерисовка не нужна и мешает производительности или логике.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Используйте <code>useState</code>, если…","level":2,"id":"Используйте_`useState`,_если…_0"},{"heading":"Используйте <code>useRef</code>, если…","level":2,"id":"Используйте_`useRef`,_если…_0"},{"heading":"Практическое правило","level":2,"id":"Практическое_правило_0"},{"heading":"Пример выбора в формах","level":2,"id":"Пример_выбора_в_формах_0"},{"heading":"Ошибки при выборе","level":2,"id":"Ошибки_при_выборе_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№16/когда-использовать-ref,-а-когда-—-state.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768642774584,"modifiedTime":1768642811286,"sourceSize":3456,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/Когда использовать Ref, а когда — State.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/когда-использовать-ref,-а-когда-—-state.html","showInTree":true,"treeOrder":159,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/работа-с-формами.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№16/контролируемые-компоненты.html":{"title":"Контролируемые компоненты","icon":"","description":"Контролируемые компоненты — это элементы формы, значение которых управляется состоянием React. Вместо того чтобы позволять DOM хранить данные, React берёт управление на себя: каждое изменение обновляет состояние, а состояние определяет, что отображается.Для создания контролируемого компонента:\nСоздайте состояние с помощью useState\nПривяжите значение поля к этому состоянию через value\nОбновляйте состояние при каждом изменении через onChange\nПример текстового поля:function NameInput() { const [name, setName] = useState(''); return ( &lt;input value={name} onChange={(e) =&gt; setName(e.target.value)} placeholder=\"Введите имя\" /&gt; );\n}\nБез value поле будет неконтролируемым. Без onChange оно станет «только для чтения» — пользователь не сможет его изменить.Контролируемые компоненты работают со всеми стандартными элементами формы:\n&lt;input type=\"text\"&gt;, &lt;input type=\"password\"&gt; и т.д. — через value\n&lt;textarea&gt; — также через value\n&lt;select&gt; — через value (может быть строкой или массивом для множественного выбора)\n&lt;input type=\"checkbox\"&gt; и &lt;input type=\"radio\"&gt; — через checked\nПример выпадающего списка:function CitySelect() { const [city, setCity] = useState('moscow'); return ( &lt;select value={city} onChange={(e) =&gt; setCity(e.target.value)}&gt; &lt;option value=\"moscow\"&gt;Москва&lt;/option&gt; &lt;option value=\"spb\"&gt;Санкт-Петербург&lt;/option&gt; &lt;/select&gt; );\n} Полный контроль: вы всегда знаете текущее значение\nВалидация в реальном времени: можно блокировать недопустимый ввод\nПреобразование данных: например, приведение к верхнему регистру или форматирование номера телефона\nСинхронизация: значение легко использовать в других частях приложения Требует больше кода, особенно для больших форм\nМожет снижать производительность при очень частых обновлениях (в таких случаях можно использовать useDeferredValue или оптимизировать)\nКонтролируемые компоненты — основной и рекомендуемый способ работы с формами в React, так как они соответствуют декларативной философии фреймворка.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Как это работает","level":2,"id":"Как_это_работает_0"},{"heading":"Поддерживаемые элементы","level":2,"id":"Поддерживаемые_элементы_0"},{"heading":"Преимущества","level":2,"id":"Преимущества_0"},{"heading":"Ограничения","level":2,"id":"Ограничения_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№16/контролируемые-компоненты.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768642706169,"modifiedTime":1768642708856,"sourceSize":3444,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/Контролируемые компоненты.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/контролируемые-компоненты.html","showInTree":true,"treeOrder":160,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/работа-с-формами.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№16/неконтролируемые-компоненты.html":{"title":"Неконтролируемые компоненты","icon":"","description":"Неконтролируемые компоненты — это элементы формы, значение которых управляется самим DOM, а не состоянием React. Вместо того чтобы синхронизировать каждое изменение с useState, вы позволяете браузеру хранить данные и читаете их только тогда, когда они нужны — например, при отправке формы.Для создания неконтролируемого компонента:\nИспользуйте useRef, чтобы получить ссылку на DOM-элемент\nПропустите привязку value к состоянию\nПри необходимости прочитайте значение через ref.current.value\nПример:function UncontrolledInput() { const inputRef = useRef(null); function handleClick() { console.log('Текущее значение:', inputRef.current.value); } return ( &lt;&gt; &lt;input ref={inputRef} defaultValue=\"начальное значение\" /&gt; &lt;button onClick={handleClick}&gt;Показать значение&lt;/button&gt; &lt;/&gt; );\n}\nОбратите внимание: вместо value используется defaultValue. Это задаёт начальное значение, но не блокирует дальнейший ввод пользователя.Неконтролируемые компоненты уместны в следующих случаях:\nБольшие формы, где управление каждым полем через состояние создаёт избыточную нагрузку\nИнтеграция со сторонними библиотеками, которые напрямую работают с DOM (например, редакторы кода или карты)\nОдноразовый ввод, например, поиск или быстрая отправка данных без валидации\nПроизводительность: если поле обновляется очень часто (например, рисование или аудиовизуализация) Нет автоматической синхронизации с состоянием — вы сами решаете, когда читать данные\nНевозможно динамически изменить значение поля из кода (кроме как через ref.current.value = ..., что не рекомендуется)\nВалидация возможна только в момент чтения (например, при отправке), а не в реальном времени\nНеконтролируемые компоненты — допустимый, но менее распространённый подход. Используйте их осознанно, когда преимущества перевешивают потерю реактивности.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Как это работает","level":2,"id":"Как_это_работает_0"},{"heading":"Когда использовать","level":2,"id":"Когда_использовать_0"},{"heading":"Особенности","level":2,"id":"Особенности_0"},{"heading":"Сравнение с контролируемыми","level":2,"id":"Сравнение_с_контролируемыми_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№16/неконтролируемые-компоненты.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768642714348,"modifiedTime":1768642768274,"sourceSize":4087,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/Неконтролируемые компоненты.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/неконтролируемые-компоненты.html","showInTree":true,"treeOrder":161,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/работа-с-формами.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№16/обработка-событий-в-react.html":{"title":"Обработка событий в React","icon":"","description":"В React обработка событий — это механизм, позволяющий компонентам реагировать на действия пользователя: клики, ввод текста, отправку формы, фокус и другие взаимодействия. События в React похожи на события в DOM, но имеют несколько важных отличий.Имена событий в React пишутся в camelCase, а не в нижнем регистре, как в HTML. Например:\n<a data-href=\"onClick\" href=\"материалы/подтемы/секция-2.-react/тема-№16/onclick.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">onClick</a> вместо onclick\n<br><a data-href=\"onChange\" href=\"материалы/подтемы/секция-2.-react/тема-№16/onchange.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">onChange</a> вместо onchange\n<br><a data-href=\"onSubmit\" href=\"материалы/подтемы/секция-2.-react/тема-№16/onsubmit.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">onSubmit</a> вместо onsubmit\nОбработчик передаётся как функция, а не как строка:// Правильно\n&lt;button onClick={handleClick}&gt;Нажми&lt;/button&gt; // Неправильно\n&lt;button onClick={handleClick()}&gt;Нажми&lt;/button&gt;\nВызов handleClick() при передаче приведёт к немедленному выполнению функции при каждом рендере, а не при клике.React поддерживает стандартные события пользовательского взаимодействия:\n<br><a data-href=\"onClick\" href=\"материалы/подтемы/секция-2.-react/тема-№16/onclick.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">onClick</a> — нажатие кнопки или другого элемента\n<br><a data-href=\"onChange\" href=\"материалы/подтемы/секция-2.-react/тема-№16/onchange.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">onChange</a> — изменение значения в &lt;input&gt;, &lt;select&gt; или &lt;textarea&gt;\n<br><a data-href=\"onSubmit\" href=\"материалы/подтемы/секция-2.-react/тема-№16/onsubmit.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">onSubmit</a> — отправка формы\n<br><a data-href=\"onFocus и onBlur\" href=\"материалы/подтемы/секция-2.-react/тема-№16/onfocus-и-onblur.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">onFocus и onBlur</a> — получение и потеря фокуса\nПример обработки отправки формы:function Form() { function handleSubmit(event) { event.preventDefault(); // отменяет перезагрузку страницы console.log('Форма отправлена'); } return ( &lt;form onSubmit={handleSubmit}&gt; &lt;input type=\"text\" /&gt; &lt;button type=\"submit\"&gt;Отправить&lt;/button&gt; &lt;/form&gt; );\n}\nОбработчики получают в качестве аргумента объект события (event). Он содержит информацию о произошедшем действии и методы для управления поведением по умолчанию.Часто используемые методы:\nevent.preventDefault() — отменяет стандартное действие (например, отправку формы)\nevent.stopPropagation() — останавливает всплытие события вверх по дереву DOM\nПример:function handleClick(event) { event.stopPropagation(); console.log('Клик только на эту кнопку');\n} Обработчики не вызываются автоматически — они срабатывают только при соответствующем пользовательском действии.\nФункция-обработчик должна быть передана, а не вызвана.\nВсе события в React нормализованы: они работают одинаково во всех браузерах, даже если нативные события отличаются.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Синтаксис и соглашения","level":2,"id":"Синтаксис_и_соглашения_0"},{"heading":"Типичные события","level":2,"id":"Типичные_события_0"},{"heading":"Объект события","level":2,"id":"Объект_события_0"},{"heading":"Важные особенности","level":2,"id":"Важные_особенности_0"}],"links":["материалы/подтемы/секция-2.-react/тема-№16/onclick.html","материалы/подтемы/секция-2.-react/тема-№16/onchange.html","материалы/подтемы/секция-2.-react/тема-№16/onsubmit.html","материалы/подтемы/секция-2.-react/тема-№16/onclick.html","материалы/подтемы/секция-2.-react/тема-№16/onchange.html","материалы/подтемы/секция-2.-react/тема-№16/onsubmit.html","материалы/подтемы/секция-2.-react/тема-№16/onfocus-и-onblur.html"],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№16/обработка-событий-в-react.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768641742296,"modifiedTime":1768641889311,"sourceSize":3456,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/Обработка событий в React.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/обработка-событий-в-react.html","showInTree":true,"treeOrder":162,"backlinks":["лекции/секция-2.-react/тема-№16.-события-и-ref-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№16/ограничения-и-рекомендации.html":{"title":"Ограничения и рекомендации","icon":"","description":"Хотя useRef — мощный инструмент, его неправильное использование может привести к трудноуловимым ошибкам и нарушению принципов React. Вот ключевые ограничения и рекомендации.Изменение ref.current внутри тела компонента (не в эффектах или обработчиках) нарушает чистоту рендера:// Плохо\nfunction BadComponent() { const ref = useRef(0); ref.current = ref.current + 1; // мутирует при каждом рендере return &lt;div&gt;{ref.current}&lt;/div&gt;;\n}\nЭто приводит к непредсказуемому поведению, особенно при использовании строгого режима или будущих асинхронных рендереров.Правильно — обновлять ref.current только в useEffect, обработчиках событий или колбэках.Если значение должно отображаться в интерфейсе или влиять на то, что пользователь видит, используйте useState:// Избегайте\nconst countRef = useRef(0);\n// ...и где-то: countRef.current += 1\n// но в JSX: {countRef.current} — это работает, но нарушает реактивность // Правильно\nconst [count, setCount] = useState(0);\nReact не будет знать, что нужно обновить компонент, если вы измените только ref.React построен на декларативной модели: вы описываете, как должен выглядеть интерфейс, а не как его изменить. Прямое изменение DOM через ref:\nЛомает предсказуемость\nУсложняет тестирование\nМожет конфликтовать с обновлениями React\nИспользуйте ref только тогда, когда нет другого способа: фокус, измерение размеров, работа с медиа, интеграция со сторонними библиотеками.Если вы попытаетесь передать ref в обычный функциональный компонент, React проигнорирует его:// Не сработает\nfunction MyInput() { return &lt;input /&gt;;\n}\n// ...\n&lt;MyInput ref={myRef} /&gt; // myRef.current будет null\nЧтобы исправить, используйте forwardRef:// const MyInput = forwardRef((props, ref) =&gt; { return &lt;input ref={ref} {...props} /&gt;;\n}); Используйте ref только для задач, которые невозможно решить через state и props.\nОбновляйте ref.current вне фазы рендера.\nПредпочитайте управляемые компоненты (useState + onChange) неконтролируемым (ref + value), если нет веской причины.\nПомните: React — про данные, а не про DOM. Ref — исключение, а не правило.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Не мутируйте ref во время рендера","level":2,"id":"Не_мутируйте_ref_во_время_рендера_0"},{"heading":"Не используйте ref вместо состояния для данных, влияющих на UI","level":2,"id":"Не_используйте_ref_вместо_состояния_для_данных,_влияющих_на_UI_0"},{"heading":"Избегайте прямого манипулирования DOM без необходимости","level":2,"id":"Избегайте_прямого_манипулирования_DOM_без_необходимости_0"},{"heading":"Ref не работает напрямую с функциональными компонентами","level":2,"id":"Ref_не_работает_напрямую_с_функциональными_компонентами_0"},{"heading":"Итог","level":2,"id":"Итог_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№16/ограничения-и-рекомендации.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768642392326,"modifiedTime":1768642483908,"sourceSize":3795,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/Ограничения и рекомендации.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/ограничения-и-рекомендации.html","showInTree":true,"treeOrder":163,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/что-такое-ref.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№16/работа-с-формами.html":{"title":"Работа с формами","icon":"","description":"В React формы могут быть реализованы двумя основными способами: через контролируемые и неконтролируемые компоненты. Выбор между ними зависит от того, как вы управляете данными ввода — через состояние React или напрямую через DOM.В контролируемых компонентах значение поля ввода управляется состоянием React. Это означает, что:\nЗначение элемента задаётся через пропс value (или checked для чекбоксов)\nЛюбое изменение обрабатывается через onChange, который обновляет состояние\nReact всегда «владеет» текущим значением\nПример:function ControlledForm() { const [name, setName] = useState(''); return ( &lt;form&gt; &lt;input value={name} onChange={(e) =&gt; setName(e.target.value)} placeholder=\"Введите имя\" /&gt; &lt;p&gt;Вы ввели: {name}&lt;/p&gt; &lt;/form&gt; );\n}\n<a data-href=\"Контролируемые компоненты\" href=\"материалы/подтемы/секция-2.-react/тема-№16/контролируемые-компоненты.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Контролируемые компоненты</a> — рекомендуемый подход в большинстве случаев, так как они:\nПредсказуемы\nПозволяют легко валидировать и преобразовывать ввод\nИнтегрируются с состоянием приложения\nВ неконтролируемых компонентах данные хранятся в самом DOM-элементе. React не управляет значением — вместо этого вы используете ref, чтобы прочитать его при необходимости.Пример:function UncontrolledForm() { const inputRef = useRef(null); function handleSubmit(e) { e.preventDefault(); console.log('Значение:', inputRef.current.value); } return ( &lt;form onSubmit={handleSubmit}&gt; &lt;input ref={inputRef} defaultValue=\"\" /&gt; &lt;button type=\"submit\"&gt;Отправить&lt;/button&gt; &lt;/form&gt; );\n}\n<br><a data-href=\"Неконтролируемые компоненты\" href=\"материалы/подтемы/секция-2.-react/тема-№16/неконтролируемые-компоненты.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Неконтролируемые компоненты</a> полезны, когда:\nФорма очень большая, и управление каждым полем через состояние избыточно\nИнтеграция с библиотеками, которые работают напрямую с DOM\nВременные или одноразовые формы, где валидация не требуется\nВыбор между ref и useState для форм зависит от цели: Используйте состояние (useState), если: Значение влияет на отображение (например, предварительный просмотр, кнопка активна/неактивна)\nТребуется валидация в реальном времени\nДанные нужны в других частях приложения Используйте ref, если: Значение нужно только в момент отправки\nВы работаете с большим количеством полей, и синхронизация состояния слишком затратна\nЭлемент используется для технических целей (например, фокусировка) Важно: даже в неконтролируемых формах можно комбинировать подходы — например, использовать ref для большинства полей, но state для кнопки «Отправить», которая должна быть недоступна, пока не заполнено обязательное поле.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"<a data-href=\"Контролируемые компоненты\" href=\"Контролируемые компоненты\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">Контролируемые компоненты</a>","level":2,"id":"[[Контролируемые_компоненты]]_0"},{"heading":"<a data-href=\"Неконтролируемые компоненты\" href=\"Неконтролируемые компоненты\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">Неконтролируемые компоненты</a>","level":2,"id":"[[Неконтролируемые_компоненты]]_0"},{"heading":"<a data-href=\"Когда использовать Ref, а когда — State\" href=\"Когда использовать Ref, а когда — State\" class=\"internal-link\" target=\"_blank\" rel=\"noopener nofollow\">Когда использовать Ref, а когда — State</a>","level":2,"id":"[[Когда_использовать_Ref,_а_когда_—_State]]_0"}],"links":["материалы/подтемы/секция-2.-react/тема-№16/контролируемые-компоненты.html","материалы/подтемы/секция-2.-react/тема-№16/контролируемые-компоненты.html","материалы/подтемы/секция-2.-react/тема-№16/неконтролируемые-компоненты.html","материалы/подтемы/секция-2.-react/тема-№16/неконтролируемые-компоненты.html","материалы/подтемы/секция-2.-react/тема-№16/когда-использовать-ref,-а-когда-—-state.html"],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№16/работа-с-формами.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768642492729,"modifiedTime":1768642666241,"sourceSize":4250,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/Работа с формами.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/работа-с-формами.html","showInTree":true,"treeOrder":164,"backlinks":["лекции/секция-2.-react/тема-№16.-события-и-ref-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№16/что-такое-ref.html":{"title":"Что такое Ref","icon":"","description":"Ref (сокращение от reference) в React — это способ получить прямой доступ к DOM-элементу или сохранить значение, которое не вызывает перерисовку компонента при изменении. Ref особенно полезен, когда нужно работать с элементами вне обычного потока данных через props и state.Для создания ref используется хук useRef:const myRef = useRef(initialValue);\nПосле этого myRef.current содержит текущее значение. При первом рендере myRef.current равно переданному начальному значению.Чтобы привязать ref к DOM-элементу, передайте его в атрибут ref:&lt;input ref={myRef} /&gt;\nТеперь myRef.current будет ссылаться на настоящий DOM-элемент &lt;input&gt;.Основное отличие useRef от useState:\nИзменение ref.current не вызывает повторный рендер компонента.\nref предназначен для хранения данных, которые нужны между рендерами, но не влияют на то, как компонент выглядит.\nЭто делает ref идеальным для:\nХранения ссылок на таймеры, интервалы или внешние объекты\nСохранения предыдущих значений props или state\nПрямого взаимодействия с DOM (фокус, измерение размеров, воспроизведение видео)\nИспользуйте ref, когда:\nНужно управлять фокусом, выделением текста или воспроизведением медиа\nТребуется доступ к DOM-методам (например, scrollIntoView)\nНеобходимо хранить значение, которое не должно влиять на UI\nНе используйте ref для данных, которые определяют внешний вид компонента — для этого подходит useState.<a data-href=\"Использование useRef для DOM-элементов\" href=\"материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-dom-элементов.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Использование useRef для DOM-элементов</a><br>\n<a data-href=\"Использование useRef для хранения значений\" href=\"материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-хранения-значений.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Использование useRef для хранения значений</a><br>\n<a data-href=\"Ограничения и рекомендации\" href=\"материалы/подтемы/секция-2.-react/тема-№16/ограничения-и-рекомендации.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Ограничения и рекомендации</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Создание и использование","level":2,"id":"Создание_и_использование_0"},{"heading":"Отличие от состояния","level":2,"id":"Отличие_от_состояния_0"},{"heading":"Когда использовать","level":2,"id":"Когда_использовать_0"}],"links":["материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-dom-элементов.html","материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-хранения-значений.html","материалы/подтемы/секция-2.-react/тема-№16/ограничения-и-рекомендации.html"],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№16/что-такое-ref.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768642202141,"modifiedTime":1768642257320,"sourceSize":2741,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/Что такое Ref.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/что-такое-ref.html","showInTree":true,"treeOrder":165,"backlinks":["лекции/секция-2.-react/тема-№16.-события-и-ref-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№16/onchange.html":{"title":"onChange","icon":"","description":"Событие onChange срабатывает, когда пользователь изменяет значение элемента формы — например, вводит текст в поле, выбирает опцию в выпадающем списке или ставит галочку в чекбоксе.Обработчик onChange обычно используется вместе с управляемыми компонентами, где значение поля контролируется состоянием React:function InputField() { const [value, setValue] = useState(''); function handleChange(event) { setValue(event.target.value); } return &lt;input value={value} onChange={handleChange} /&gt;;\n}\nКаждый ввод обновляет состояние, и React немедленно отображает новое значение.В обработчик передаётся объект события. Чтобы получить текущее значение поля, используйте event.target.value:function handleChange(event) { console.log('Текущее значение:', event.target.value);\n}\nДля чекбоксов и радиокнопок значение находится в event.target.checked.function Checkbox() { const [checked, setChecked] = useState(false); function handleChange(event) { setChecked(event.target.checked); } return &lt;input type=\"checkbox\" checked={checked} onChange={handleChange} /&gt;;\n} onChange срабатывает при любом изменении, а не только при потере фокуса (в отличие от нативного DOM-события change в некоторых старых браузерах).\nВ React это событие нормализовано: оно работает одинаково для всех типов полей ввода.\nНе используйте onChange без управления значением через value (или checked) — это приведёт к неконтролируемому поведению и предупреждениям в консоли.\nСобытие onChange — основа для создания интерактивных форм в React и ключевой элемент паттерна управляемых компонентов.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Использование","level":2,"id":"Использование_0"},{"heading":"Объект события","level":2,"id":"Объект_события_0"},{"heading":"Пример с чекбоксом","level":2,"id":"Пример_с_чекбоксом_0"},{"heading":"Важные особенности","level":2,"id":"Важные_особенности_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№16/onchange.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768641987412,"modifiedTime":1768642016812,"sourceSize":2598,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/onChange.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/onchange.html","showInTree":true,"treeOrder":166,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/обработка-событий-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№16/onclick.html":{"title":"onClick","icon":"","description":"Событие onClick срабатывает, когда пользователь нажимает на элемент — например, кнопку, ссылку или любой другой кликабельный компонент.Обработчик onClick передаётся как пропс в JSX-элемент:&lt;button onClick={handleClick}&gt;Нажми меня&lt;/button&gt;\nФункция handleClick будет вызвана при каждом клике. Она может быть определена внутри компонента:function Button() { function handleClick() { console.log('Кнопка нажата'); } return &lt;button onClick={handleClick}&gt;Нажми&lt;/button&gt;;\n}\nОбработчик может принимать объект события как аргумент:function handleClick(event) { console.log(event.target); // элемент, по которому кликнули\n}\nЭто позволяет получать информацию о контексте клика, например, значение кнопки или её атрибуты.Если нужно передать данные в обработчик, используйте стрелочную функцию:&lt;button onClick={() =&gt; handleDelete(id)}&gt;Удалить&lt;/button&gt;\nВажно: не вызывайте функцию напрямую (onClick={handleDelete(id)}), иначе она выполнится сразу при рендере.\nonClick работает на любом элементе, даже если он не интерактивный (например, &lt;div&gt;), но для доступности лучше использовать семантические теги (&lt;button&gt;) или добавлять role=\"button\".\nВ мобильных браузерах onClick может иметь небольшую задержку; для мгновенного отклика иногда используют onTouchStart, но это редко требуется в современных приложениях.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Использование","level":2,"id":"Использование_0"},{"heading":"Доступ к событию","level":2,"id":"Доступ_к_событию_0"},{"heading":"Передача дополнительных данных","level":2,"id":"Передача_дополнительных_данных_0"},{"heading":"Особенности","level":2,"id":"Особенности_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№16/onclick.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768641956899,"modifiedTime":1768641981200,"sourceSize":2320,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/onClick.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/onclick.html","showInTree":true,"treeOrder":167,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/обработка-событий-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№16/onfocus-и-onblur.html":{"title":"onFocus и onBlur","icon":"","description":"События onFocus и onBlur позволяют отслеживать, когда элемент получает или теряет фокус. Они особенно полезны для полей ввода, кнопок и других интерактивных элементов.Событие onFocus срабатывает, когда пользователь переходит на элемент — например, кликает по полю ввода или перемещается к нему с помощью клавиши Tab.function InputWithFocus() { function handleFocus() { console.log('Поле получило фокус'); } return &lt;input onFocus={handleFocus} /&gt;;\n}\nСобытие onBlur срабатывает, когда элемент теряет фокус — например, пользователь кликает вне поля или переключается на другой элемент.function InputWithBlur() { function handleBlur() { console.log('Поле потеряло фокус'); } return &lt;input onBlur={handleBlur} /&gt;;\n}\nЭти события часто используются вместе:\nДля показа подсказок или ошибок при потере фокуса (валидация «на лету»)\nДля скрытия/показа дополнительного интерфейса (например, календаря при фокусе на дате)\nДля отслеживания активного поля в сложных формах\nПример: валидация email после того, как пользователь завершил ввод:function EmailInput() { const [email, setEmail] = useState(''); const [error, setError] = useState(''); function validate(value) { if (!value.includes('@')) { setError('Email должен содержать @'); } else { setError(''); } } return ( &lt;&gt; &lt;input value={email} onChange={(e) =&gt; setEmail(e.target.value)} onBlur={() =&gt; validate(email)} /&gt; {error &amp;&amp; &lt;span style={{ color: 'red' }}&gt;{error}&lt;/span&gt;} &lt;/&gt; );\n} onFocus и onBlur не всплывают так же, как другие события, но React нормализует их поведение.\nЭти события не срабатывают при программном изменении фокуса (например, через ref.current.focus()), если только не используется нативный DOM-метод напрямую.\nИспользование onBlur для валидации предпочтительнее, чем onChange, если проверка дорогая или должна происходить только после завершения ввода.\nСобытия onFocus и onBlur помогают создавать более отзывчивый и удобный интерфейс, реагирующий на этапы взаимодействия пользователя с элементами.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"onFocus","level":2,"id":"onFocus_0"},{"heading":"onBlur","level":2,"id":"onBlur_0"},{"heading":"Практическое применение","level":2,"id":"Практическое_применение_0"},{"heading":"Важные особенности","level":2,"id":"Важные_особенности_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№16/onfocus-и-onblur.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768642092377,"modifiedTime":1768642122257,"sourceSize":3312,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/onFocus и onBlur.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/onfocus-и-onblur.html","showInTree":true,"treeOrder":168,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/обработка-событий-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№16/onsubmit.html":{"title":"onSubmit","icon":"","description":"Событие onSubmit срабатывает, когда пользователь отправляет форму — например, нажимает кнопку с type=\"submit\" или вводит Enter в поле внутри формы.Обработчик onSubmit привязывается к элементу &lt;form&gt;:function Form() { function handleSubmit(event) { event.preventDefault(); // предотвращает перезагрузку страницы console.log('Форма отправлена'); } return ( &lt;form onSubmit={handleSubmit}&gt; &lt;input type=\"text\" name=\"username\" /&gt; &lt;button type=\"submit\"&gt;Отправить&lt;/button&gt; &lt;/form&gt; );\n}\nБез вызова event.preventDefault() браузер выполнит стандартное действие — отправит форму и перезагрузит страницу, что в React-приложениях почти всегда нежелательно.В управляемых компонентах данные обычно берутся из состояния:function Form() { const [username, setUsername] = useState(''); function handleSubmit(event) { event.preventDefault(); console.log('Имя пользователя:', username); } return ( &lt;form onSubmit={handleSubmit}&gt; &lt;input type=\"text\" value={username} onChange={(e) =&gt; setUsername(e.target.value)} /&gt; &lt;button type=\"submit\"&gt;Отправить&lt;/button&gt; &lt;/form&gt; );\n}\nВ неконтролируемых формах можно использовать ref для доступа к значениям напрямую.\nКнопка внутри формы по умолчанию имеет type=\"submit\", если не указано иное. Чтобы избежать случайной отправки, явно указывайте type=\"button\" для обычных кнопок.\nСобытие onSubmit всплывает, но его можно остановить с помощью event.stopPropagation(), если нужно изолировать обработку.\nОтправка формы возможна не только через кнопку: нажатие Enter в текстовом поле также вызывает onSubmit.\nСобытие onSubmit — центральный механизм обработки пользовательского ввода в формах и основа для валидации, отправки данных на сервер и управления состоянием приложения.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Использование","level":2,"id":"Использование_0"},{"heading":"Получение данных формы","level":2,"id":"Получение_данных_формы_0"},{"heading":"Важные особенности","level":2,"id":"Важные_особенности_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№16/onsubmit.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768642063823,"modifiedTime":1768642091116,"sourceSize":2819,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/onSubmit.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/onsubmit.html","showInTree":true,"treeOrder":169,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/обработка-событий-в-react.html"],"type":"markdown"},"лекции/секция-2.-react/тема-№18.-routers-в-react.html":{"title":"Тема №18. Routers в React","icon":"","description":"В этой теме вы изучите маршрутизацию в React — механизм для отображения разных компонентов в зависимости от текущего URL. Поймёте, как организовать навигацию между экранами приложения, используя библиотеку React Router, и как передавать параметры между маршрутами.\n<a data-href=\"Что такое маршрутизация\" href=\"материалы/подтемы/секция-2.-react/тема-№18/что-такое-маршрутизация.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Что такое маршрутизация</a>\n<br><a data-href=\"React Router — основная библиотека\" href=\"материалы/подтемы/секция-2.-react/тема-№18/react-router-—-основная-библиотека.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">React Router — основная библиотека</a>\n<br><a data-href=\"Основные компоненты React Router\" href=\"материалы/подтемы/секция-2.-react/тема-№18/основные-компоненты-react-router.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Основные компоненты React Router</a>\n<br><a data-href=\"Параметры маршрута\" href=\"материалы/подтемы/секция-2.-react/тема-№18/параметры-маршрута.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Параметры маршрута</a>\n<br><a data-href=\"Вложенные маршруты\" href=\"материалы/подтемы/секция-2.-react/тема-№18/вложенные-маршруты.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Вложенные маршруты</a>\n<br><a data-href=\"Программная навигация\" href=\"материалы/подтемы/секция-2.-react/тема-№18/программная-навигация.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Программная навигация</a>\n<br><a data-href=\"Обработка несуществующих маршрутов\" href=\"материалы/подтемы/секция-2.-react/тема-№18/обработка-несуществующих-маршрутов.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Обработка несуществующих маршрутов</a>\n<br><a data-href=\"Загрузка данных в маршрутах\" href=\"материалы/подтемы/секция-2.-react/тема-№18/загрузка-данных-в-маршрутах.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Загрузка данных в маршрутах</a>\n(пусто)<br><a data-href=\"Тема №19. Асинхронность в JavaScript\" href=\".html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №19. Асинхронность в JavaScript</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-2.-react/тема-№18/что-такое-маршрутизация.html","материалы/подтемы/секция-2.-react/тема-№18/react-router-—-основная-библиотека.html","материалы/подтемы/секция-2.-react/тема-№18/основные-компоненты-react-router.html","материалы/подтемы/секция-2.-react/тема-№18/параметры-маршрута.html","материалы/подтемы/секция-2.-react/тема-№18/вложенные-маршруты.html","материалы/подтемы/секция-2.-react/тема-№18/программная-навигация.html","материалы/подтемы/секция-2.-react/тема-№18/обработка-несуществующих-маршрутов.html","материалы/подтемы/секция-2.-react/тема-№18/загрузка-данных-в-маршрутах.html",".html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-2.-react/тема-№18.-routers-в-react.html","pathToRoot":"../..","attachments":[],"createdTime":1768932838850,"modifiedTime":1768934149800,"sourceSize":1123,"sourcePath":"Лекции/Секция 2. React/Тема №18. Routers в React.md","exportPath":"лекции/секция-2.-react/тема-№18.-routers-в-react.html","showInTree":true,"treeOrder":33,"backlinks":["лекции/секция-2.-react/тема-№17.-hooks-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№17/пользовательские-hooks.html":{"title":"Пользовательские Hooks","icon":"","description":"Пользовательские хуки — это функции, созданные разработчиком на основе встроенных хуков React. Они позволяют извлекать и повторно использовать логику компонентов, не дублируя код. Любой пользовательский хук должен начинаться с префикса use, чтобы React распознавал его как хук и применял правила хуков.Часто в приложении возникает повторяющаяся логика: работа с локальным хранилищем, подписка на события, обработка состояния формы, кэширование данных. Вместо того чтобы писать один и тот же код в нескольких компонентах, вы выносите его в отдельную функцию-хук.Преимущества:\nЛогика изолирована и тестируема\nКомпоненты становятся чище и короче\nПоведение легко переиспользовать\nЭтот хук инкапсулирует работу с localStorage и синхронизирует её с состоянием компонента:import { useState, useEffect } from 'react'; function useLocalStorage&lt;T&gt;(key: string, initialValue: T): [T, (value: T) =&gt; void] { const [storedValue, setStoredValue] = useState&lt;T&gt;(() =&gt; { try { const item = window.localStorage.getItem(key); return item ? JSON.parse(item) : initialValue; } catch (error) { console.error(`Ошибка при чтении ${key} из localStorage:`, error); return initialValue; } }); const setValue = (value: T) =&gt; { try { setStoredValue(value); window.localStorage.setItem(key, JSON.stringify(value)); } catch (error) { console.error(`Ошибка при записи ${key} в localStorage:`, error); } }; return [storedValue, setValue];\n}\nИспользование:function App() { const [name, setName] = useLocalStorage('userName', 'Гость'); return &lt;input value={name} onChange={(e) =&gt; setName(e.target.value)} /&gt;;\n}\nХук для отслеживания размеров окна браузера:import { useState, useEffect } from 'react'; function useWindowSize() { const [windowSize, setWindowSize] = useState({ width: window.innerWidth, height: window.innerHeight, }); useEffect(() =&gt; { const handleResize = () =&gt; { setWindowSize({ width: window.innerWidth, height: window.innerHeight, }); }; window.addEventListener('resize', handleResize); return () =&gt; window.removeEventListener('resize', handleResize); }, []); return windowSize;\n}\nИспользование:function ResponsiveComponent() { const { width } = useWindowSize(); return &lt;div&gt;Ширина окна: {width}px&lt;/div&gt;;\n} Имя всегда начинается с use\nМожет вызывать другие хуки (useState, useEffect, useContext и т.д.)\nНе принимает JSX и не возвращает JSX — только данные и функции управления ими\nДолжен быть чистым по отношению к компоненту: не зависит от конкретного UI Если логика используется только в одном месте\nЕсли она слишком специфична и не поддаётся обобщению\nЕсли проще передать колбэк или использовать пропсы\nПользовательские хуки — мощный инструмент для абстракции поведения, но их следует применять осознанно, чтобы не усложнять архитектуру без необходимости.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Зачем нужны","level":2,"id":"Зачем_нужны_0"},{"heading":"Пример: useLocalStorage","level":2,"id":"Пример_useLocalStorage_0"},{"heading":"Пример: useWindowSize","level":2,"id":"Пример_useWindowSize_0"},{"heading":"Правила создания","level":2,"id":"Правила_создания_0"},{"heading":"Когда не стоит создавать хук","level":2,"id":"Когда_не_стоит_создавать_хук_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№17/пользовательские-hooks.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768932498094,"modifiedTime":1768932627884,"sourceSize":4334,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №17/Пользовательские Hooks.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№17/пользовательские-hooks.html","showInTree":true,"treeOrder":172,"backlinks":["лекции/секция-2.-react/тема-№17.-hooks-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№17/правила-использования-hooks.html":{"title":"Правила использования Hooks","icon":"","description":"Hooks в React работают только при соблюдении двух строгих правил. Эти правила гарантируют, что React может правильно отслеживать состояние и эффекты между вызовами компонентов.Никогда не вызывайте хуки внутри условий, циклов, вложенных функций или тернарных операторов. Это нарушает порядок вызова хуков между рендерами, что приводит к ошибкам.Неправильно:if (condition) { const [state, setState] = useState(0);\n}\nПравильно:const [state, setState] = useState(0);\nЕсли вам нужно условное поведение — применяйте его внутри тела хука или после его вызова, но не вокруг самого вызова.Хуки нельзя использовать в обычных JavaScript-функциях. Их можно вызывать только:\nвнутри функционального компонента React;\nвнутри другого пользовательского хука (который сам следует этим правилам).\nЭто обеспечивает, что вся логика, связанная с состоянием и эффектами, остаётся привязанной к компонентному дереву.Все хуки (встроенные и пользовательские) должны начинаться с префикса use. Это соглашение помогает React и разработчикам распознавать, что функция использует реактовые возможности и подчиняется правилам хуков.Примеры корректных имён:\nuseState\nuseEffect\nuseLocalStorage\nuseWindowSize\nReact предоставляет линтер-правило (eslint-plugin-react-hooks), которое автоматически проверяет соблюдение этих правил. Рекомендуется всегда включать его в проект.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Правило 1: Вызывайте Hooks только на верхнем уровне","level":2,"id":"Правило_1_Вызывайте_Hooks_только_на_верхнем_уровне_0"},{"heading":"Правило 2: Вызывайте Hooks только из функциональных компонентов или других Hooks","level":2,"id":"Правило_2_Вызывайте_Hooks_только_из_функциональных_компонентов_или_других_Hooks_0"},{"heading":"Именование","level":2,"id":"Именование_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№17/правила-использования-hooks.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768931877336,"modifiedTime":1768931917065,"sourceSize":2610,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №17/Правила использования Hooks.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№17/правила-использования-hooks.html","showInTree":true,"treeOrder":173,"backlinks":["лекции/секция-2.-react/тема-№17.-hooks-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№17/что-такое-hooks.html":{"title":"Что такое Hooks","icon":"","description":"Hooks — это специальные функции, которые позволяют «подключать» возможности React к функциональным компонентам. Благодаря им вы можете использовать состояние (state), выполнять побочные эффекты (например, запросы к API), работать с референсами и другими возможностями, которые раньше были доступны только в классовых компонентах.До появления Hooks логика, связанная с состоянием или жизненным циклом, могла быть реализована только в классах. Это делало компоненты громоздкими, сложными для тестирования и переиспользования. Hooks решили эту проблему: теперь вся эта логика доступна в простых функциях, что упрощает структуру кода и способствует его повторному использованию.Основное назначение Hooks — отделить поведение от представления. Например, логика загрузки данных может быть вынесена в отдельный хук и использована в разных компонентах без дублирования кода.Важно помнить: Hooks не работают вне функциональных компонентов. Их нельзя вызывать в обычных функциях, условиях или циклах — только на верхнем уровне компонента или внутри других пользовательских хуков.Самые распространённые встроенные хуки — это useState, useEffect, useRef и useContext. Некоторые из них вы уже использовали; другие будут рассмотрены далее в этой теме.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№17/что-такое-hooks.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768931668391,"modifiedTime":1768931833339,"sourceSize":2232,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №17/Что такое Hooks.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№17/что-такое-hooks.html","showInTree":true,"treeOrder":174,"backlinks":["лекции/секция-2.-react/тема-№17.-hooks-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№17/usecontext.html":{"title":"useContext","icon":"","description":"Хук useContext предоставляет способ читать данные из React-контекста без необходимости прокидывать пропсы через каждый уровень компонентного дерева. Это особенно полезно для глобальных данных, таких как тема приложения, язык интерфейса или информация о текущем пользователе.Контекст состоит из двух частей: Провайдер (Provider) — компонент, который передаёт значение вниз по дереву. Потребитель (Consumer) — любой компонент, который получает это значение с помощью useContext.\nСначала создаётся контекст:import { createContext } from 'react'; const ThemeContext = createContext('light'); // 'light' — значение по умолчанию\nЗатем обёртываем часть приложения в провайдер:&lt;ThemeContext.Provider value=\"dark\"&gt; &lt;App /&gt;\n&lt;/ThemeContext.Provider&gt;\nВнутри любого дочернего компонента можно получить значение:import { useContext } from 'react'; function Button() { const theme = useContext(ThemeContext); return &lt;button className={theme}&gt;Кнопка&lt;/button&gt;;\n}\nuseContext уместен, когда:\nДанные нужны во многих компонентах на разных уровнях вложенности.\nИзменение данных должно вызывать перерисовку всех зависимых компонентов.\nПрокидывание пропсов становится громоздким («пропс-дриллинг»).\nТипичные сценарии:\nТемизация\nМультиязычность\nАутентификация\nГлобальные настройки\nКаждый раз, когда значение контекста изменяется, все компоненты, которые его используют, будут перерисованы — даже если они используют только часть данных. Чтобы избежать лишних рендеров:\nХраните в контексте только связанные данные (не объединяйте всё в один глобальный объект).\nРазбивайте контексты по смыслу: AuthContext, ThemeContext, LanguageContext.\nДля сложных значений используйте useMemo, чтобы сохранять ссылочную стабильность.\nПример плохой практики:// Не делайте так\n&lt;GlobalContext.Provider value={{ user, theme, lang, settings }}&gt;\nЛучше:&lt;UserContext.Provider value={user}&gt;\n&lt;ThemeContext.Provider value={theme}&gt;\nЭто позволяет компонентам подписываться только на то, что им действительно нужно.Значение по умолчанию (передаваемое в createContext) используется только если компонент не находится внутри соответствующего Provider. Оно не подходит для динамической инициализации — например, из localStorage. В таких случаях лучше управлять состоянием выше и передавать его в Provider.\nПримечание: useContext не заменяет все остальные хуки. Он решает конкретную проблему — передачу данных «сквозь» дерево. Для локального состояния по-прежнему используйте useState или useReducer.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Как работает контекст","level":2,"id":"Как_работает_контекст_0"},{"heading":"Когда использовать","level":2,"id":"Когда_использовать_0"},{"heading":"Важные ограничения","level":2,"id":"Важные_ограничения_0"},{"heading":"Значение по умолчанию","level":2,"id":"Значение_по_умолчанию_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№17/usecontext.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768932306861,"modifiedTime":1768932382688,"sourceSize":4318,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №17/useContext.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№17/usecontext.html","showInTree":true,"treeOrder":175,"backlinks":["лекции/секция-2.-react/тема-№17.-hooks-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№17/useeffect.html":{"title":"useEffect","icon":"","description":"Хук useEffect позволяет выполнять побочные эффекты в функциональных компонентах. Побочные эффекты — это действия, которые влияют на внешнюю среду или не могут быть выполнены во время чистого рендеринга: например, запросы к API, подписки на события, прямые манипуляции с DOM, таймеры и работа с внешними системами.useEffect(() =&gt; { // код побочного эффекта return () =&gt; { // опциональная функция очистки };\n}, [зависимости]);\nПервый аргумент — функция, которая содержит логику эффекта.\nВторой аргумент — массив зависимостей. Он управляет, когда эффект должен запускаться повторно.Если второй аргумент отсутствует, эффект выполняется после каждого рендера компонента.useEffect(() =&gt; { console.log('Компонент обновился');\n});\nЭто может привести к избыточным вызовам и снижению производительности — используйте осторожно.Если передать пустой массив [], эффект выполнится один раз — при монтировании компонента. Это аналог componentDidMount в классах.useEffect(() =&gt; { fetchData();\n}, []);\nЕсли в массиве перечислены переменные, эффект будет перезапускаться при изменении любого из них.useEffect(() =&gt; { document.title = `Пользователь: ${name}`;\n}, [name]);\nReact сравнивает значения зависимостей посредством строгого равенства (Object.is). Поэтому для объектов и массивов важно сохранять ссылочную стабильность (например, через useMemo или вынос в константу).Если функция внутри useffect возвращает другую функцию, React вызовет её:\nперед следующим запуском эффекта (если зависимости изменились);\nпри размонтировании компонента.\nЭто используется для отмены подписок, таймеров, слушателей и других ресурсов.Пример:useEffect(() =&gt; { const handleResize = () =&gt; console.log('Окно изменено'); window.addEventListener('resize', handleResize); return () =&gt; { window.removeEventListener('resize', handleResize); };\n}, []);\nБез очистки возможны утечки памяти или ошибки при попытке взаимодействия с уже удалённым компонентом.\nЗагрузка данных при монтировании (fetch + useState)\nПодписка на события браузера или внешние источники\nРучное обновление DOM вне React-потока\nЛогирование или аналитика\nВажно: не помещайте в useEffect логику, которую можно выразить декларативно через JSX или состояние. Эффекты должны использоваться только тогда, когда без них невозможно достичь цели.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Синтаксис","level":2,"id":"Синтаксис_0"},{"heading":"Варианты использования","level":2,"id":"Варианты_использования_0"},{"heading":"Без массива зависимостей","level":3,"id":"Без_массива_зависимостей_0"},{"heading":"Пустой массив зависимостей","level":3,"id":"Пустой_массив_зависимостей_0"},{"heading":"Зависимости указаны","level":3,"id":"Зависимости_указаны_0"},{"heading":"Очистка эффекта","level":2,"id":"Очистка_эффекта_0"},{"heading":"Распространённые случаи","level":2,"id":"Распространённые_случаи_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№17/useeffect.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768932056147,"modifiedTime":1768932222025,"sourceSize":4232,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №17/useEffect.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№17/useeffect.html","showInTree":true,"treeOrder":176,"backlinks":["лекции/секция-2.-react/тема-№17.-hooks-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№18/вложенные-маршруты.html":{"title":"Вложенные маршруты","icon":"","description":"Вложенные маршруты позволяют строить иерархическую структуру экранов, где один маршрут отображается внутри другого. Это особенно полезно для создания интерфейсов с общей оболочкой — например, панель навигации или шапка остаются неизменными, а меняется только внутренний контент.В React Router v6 вложенные маршруты определяются через свойство children у компонента &lt;Route&gt;. Родительский маршрут задаёт общую разметку, а дочерние — то, что должно отображаться внутри.Для отображения дочерних маршрутов внутри родительского компонента используется специальный компонент &lt;Outlet /&gt;.Предположим, у нас есть раздел /dashboard, который содержит подразделы: /dashboard/overview и /dashboard/settings.// App.jsx\nimport { Routes, Route } from 'react-router-dom';\nimport DashboardLayout from './pages/DashboardLayout';\nimport Overview from './pages/Overview';\nimport Settings from './pages/Settings'; function App() { return ( &lt;Routes&gt; &lt;Route path=\"/dashboard\" element={&lt;DashboardLayout /&gt;}&gt; &lt;Route index element={&lt;Overview /&gt;} /&gt; &lt;Route path=\"settings\" element={&lt;Settings /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; );\n}\nОбратите внимание:\nдочерние маршруты указываются внутри родительского &lt;Route&gt;;\nпуть settings указан без слеша — он автоматически становится частью родительского пути: /dashboard/settings;\nмаршрут с index совпадает с точным путём родителя (/dashboard).\nВнутри DashboardLayout нужно указать, куда вставлять дочерний контент:// DashboardLayout.jsx\nimport { Outlet } from 'react-router-dom'; function DashboardLayout() { return ( &lt;div&gt; &lt;nav&gt; &lt;Link to=\"/dashboard\"&gt;Обзор&lt;/Link&gt; &lt;Link to=\"/dashboard/settings\"&gt;Настройки&lt;/Link&gt; &lt;/nav&gt; &lt;main&gt; &lt;Outlet /&gt; {/* Сюда будет подставляться Overview или Settings */} &lt;/main&gt; &lt;/div&gt; );\n}\nБез &lt;Outlet /&gt; дочерние маршруты не отобразятся.\nИзбегается дублирование общей разметки (например, меню);\nЛогика навигации и структура приложения становятся нагляднее;\nПоддерживается естественная иерархия URL.\nВложенные маршруты не требуют дополнительной настройки — всё работает за счёт объявления структуры в &lt;Routes&gt;. Однако родительский компонент обязан содержать &lt;Outlet /&gt;, иначе дочерние элементы не будут отображены.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Принцип работы","level":2,"id":"Принцип_работы_0"},{"heading":"Пример: Панель управления","level":2,"id":"Пример_Панель_управления_0"},{"heading":"Компонент <code>&lt;Outlet /&gt;</code>","level":2,"id":"Компонент_`<Outlet_/>`_0"},{"heading":"Преимущества","level":2,"id":"Преимущества_0"},{"heading":"Важно","level":2,"id":"Важно_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№18/вложенные-маршруты.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768933576108,"modifiedTime":1768933795466,"sourceSize":3594,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №18/Вложенные маршруты.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№18/вложенные-маршруты.html","showInTree":true,"treeOrder":178,"backlinks":["лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№18/загрузка-данных-в-маршрутах.html":{"title":"Загрузка данных в маршрутах","icon":"","description":"Загрузка данных в маршрутах — это процесс получения информации (например, с API), необходимой для отображения конкретного экрана. В React Router v6 основной подход заключается в том, что каждый компонент маршрута отвечает за загрузку собственных данных.Наиболее распространённый способ — инициировать запрос при монтировании компонента, используя useEffect:// UserProfile.jsx\nimport { useEffect, useState } from 'react';\nimport { useParams } from 'react-router-dom'; function UserProfile() { const { userId } = useParams(); const [user, setUser] = useState(null); const [loading, setLoading] = useState(true); useEffect(() =&gt; { fetch(`/api/users/${userId}`) .then(res =&gt; res.json()) .then(data =&gt; { setUser(data); setLoading(false); }); }, [userId]); if (loading) return &lt;div&gt;Загрузка...&lt;/div&gt;; return &lt;div&gt;Имя: {user.name}&lt;/div&gt;;\n}\nКаждый маршрут сам управляет своим состоянием загрузки, ошибками и обновлением данных при изменении параметров (например, переходе от /user/1 к /user/2).Важно, чтобы данные загружались в том компоненте, который их использует. Например, если страница профиля отображает список постов пользователя, запрос к /api/users/:id/posts должен выполняться внутри UserProfile, а не в родительском компоненте. Это:\nупрощает логику;\nпредотвращает передачу ненужных пропсов;\nделает компоненты переиспользуемыми.\nНачиная с версии 6.4, React Router предлагает новый подход — loader-функции, которые выполняются до рендеринга компонента. Они позволяют загружать данные на этапе маршрутизации, а не в самом компоненте:// routes.js\nconst userLoader = async ({ params }) =&gt; { const res = await fetch(`/api/users/${params.userId}`); return res.json();\n}; &lt;Route path=\"/user/:userId\" element={&lt;UserProfile /&gt;} loader={userLoader} /&gt;\nОднако в рамках текущего курса мы фокусируемся на базовом подходе с useEffect, так как он:\nработает во всех версиях React Router v6;\nне требует дополнительной настройки роутера;\nпроще для понимания на начальном этапе. Не загружайте данные в родительском компоненте ради дочернего — это нарушает инкапсуляцию;\nОбрабатывайте ошибки загрузки (например, показывайте сообщение при 404 от API);\nИспользуйте userId из useParams() как зависимость в useEffect, чтобы обновлять данные при смене параметра.\nЭтот подход обеспечивает чёткое разделение ответственности и предсказуемое поведение при навигации.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Загрузка в компоненте маршрута","level":2,"id":"Загрузка_в_компоненте_маршрута_0"},{"heading":"Принцип инкапсуляции","level":2,"id":"Принцип_инкапсуляции_0"},{"heading":"Альтернатива: loader-функции (React Router v6.4+)","level":2,"id":"Альтернатива_loader-функции_(React_Router_v6.4+)_0"},{"heading":"Рекомендации","level":2,"id":"Рекомендации_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№18/загрузка-данных-в-маршрутах.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768934023918,"modifiedTime":1768934105541,"sourceSize":3955,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №18/Загрузка данных в маршрутах.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№18/загрузка-данных-в-маршрутах.html","showInTree":true,"treeOrder":179,"backlinks":["лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№18/обработка-несуществующих-маршрутов.html":{"title":"Обработка несуществующих маршрутов","icon":"","description":"Когда пользователь переходит по URL, который не соответствует ни одному из определённых маршрутов, приложение должно отображать страницу с сообщением об ошибке — обычно это страница «404 — Страница не найдена». React Router позволяет легко реализовать такой fallback-маршрут.В React Router для перехвата всех несуществующих путей используется специальный путь *. Он совпадает с любым URL, который не был обработан другими маршрутами.// App.jsx\nimport { Routes, Route } from 'react-router-dom';\nimport HomePage from './pages/HomePage';\nimport NotFound from './pages/NotFound'; function App() { return ( &lt;Routes&gt; &lt;Route path=\"/\" element={&lt;HomePage /&gt;} /&gt; &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt; &lt;/Routes&gt; );\n}\nВажно: маршрут с path=\"*\" должен быть последним в списке, так как &lt;Routes&gt; выбирает первый совпадающий маршрут. Если поставить его выше, он будет перехватывать все запросы.Страница NotFound может содержать:\nпонятное сообщение для пользователя;\nкнопку «На главную» или ссылку на основные разделы;\nлоготип или элементы бренда для сохранения узнаваемости.\nПример:// NotFound.jsx\nimport { Link } from 'react-router-dom'; function NotFound() { return ( &lt;div&gt; &lt;h1&gt;Страница не найдена&lt;/h1&gt; &lt;p&gt;К сожалению, такой страницы не существует.&lt;/p&gt; &lt;Link to=\"/\"&gt;Вернуться на главную&lt;/Link&gt; &lt;/div&gt; );\n} Всегда добавляйте маршрут * в конце — это улучшает пользовательский опыт и предотвращает пустой экран;\nНе используйте * для других целей (например, динамических маршрутов) — только как fallback;\nВ реальных проектах страница 404 часто стилизуется в соответствии с общим дизайном приложения.\nТакой подход делает приложение более надёжным и дружелюбным к пользователю.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Маршрут-заполнитель <code>*</code>","level":2,"id":"Маршрут-заполнитель_`*`_0"},{"heading":"Содержимое страницы 404","level":2,"id":"Содержимое_страницы_404_0"},{"heading":"Рекомендации","level":2,"id":"Рекомендации_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№18/обработка-несуществующих-маршрутов.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768933956907,"modifiedTime":1768934021084,"sourceSize":2875,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №18/Обработка несуществующих маршрутов.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№18/обработка-несуществующих-маршрутов.html","showInTree":true,"treeOrder":180,"backlinks":["лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№18/основные-компоненты-react-router.html":{"title":"Основные компоненты React Router","icon":"","description":"React Router предоставляет набор компонентов, которые вместе формируют систему навигации в приложении. Они работают только внутри контекста маршрутизатора и должны использоваться в определённой иерархии.Этот компонент создаёт корневой контекст маршрутизации, используя HTML5 History API (pushState, replaceState, popstate). Он должен оборачивать всё ваше приложение — обычно размещается в файле main.jsx или App.jsx.import { BrowserRouter } from 'react-router-dom';\nimport App from './App'; ReactDOM.createRoot(document.getElementById('root')).render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;\n);\nБез &lt;BrowserRouter&gt; другие компоненты React Router не будут работать.Компонент &lt;Routes&gt; просматривает все вложенные &lt;Route&gt; и отображает только один — тот, чей путь (path) совпадает с текущим URL. Это центральный механизм выбора компонента.Каждый &lt;Route&gt; определяет соответствие между путём и элементом:&lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt;\nВажно: element принимает JSX, а не ссылку на компонент (не element={AboutPage}); пути без слеша в начале (about) считаются относительными; всегда используйте абсолютные пути: /about.\nПример использования:import { Routes, Route } from 'react-router-dom';\nimport HomePage from './pages/HomePage';\nimport AboutPage from './pages/AboutPage'; function App() { return ( &lt;Routes&gt; &lt;Route path=\"/\" element={&lt;HomePage /&gt;} /&gt; &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt; &lt;/Routes&gt; );\n}\nКомпонент &lt;Link&gt; заменяет стандартный HTML-тег &lt;a&gt;. Он позволяет переходить по маршрутам без перезагрузки страницы.&lt;Link to=\"/about\"&gt;О нас&lt;/Link&gt;\nПри клике на &lt;Link&gt; React Router обновляет URL и перерисовывает нужный компонент, но браузер не отправляет запрос на сервер.Это расширенная версия &lt;Link&gt;, которая автоматически добавляет CSS-класс (по умолчанию active), когда текущий URL совпадает с его to.&lt;NavLink to=\"/profile\"&gt;Профиль&lt;/NavLink&gt;\nЕсли пользователь находится на /profile, элемент получит класс active. Это удобно для подсветки текущего пункта меню.Можно кастомизировать имя активного класса:&lt;NavLink to=\"/settings\" className={({ isActive }) =&gt; isActive ? 'nav-active' : 'nav-item'}\n&gt; Настройки\n&lt;/NavLink&gt;\nОсновные компоненты образуют следующую структуру:\n&lt;BrowserRouter&gt; — окружает всё приложение;\n&lt;Routes&gt; — содержит список маршрутов;\n&lt;Route&gt; — связывает путь с компонентом;\n&lt;Link&gt; / &lt;NavLink&gt; — обеспечивают навигацию между маршрутами.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"<code>&lt;BrowserRouter&gt;</code>","level":2,"id":"`<BrowserRouter>`_0"},{"heading":"<code>&lt;Routes&gt;</code> и <code>&lt;Route&gt;</code>","level":2,"id":"`<Routes>`_и_`<Route>`_0"},{"heading":"<code>&lt;Link&gt;</code>","level":2,"id":"`<Link>`_0"},{"heading":"<code>&lt;NavLink&gt;</code>","level":2,"id":"`<NavLink>`_0"},{"heading":"Для ленивых","level":2,"id":"Для_ленивых_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№18/основные-компоненты-react-router.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768933314810,"modifiedTime":1768933449202,"sourceSize":3881,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №18/Основные компоненты React Router.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№18/основные-компоненты-react-router.html","showInTree":true,"treeOrder":181,"backlinks":["лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№18/параметры-маршрута.html":{"title":"Параметры маршрута","icon":"","description":"Параметры маршрута позволяют создавать динамические URL-адреса, в которых часть пути является переменной. Это необходимо, когда одна и та же страница отображает разные данные в зависимости от входного значения — например, профиль пользователя по ID или статья по уникальному slug.В React Router динамический сегмент пути обозначается двоеточием: :имяПараметра.Примеры:\n/user/:id — путь к профилю пользователя с идентификатором id;\n/product/:slug — страница товара по человекочитаемому имени.\nТакой маршрут будет совпадать с любым значением на месте параметра:\n/user/42 → id = \"42\"\n/user/abc → id = \"abc\"\nЧтобы получить значение параметра внутри компонента, используется хук useParams() из react-router-dom.// Маршрут\n&lt;Route path=\"/user/:userId\" element={&lt;UserProfile /&gt;} /&gt; // Компонент UserProfile.jsx\nimport { useParams } from 'react-router-dom'; function UserProfile() { const { userId } = useParams(); return &lt;div&gt;Профиль пользователя: {userId}&lt;/div&gt;;\n}\nХук возвращает объект, ключи которого соответствуют именам параметров в пути. Все значения — строки.Параметры маршрута используются для:\nотображения детальной информации (пользователь, товар, статья);\nфильтрации контента (например, /category/:name);\nсоздания универсальных шаблонов страниц.\nВажно: если параметр необязательный или может отсутствовать, лучше использовать query-параметры (?id=123) или альтернативные маршруты, так как /user/:id не совпадёт с /user.React Router не проверяет тип или формат параметра. Например, /user/42 и /user/not-a-number оба будут переданы как строка. Валидацию и обработку ошибок нужно реализовывать в самом компоненте.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Динамические сегменты","level":2,"id":"Динамические_сегменты_0"},{"heading":"Извлечение параметров: <code>useParams()</code>","level":2,"id":"Извлечение_параметров_`useParams()`_0"},{"heading":"Применение","level":2,"id":"Применение_0"},{"heading":"Ограничения","level":2,"id":"Ограничения_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№18/параметры-маршрута.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768933476262,"modifiedTime":1768933531259,"sourceSize":2860,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №18/Параметры маршрута.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№18/параметры-маршрута.html","showInTree":true,"treeOrder":182,"backlinks":["лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№18/программная-навигация.html":{"title":"Программная навигация","icon":"","description":"Программная навигация — это способ изменять текущий URL и переключать экраны не через клик по &lt;Link&gt;, а из кода компонента. Это необходимо, когда переход должен происходить в ответ на действие пользователя (например, отправка формы) или системное событие (например, успешная авторизация).Для программной навигации в React Router v6 используется хук useNavigate(). Он возвращает функцию, которую можно вызвать для перехода на другой маршрут.import { useNavigate } from 'react-router-dom'; function LoginPage() { const navigate = useNavigate(); const handleLogin = () =&gt; { // имитация успешной авторизации navigate('/dashboard'); }; return ( &lt;button onClick={handleLogin}&gt; Войти &lt;/button&gt; );\n}\nnavigate('/profile');\nДобавляет новую запись в историю браузера (как обычный клик по ссылке).navigate('/home', { replace: true });\nПолезно после логина или логаута, чтобы пользователь не мог вернуться назад на страницу входа кнопкой «Назад».navigate(-1);\nАналог кнопки «Назад» в браузере. Можно также использовать navigate(1) для перехода вперёд.\nПосле успешной отправки формы (например, создания заказа);\nПри автоматическом перенаправлении (например, если пользователь не авторизован);\nВ обработчиках ошибок (например, переход на страницу 404 при отсутствии данных);\nВ модальных окнах или всплывающих уведомлениях, где нет возможности использовать &lt;Link&gt;.\nФункция navigate должна вызываться только внутри компонента, обёрнутого в &lt;BrowserRouter&gt;. Вызов вне дерева маршрутизации приведёт к ошибке.Также не рекомендуется вызывать navigate напрямую в теле компонента (на этапе рендеринга), так как это может вызвать побочные эффекты. Используйте его только в обработчиках событий или внутри useEffect при определённых условиях.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Хук <code>useNavigate()</code>","level":2,"id":"Хук_`useNavigate()`_0"},{"heading":"Основные сценарии использования","level":2,"id":"Основные_сценарии_использования_0"},{"heading":"Переход на новый путь","level":3,"id":"Переход_на_новый_путь_0"},{"heading":"Замена текущей записи в истории","level":3,"id":"Замена_текущей_записи_в_истории_0"},{"heading":"Возврат назад","level":3,"id":"Возврат_назад_0"},{"heading":"Когда использовать","level":2,"id":"Когда_использовать_0"},{"heading":"Ограничения","level":2,"id":"Ограничения_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№18/программная-навигация.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768933810314,"modifiedTime":1768933843278,"sourceSize":3238,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №18/Программная навигация.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№18/программная-навигация.html","showInTree":true,"treeOrder":183,"backlinks":["лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№18/что-такое-маршрутизация.html":{"title":"Что такое маршрутизация","icon":"","description":"Маршрутизация — это механизм, который связывает URL-адрес в браузере с конкретным компонентом пользовательского интерфейса. В приложениях на React она позволяет показывать разные экраны (например, «Главная», «Профиль», «Настройки») без перезагрузки всей страницы.SPA (Single Page Application) — это одностраничное веб-приложение, в котором весь пользовательский интерфейс загружается один раз. При переходе между разделами контент обновляется динамически, а не через загрузку нового HTML-документа с сервера. Это делает навигацию быстрой и похожей на работу нативного приложения.В отличие от традиционных многостраничных сайтов (MPA), где каждый новый URL загружает отдельный HTML-файл, SPA управляет отображением контента целиком на стороне клиента. Маршрутизация в React реализует именно такую логику: она следит за изменением адреса в строке браузера и решает, какой компонент должен быть отображён.Без маршрутизации приложение может отображать только один статичный экран. Чтобы пользователь мог переходить между разделами — например, из списка товаров на страницу конкретного товара — требуется система, которая:\nчитает текущий путь (например, /product/123);\nопределяет, какой компонент соответствует этому пути;\nотображает его в нужном месте интерфейса.\nМаршрутизация также обеспечивает:\nкорректную работу кнопок «Назад» и «Вперёд» в браузере;\nвозможность делиться ссылками на конкретные экраны;\nчёткую структуру навигации в коде.\nВ React для этих целей используется библиотека React Router.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Что такое SPA","level":2,"id":"Что_такое_SPA_0"},{"heading":"Зачем нужна маршрутизация","level":2,"id":"Зачем_нужна_маршрутизация_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№18/что-такое-маршрутизация.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768932909635,"modifiedTime":1768933004357,"sourceSize":2786,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №18/Что такое маршрутизация.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№18/что-такое-маршрутизация.html","showInTree":true,"treeOrder":184,"backlinks":["лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№18/react-router-—-основная-библиотека.html":{"title":"React Router — основная библиотека","icon":"","description":"React Router — это официальная и наиболее распространённая библиотека маршрутизации для приложений на React. Она позволяет сопоставлять URL-адреса с компонентами, управлять историей навигации и реализовывать сложные сценарии вроде вложенных маршрутов или динамических параметров.Для использования React Router в проекте необходимо установить пакет react-router-dom. Это версия библиотеки, предназначенная для веб-приложений (в отличие от react-router-native для React Native).npm install react-router-dom\nПосле установки вы можете импортировать необходимые компоненты и хуки из react-router-dom:import { BrowserRouter, Routes, Route, Link } from 'react-router-dom';\nВ рамках курса используется React Router v6 — текущая стабильная версия, которая значительно отличается от предыдущих (особенно v5). Основные изменения:\nвместо пропса component теперь используется element;\nобязательное использование &lt;Routes&gt; (ранее &lt;Switch&gt;);\nупрощённый синтаксис для вложенных маршрутов;\nновые хуки: useNavigate, useParams, useLocation.\nУбедитесь, что в вашем проекте установлена именно версия 6.x, так как примеры из лекций не будут работать с более старыми версиями.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Установка","level":2,"id":"Установка_0"},{"heading":"Поддержка версий","level":2,"id":"Поддержка_версий_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№18/react-router-—-основная-библиотека.html","pathToRoot":"../../../..","attachments":[],"createdTime":1768933056845,"modifiedTime":1768933288916,"sourceSize":2002,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №18/React Router — основная библиотека.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№18/react-router-—-основная-библиотека.html","showInTree":true,"treeOrder":185,"backlinks":["лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"type":"markdown"},"лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html":{"title":"Тема №19. Асинхронность в JavaScript","icon":"","description":"В этой теме вы изучите асинхронное выполнение кода в JavaScript — механизм, позволяющий выполнять длительные операции (например, запросы к серверу, чтение файлов, таймеры) без блокировки основного потока. Поймёте, как работают коллбэки, промисы и async/await, и как правильно обрабатывать результаты асинхронных действий. Это фундамент для работы с API, загрузки данных и управления состоянием в мобильных приложениях.\n<a data-href=\"Что такое асинхронность\" href=\"материалы/подтемы/секция-2.-react/тема-№19/что-такое-асинхронность.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Что такое асинхронность</a>\n<br><a data-href=\"Коллбэки\" href=\"материалы/подтемы/секция-2.-react/тема-№19/коллбэки.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Коллбэки</a>\n<br><a data-href=\"Промисы (Promise)\" href=\"материалы/подтемы/секция-2.-react/тема-№19/промисы-(promise).html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Промисы (Promise)</a>\n<br><a data-href=\"Async и await\" href=\"материалы/подтемы/секция-2.-react/тема-№19/async-и-await.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Async и await</a>\n<br><a data-href=\"Разница между await и then()\" href=\"материалы/подтемы/секция-2.-react/тема-№19/разница-между-await-и-then().html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Разница между await и then()</a>\n<br><a data-href=\"Асинхронность и React\" href=\"материалы/подтемы/секция-2.-react/тема-№19/асинхронность-и-react.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Асинхронность и React</a>\n(пусто)<br><a data-href=\"Тема №20. Основы TypeScript\" href=\"лекции/секция-2.-react/тема-№20.-основы-typescript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №20. Основы TypeScript</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-2.-react/тема-№19/что-такое-асинхронность.html","материалы/подтемы/секция-2.-react/тема-№19/коллбэки.html","материалы/подтемы/секция-2.-react/тема-№19/промисы-(promise).html","материалы/подтемы/секция-2.-react/тема-№19/async-и-await.html","материалы/подтемы/секция-2.-react/тема-№19/разница-между-await-и-then().html","материалы/подтемы/секция-2.-react/тема-№19/асинхронность-и-react.html","лекции/секция-2.-react/тема-№20.-основы-typescript.html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html","pathToRoot":"../..","attachments":[],"createdTime":1770183889581,"modifiedTime":1770185338647,"sourceSize":1168,"sourcePath":"Лекции/Секция 2. React/Тема №19. Асинхронность в JavaScript.md","exportPath":"лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html","showInTree":true,"treeOrder":34,"backlinks":["лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"type":"markdown"},"лекции/секция-2.-react/тема-№20.-основы-typescript.html":{"title":"Тема №20. Основы TypeScript","icon":"","description":"В этой теме вы познакомитесь с TypeScript как языком, расширяющим JavaScript статической типизацией. Поймёте, зачем он нужен, как он соотносится с JavaScript и почему его используют в крупных проектах. Вы узнаете, как TypeScript транспилируется в JavaScript, и научитесь писать базовый типизированный код без углубления в сложные конструкции.\n<a data-href=\"Что такое TypeScript\" href=\"материалы/подтемы/секция-2.-react/тема-№20/что-такое-typescript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Что такое TypeScript</a>\n<br><a data-href=\"Настройка проекта с TypeScript\" href=\"материалы/подтемы/секция-2.-react/тема-№20/настройка-проекта-с-typescript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Настройка проекта с TypeScript</a>\n<br><a data-href=\"Базовые типы в TypeScript\" href=\"материалы/подтемы/секция-2.-react/тема-№20/базовые-типы-в-typescript.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Базовые типы в TypeScript</a>\n(пусто)<br><a data-href=\"Тема №21. Типизация структур данных в TypeScript\" href=\".html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тема №21. Типизация структур данных в TypeScript</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Описание темы","level":2,"id":"Описание_темы_0"},{"heading":"План темы","level":2,"id":"План_темы_0"},{"heading":"Задания связанные с темой","level":2,"id":"Задания_связанные_с_темой_0"},{"heading":"Следующая тема","level":2,"id":"Следующая_тема_0"}],"links":["материалы/подтемы/секция-2.-react/тема-№20/что-такое-typescript.html","материалы/подтемы/секция-2.-react/тема-№20/настройка-проекта-с-typescript.html","материалы/подтемы/секция-2.-react/тема-№20/базовые-типы-в-typescript.html",".html"],"author":"","coverImageURL":"","fullURL":"лекции/секция-2.-react/тема-№20.-основы-typescript.html","pathToRoot":"../..","attachments":[],"createdTime":1770185322208,"modifiedTime":1770187494694,"sourceSize":956,"sourcePath":"Лекции/Секция 2. React/Тема №20. Основы TypeScript.md","exportPath":"лекции/секция-2.-react/тема-№20.-основы-typescript.html","showInTree":true,"treeOrder":35,"backlinks":["лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№19/асинхронность-и-react.html":{"title":"Асинхронность и React","icon":"","description":"В React асинхронные операции, такие как загрузка данных с сервера, должны выполняться в правильном месте жизненного цикла компонента. Неправильное использование асинхронности может привести к ошибкам, утечкам памяти или обновлению состояния в уже размонтированном компоненте.В функциональных компонентах асинхронный код запускается внутри хука useEffect. Это гарантирует, что операция выполнится в нужный момент — например, при монтировании компонента или при изменении зависимостей.import { useEffect, useState } from 'react'; function UserProfile({ userId }) { const [user, setUser] = useState(null); const [loading, setLoading] = useState(true); useEffect(() =&gt; { const fetchUser = async () =&gt; { try { const response = await fetch(`/api/users/${userId}`); const data = await response.json(); setUser(data); } catch (error) { console.error('Ошибка загрузки пользователя:', error); } finally { setLoading(false); } }; fetchUser(); }, [userId]); // Зависимость: перезапускать при смене userId if (loading) return &lt;div&gt;Загрузка...&lt;/div&gt;; return &lt;div&gt;Имя: {user?.name}&lt;/div&gt;;\n}\nСледующий код недопустим:// Ошибка: нельзя использовать await вне async-функции\nconst data = await fetch('/api/data');\nКомпонент React — это обычная функция, и она должна синхронно возвращать JSX. Асинхронная логика должна быть изолирована внутри useEffect или вспомогательных функций.Если компонент размонтируется до завершения запроса, попытка обновить его состояние вызовет предупреждение. Чтобы этого избежать, можно использовать флаг:useEffect(() =&gt; { let isMounted = true; const fetchUser = async () =&gt; { const data = await fetch(`/api/users/${userId}`).then(r =&gt; r.json()); if (isMounted) { setUser(data); } }; fetchUser(); return () =&gt; { isMounted = false; // cleanup при размонтировании };\n}, [userId]);\nВ большинстве случаев React Native подавляет такие ошибки, но хорошая практика — предотвращать их явно.При асинхронных операциях рекомендуется управлять тремя состояниями:\nloading — идёт загрузка\ndata — успешный результат\nerror — произошла ошибка\nЭто улучшает UX и помогает избежать неопределённого поведения.\nВсе побочные эффекты (запросы, подписки, таймеры) — только в useEffect\nАсинхронная функция внутри useEffect должна быть объявлена отдельно или как немедленно вызываемая стрелочная функция\nНе забывайте указывать зависимости в массиве useEffect, чтобы избежать устаревших замыканий\nИзбегайте запуска асинхронных операций в обработчиках рендера (например, прямо в теле компонента)\nАсинхронность в React требует дисциплины, но при правильном подходе делает приложения отзывчивыми и надёжными.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Где выполнять асинхронные операции","level":2,"id":"Где_выполнять_асинхронные_операции_0"},{"heading":"Почему нельзя использовать <code>await</code> напрямую в компоненте","level":2,"id":"Почему_нельзя_использовать_`await`_напрямую_в_компоненте_0"},{"heading":"Обработка размонтирования","level":2,"id":"Обработка_размонтирования_0"},{"heading":"Работа с состоянием","level":2,"id":"Работа_с_состоянием_0"},{"heading":"Важно помнить","level":2,"id":"Важно_помнить_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№19/асинхронность-и-react.html","pathToRoot":"../../../..","attachments":[],"createdTime":1770185252130,"modifiedTime":1770185308280,"sourceSize":4532,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №19/Асинхронность и React.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№19/асинхронность-и-react.html","showInTree":true,"treeOrder":189,"backlinks":["лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№19/коллбэки.html":{"title":"Коллбэки","icon":"","description":"Коллбэк (callback) — это функция, передаваемая в другую функцию как аргумент и вызываемая позже, когда завершится какая-то операция. Коллбэки были первым способом обработки асинхронных операций в JavaScript.Функция, принимающая коллбэк, вызывает его в нужный момент — например, после получения данных или истечения таймера. Это позволяет «подписаться» на завершение операции.function fetchData(callback) { setTimeout(() =&gt; { const data = { id: 1, name: 'Пример' }; callback(data); }, 1000);\n} fetchData((result) =&gt; { console.log('Получены данные:', result);\n});\nЗдесь fetchData имитирует задержку, а затем вызывает переданный коллбэк с данными.Когда нужно выполнить несколько асинхронных операций последовательно, код быстро становится вложенным и трудночитаемым:getData((a) =&gt; { getMoreData(a, (b) =&gt; { getEvenMoreData(b, (c) =&gt; { getFinalData(c, (d) =&gt; { console.log(d); }); }); });\n});\nТакой стиль усложняет понимание логики, отладку и рефакторинг.В коллбэках нет единого механизма обработки ошибок. Часто используется соглашение: первый аргумент — ошибка, второй — данные:fs.readFile('file.txt', (err, data) =&gt; { if (err) { console.error('Ошибка:', err); return; } console.log(data);\n});\nНо если забыть проверить err, ошибка может остаться незамеченной.Код перестаёт читаться сверху вниз. Вместо последовательных шагов появляются вложенные блоки, что затрудняет восприятие потока выполнения.Несмотря на недостатки, коллбэки всё ещё применяются:\nВ событиях: button.addEventListener('click', handler)\nВ некоторых API React Native (например, обратные вызовы в нативных модулях)\nВ устаревших библиотеках\nОднако для новых проектов рекомендуется использовать промисы или async/await.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Как работают коллбэки","level":2,"id":"Как_работают_коллбэки_0"},{"heading":"Проблемы коллбэков","level":2,"id":"Проблемы_коллбэков_0"},{"heading":"Ад коллбэков (Callback Hell)","level":3,"id":"Ад_коллбэков_(Callback_Hell)_0"},{"heading":"Сложность обработки ошибок","level":3,"id":"Сложность_обработки_ошибок_0"},{"heading":"Нарушение линейности кода","level":3,"id":"Нарушение_линейности_кода_0"},{"heading":"Когда ещё используют коллбэки","level":2,"id":"Когда_ещё_используют_коллбэки_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№19/коллбэки.html","pathToRoot":"../../../..","attachments":[],"createdTime":1770184096190,"modifiedTime":1770184157255,"sourceSize":3111,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №19/Коллбэки.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№19/коллбэки.html","showInTree":true,"treeOrder":190,"backlinks":["лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№19/промисы-(promise).html":{"title":"Промисы (Promise)","icon":"","description":"Промис (Promise) — это встроенный в JavaScript объект, который представляет результат асинхронной операции, которая может завершиться успешно или с ошибкой. Промисы были созданы для решения проблем коллбэков и обеспечения более читаемого и управляемого асинхронного кода.Любой промис может находиться в одном из трёх состояний:\npending — начальное состояние, операция ещё не завершена\nfulfilled — операция завершилась успешно, значение доступно\nrejected — операция завершилась с ошибкой, причина ошибки доступна\nСостояние промиса меняется только один раз: из pending либо в fulfilled, либо в rejected. После этого оно остаётся неизменным.Промис создаётся с помощью конструктора new Promise(), которому передаётся функция-исполнитель (executor):const myPromise = new Promise((resolve, reject) =&gt; { // Имитация асинхронной операции setTimeout(() =&gt; { const success = true; if (success) { resolve('Данные получены'); } else { reject(new Error('Не удалось получить данные')); } }, 1000);\n});\nФункция получает два параметра:\nresolve(value) — вызывается при успешном завершении\nreject(error) — вызывается при ошибке\nДля работы с результатом промиса используются методы:Вызывается, если промис выполнен успешно:myPromise.then((result) =&gt; { console.log(result); // 'Данные получены'\n});\nВызывается, если промис отклонён:myPromise.catch((error) =&gt; { console.error(error.message); // 'Не удалось получить данные'\n});\nВызывается в любом случае — как при успехе, так и при ошибке. Часто используется для очистки (например, скрыть индикатор загрузки):myPromise .then(console.log) .catch(console.error) .finally(() =&gt; console.log('Операция завершена'));\nМетод .then() возвращает новый промис, что позволяет строить цепочки:fetchUserData() .then(user =&gt; fetchUserPosts(user.id)) .then(posts =&gt; processPosts(posts)) .then(result =&gt; console.log(result)) .catch(error =&gt; console.error('Ошибка:', error));\nКаждый шаг может возвращать значение или другой промис. Если в цепочке возникает ошибка, выполнение переходит к ближайшему .catch().\nКод становится линейным и читаемым\nОшибки обрабатываются централизованно через .catch()\nЛегко комбинировать несколько асинхронных операций\nИзбегается «ад коллбэков» Промисы не отменяются после создания\nНельзя узнать текущее состояние промиса напрямую (только через обработчики)\nЕсли не вызвать .catch(), ошибка может остаться незамеченной (в современных средах такие ошибки логируются в консоль)\nПромисы стали стандартом для асинхронных операций в JavaScript и лежат в основе более современного синтаксиса async/await.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Состояния промиса","level":2,"id":"Состояния_промиса_0"},{"heading":"Создание промиса","level":2,"id":"Создание_промиса_0"},{"heading":"Обработка результата","level":2,"id":"Обработка_результата_0"},{"heading":"<code>.then()</code>","level":3,"id":"`.then()`_0"},{"heading":"<code>.catch()</code>","level":3,"id":"`.catch()`_0"},{"heading":"<code>.finally()</code>","level":3,"id":"`.finally()`_0"},{"heading":"Цепочка промисов","level":2,"id":"Цепочка_промисов_0"},{"heading":"Преимущества перед коллбэками","level":2,"id":"Преимущества_перед_коллбэками_0"},{"heading":"Важно помнить","level":2,"id":"Важно_помнить_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№19/промисы-(promise).html","pathToRoot":"../../../..","attachments":[],"createdTime":1770184294102,"modifiedTime":1770184443324,"sourceSize":4561,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №19/Промисы (Promise).md","exportPath":"материалы/подтемы/секция-2.-react/тема-№19/промисы-(promise).html","showInTree":true,"treeOrder":191,"backlinks":["лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№19/разница-между-await-и-then().html":{"title":"Разница между await и then()","icon":"","description":"await и .then() — это два способа работы с промисами, но они отличаются по стилю, читаемости и поведению.С .then() код строится в виде цепочки:fetchData() .then(data =&gt; processData(data)) .then(result =&gt; saveResult(result)) .catch(error =&gt; console.error(error));\nС await код выглядит как последовательный синхронный:try { const data = await fetchData(); const result = processData(data); await saveResult(result);\n} catch (error) { console.error(error);\n}\nВторой вариант легче читать, особенно при наличии условий, циклов или нескольких переменных.При использовании .then() каждое значение доступно только внутри соответствующего колбэка. Чтобы использовать результат на следующем шаге, нужно возвращать его явно:fetchUser() .then(user =&gt; { return fetchPosts(user.id); // без return — undefined }) .then(posts =&gt; console.log(posts));\nС await значения сохраняются в обычные переменные и доступны на любом этапе функции:const user = await fetchUser();\nconst posts = await fetchPosts(user.id);\nconsole.log(posts);\nС .then() ошибку ловит отдельный .catch() в конце цепочки. Если ошибка возникает в любом .then(), она передаётся дальше до .catch().С await используется стандартный try/catch, что позволяет обрабатывать ошибки точно так же, как в синхронном коде, и даже применять разные блоки catch для разных участков.Функция с .then() требует аккуратного возврата промиса, чтобы результат был доступен снаружи:function getUserData() { return fetchUser().then(user =&gt; { return { ...user, loadedAt: Date.now() }; });\n}\nС async/await возврат происходит естественно:async function getUserData() { const user = await fetchUser(); return { ...user, loadedAt: Date.now() };\n}\nОбе функции возвращают промис, но второй вариант проще понять.\nПри работе с параллельными операциями на верхнем уровне:\nPromise.all([a(), b()]).then(([resA, resB]) =&gt; { ... }); В обработчиках событий, где неудобно создавать отдельную async-функцию:\nbutton.addEventListener('click', () =&gt; fetchData().then(showData)); Однако даже в этих случаях можно использовать стрелочную async-функцию.Используйте async/await по умолчанию. Он делает код линейным, упрощает отладку и совместим со всеми возможностями JavaScript. Резервируйте .then() только для специфических случаев, где он действительно короче или удобнее.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Стиль написания кода","level":2,"id":"Стиль_написания_кода_0"},{"heading":"Обработка значений","level":2,"id":"Обработка_значений_0"},{"heading":"Обработка ошибок","level":2,"id":"Обработка_ошибок_0"},{"heading":"Возврат из функции","level":2,"id":"Возврат_из_функции_0"},{"heading":"Когда может быть уместен <code>.then()</code>","level":2,"id":"Когда_может_быть_уместен_`.then()`_0"},{"heading":"Рекомендация","level":2,"id":"Рекомендация_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№19/разница-между-await-и-then().html","pathToRoot":"../../../..","attachments":[],"createdTime":1770184978257,"modifiedTime":1770185010168,"sourceSize":3825,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №19/Разница между await и then().md","exportPath":"материалы/подтемы/секция-2.-react/тема-№19/разница-между-await-и-then().html","showInTree":true,"treeOrder":192,"backlinks":["лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№19/что-такое-асинхронность.html":{"title":"Что такое асинхронность","icon":"","description":"Асинхронность — это способ выполнения кода, при котором длительные операции (например, запрос к серверу или таймер) не останавливают выполнение остальной программы. В JavaScript основной поток выполнения единственный, поэтому без асинхронности интерфейс «зависал» бы при каждой задержке.Если бы JavaScript был полностью синхронным, то при выполнении операции вроде fetch() весь интерфейс перестал бы отвечать, пока не пришёл ответ. Асинхронность позволяет продолжать взаимодействие с приложением: пользователь может кликать, скроллить и вводить данные, даже если фоновая задача ещё не завершена.\nЗапросы к API через fetch или axios\nЧтение или запись в файловую систему (в средах, где это доступно)\nТаймеры: setTimeout, setInterval\nСобытия: клики, ввод текста, загрузка изображений\nJavaScript использует событийную петлю (event loop). Когда встречается асинхронная операция, она передаётся в браузерное API или среду выполнения (например, Node.js или React Native), а основной поток продолжает работу. Как только операция завершается, её результат помещается в очередь задач, и движок обрабатывает его, когда основной стек вызовов свободен.Это означает, что асинхронный код не выполняется параллельно, но он не блокирует выполнение других инструкций.console.log('Начало'); setTimeout(() =&gt; { console.log('Таймер сработал');\n}, 1000); console.log('Конец');\nВывод:Начало\nКонец\nТаймер сработал\nСтрока 'Таймер сработал' появляется последней, потому что setTimeout — асинхронная функция. Она не ждёт, пока пройдёт секунда, а сразу возвращает управление, позволяя выполниться следующей строке.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Почему это важно","level":2,"id":"Почему_это_важно_0"},{"heading":"Примеры асинхронных операций","level":2,"id":"Примеры_асинхронных_операций_0"},{"heading":"Как это работает в JavaScript","level":2,"id":"Как_это_работает_в_JavaScript_0"},{"heading":"Простой пример","level":2,"id":"Простой_пример_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№19/что-такое-асинхронность.html","pathToRoot":"../../../..","attachments":[],"createdTime":1770183949864,"modifiedTime":1770184027402,"sourceSize":2986,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №19/Что такое асинхронность.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№19/что-такое-асинхронность.html","showInTree":true,"treeOrder":193,"backlinks":["лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№19/async-и-await.html":{"title":"Async и await","icon":"","description":"async/await — это синтаксический сахар над промисами, который позволяет писать асинхронный код так, будто он синхронный. Он делает код проще для чтения и отладки, сохраняя при этом все преимущества промисов.Функция, содержащая await, должна быть помечена ключевым словом async. Такая функция всегда возвращает промис:async function fetchData() { const response = await fetch('https://api.example.com/data'); const data = await response.json(); return data; // эквивалентно resolve(data)\n}\nВызов этой функции:fetchData().then(data =&gt; console.log(data));\nИли внутри другой async-функции:async function handleData() { const data = await fetchData(); console.log(data);\n}\nКлючевое слово await приостанавливает выполнение только внутри текущей async-функции, пока промис не завершится. При этом основной поток выполнения не блокируется — другие задачи продолжают работать.async function example() { console.log('Начало'); await new Promise(resolve =&gt; setTimeout(resolve, 1000)); console.log('Прошла секунда');\n}\nВывод:Начало\n(через 1 секунду) Прошла секунда\nОшибки в async/await обрабатываются с помощью стандартного try/catch:async function safeFetch() { try { const response = await fetch('https://api.example.com/data'); if (!response.ok) throw new Error('Сервер вернул ошибку'); const data = await response.json(); return data; } catch (error) { console.error('Не удалось загрузить данные:', error.message); throw error; // можно пробросить дальше, если нужно }\n}\nЭто гораздо удобнее, чем .catch() в цепочках промисов, особенно при сложной логике.\nawait можно использовать только внутри функций, объявленных как async\nНельзя использовать await на верхнем уровне модуля (вне функции), если только не используется top-level await (поддержка зависит от окружения; в React Native — не рекомендуется)\nasync-функция всегда возвращает промис, даже если в ней нет await\nПоследовательно (медленно):async function loadSequentially() { const user = await fetchUser(); const posts = await fetchPosts(user.id); return { user, posts };\n}\nПараллельно (быстро):async function loadInParallel() { const userPromise = fetchUser(); const postsPromise = fetchPosts(); // предположим, что ID не нужен сразу const user = await userPromise; const posts = await postsPromise; return { user, posts };\n}\nИли с Promise.all:async function loadWithAll() { const [user, posts] = await Promise.all([fetchUser(), fetchPosts()]); return { user, posts };\n}\nИспользуйте async/await в большинстве случаев — он проще, читаемее и лучше сочетается с обычными конструкциями языка (if, for, try/catch). Избегайте смешивания .then() и await в одном блоке кода без веской причины.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Основной синтаксис","level":2,"id":"Основной_синтаксис_0"},{"heading":"Как работает <code>await</code>","level":2,"id":"Как_работает_`await`_0"},{"heading":"Обработка ошибок","level":2,"id":"Обработка_ошибок_0"},{"heading":"Важные ограничения","level":2,"id":"Важные_ограничения_0"},{"heading":"Пример: последовательная и параллельная загрузка","level":2,"id":"Пример_последовательная_и_параллельная_загрузка_0"},{"heading":"Рекомендация","level":2,"id":"Рекомендация_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№19/async-и-await.html","pathToRoot":"../../../..","attachments":[],"createdTime":1770184677448,"modifiedTime":1770184729992,"sourceSize":4264,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №19/Async и await.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№19/async-и-await.html","showInTree":true,"treeOrder":194,"backlinks":["лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№20/базовые-типы-в-typescript.html":{"title":"Базовые типы в TypeScript","icon":"","description":"TypeScript предоставляет систему типов, которая позволяет явно указывать или автоматически выводить типы переменных, параметров функций и возвращаемых значений. Это помогает избежать ошибок и делает код понятнее.Основные примитивные типы в TypeScript совпадают с соответствующими значениями в JavaScript:\nstring — текстовые данные number — числа (все числа в JS/TS имеют тип number, целые и дробные) boolean — логические значения (true / false) null — отсутствие значения (явный null) undefined — значение по умолчанию для неинициализированных переменных Пример:let name: string = \"Alice\";\nlet age: number = 30;\nlet isActive: boolean = true;\nTypeScript обычно выводит эти типы автоматически, поэтому явное указание часто избыточно:let name = \"Alice\"; // TypeScript выводит: string\nТип any отключает проверку типов. Переменная типа any может принимать любое значение и использоваться в любом контексте:let data: any = \"text\";\ndata = 42; // допустимо\ndata.toUpperCase(); // допустимо, но может вызвать ошибку во время выполнения\nИспользование any нарушает преимущества TypeScript и рекомендуется только при миграции старого кода или работе с динамическими данными, когда тип невозможно определить.Тип unknown представляет значение, тип которого неизвестен. В отличие от any, он безопасен: TypeScript требует проверки перед использованием:let data: unknown = \"text\"; // Ошибка: нельзя вызывать методы на unknown без проверки\n// data.toUpperCase(); if (typeof data === \"string\") { console.log(data.toUpperCase()); // теперь безопасно\n}\nunknown — предпочтительная замена any при работе с внешними данными (например, ответами от API).Тип void означает, что функция ничего не возвращает:function logMessage(message: string): void { console.log(message);\n}\nЕсли функция не имеет оператора return или содержит return; без значения, её тип возвращаемого значения — void.Тип never используется для функций, которые никогда не завершаются нормально — например, всегда выбрасывают ошибку или зацикливаются:function throwError(message: string): never { throw new Error(message);\n} function infiniteLoop(): never { while (true) {}\n}\nТип never также возникает в случае исчерпывающей проверки типов (например, в switch), но это выходит за рамки базового уровня.TypeScript автоматически выводит типы на основе присвоенных значений:let count = 10; // тип: number\nЯвное указание типа требуется, когда значение неизвестно на этапе инициализации или когда нужно сузить тип:let userId: string; // пока undefined, но позже получит строку\nuserId = fetchUserId(); // функция возвращает string // Или при работе с DOM:\nconst button = document.getElementById(\"submit\") as HTMLButtonElement;\nЯвная типизация особенно полезна в сигнатурах функций и интерфейсах, чтобы чётко определить контракт между частями программы.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Примитивные типы","level":2,"id":"Примитивные_типы_0"},{"heading":"Специальные типы","level":2,"id":"Специальные_типы_0"},{"heading":"<code>any</code>","level":3,"id":"`any`_0"},{"heading":"<code>unknown</code>","level":3,"id":"`unknown`_0"},{"heading":"<code>void</code>","level":3,"id":"`void`_0"},{"heading":"<code>never</code>","level":3,"id":"`never`_0"},{"heading":"Вывод и явное указание типов","level":2,"id":"Вывод_и_явное_указание_типов_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№20/базовые-типы-в-typescript.html","pathToRoot":"../../../..","attachments":[],"createdTime":1770187183900,"modifiedTime":1770187186558,"sourceSize":4761,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №20/Базовые типы в TypeScript.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№20/базовые-типы-в-typescript.html","showInTree":true,"treeOrder":196,"backlinks":["лекции/секция-2.-react/тема-№20.-основы-typescript.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№20/настройка-проекта-с-typescript.html":{"title":"Настройка проекта с TypeScript","icon":"","description":"Чтобы начать использовать TypeScript, необходимо настроить проект: установить компилятор, создать конфигурационный файл и (при необходимости) интегрировать TypeScript в существующий фреймворк, например React.TypeScript поставляется как пакет npm. Его можно установить глобально или локально в проекте. Рекомендуется устанавливать локально:npm install --save-dev typescript\nПосле установки доступна команда npx tsc для запуска компилятора.Файл tsconfig.json управляет поведением компилятора TypeScript. Он указывает, какие файлы обрабатывать и как транспилировать код. Создать его можно командой:npx tsc --init\nЭта команда генерирует базовый файл с закомментированными настройками. Основные опции:\ntarget — версия JavaScript, в которую будет транспилироваться код (например, \"ES2016\", \"ES2020\").\noutDir — папка, куда будут помещены скомпилированные .js-файлы.\nstrict — включает строгую проверку типов (рекомендуется всегда использовать).\nПример минимального tsconfig.json:{ \"compilerOptions\": { \"target\": \"ES2020\", \"module\": \"commonjs\", \"strict\": true, \"outDir\": \"./dist\", \"rootDir\": \"./src\" }, \"include\": [\"src/**/*\"]\n}\nПосле настройки можно компилировать проект командой:npx tsc\nДля новых проектов на React проще всего использовать шаблоны с поддержкой TypeScript:\nС Vite:\nnpm create vite@latest my-app -- --template react-ts С Create React App:\nnpx create-react-app my-app --template typescript Такие шаблоны уже содержат необходимые зависимости (typescript, @types/react, @types/node и др.) и готовый tsconfig.json.В уже существующем React-проекте можно добавить TypeScript вручную, но это требует установки типов и настройки сборки — поэтому для обучения предпочтительнее начинать с шаблонов.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Установка компилятора TypeScript","level":2,"id":"Установка_компилятора_TypeScript_0"},{"heading":"Конфигурационный файл tsconfig.json","level":2,"id":"Конфигурационный_файл_tsconfig.json_0"},{"heading":"Использование TypeScript в React-проектах","level":2,"id":"Использование_TypeScript_в_React-проектах_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№20/настройка-проекта-с-typescript.html","pathToRoot":"../../../..","attachments":[],"createdTime":1770187166243,"modifiedTime":1770187168992,"sourceSize":3012,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №20/Настройка проекта с TypeScript.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№20/настройка-проекта-с-typescript.html","showInTree":true,"treeOrder":197,"backlinks":["лекции/секция-2.-react/тема-№20.-основы-typescript.html"],"type":"markdown"},"материалы/подтемы/секция-2.-react/тема-№20/что-такое-typescript.html":{"title":"Что такое TypeScript","icon":"","description":"TypeScript — это язык программирования, разработанный компанией Microsoft как надмножество JavaScript. Он добавляет к JavaScript статическую типизацию и другие возможности, которые помогают писать более надёжный и поддерживаемый код. Любая программа на JavaScript является корректной программой на TypeScript, что делает переход к нему постепенным и безопасным.В JavaScript типы переменных определяются во время выполнения (динамическая типизация). Это даёт гибкость, но может привести к ошибкам, которые проявляются только при запуске программы:function greet(name) { return \"Hello, \" + name.toUpperCase();\n}\ngreet(); // вызов без аргумента → ошибка во время выполнения\nTypeScript проверяет типы ещё до запуска программы (статическая типизация). Ошибки выявляются на этапе написания кода или сборки:function greet(name: string) { return \"Hello, \" + name.toUpperCase();\n}\ngreet(); // ошибка компиляции: отсутствует обязательный аргумент\nTypeScript не заменяет JavaScript. Наоборот, он полностью совместим с ним:\nЛюбой JavaScript-файл можно переименовать в .ts — он останется рабочим.\nВсе существующие библиотеки JavaScript можно использовать в TypeScript.\nTypeScript добавляет синтаксис для описания типов, но не меняет поведение самого языка.\nБраузеры и среды выполнения (например, Node.js) понимают только JavaScript. Поэтому код на TypeScript должен быть преобразован (транспилирован) в JavaScript перед запуском. Это делает компилятор TypeScript (tsc):Исходный файл app.ts:const message: string = \"Hello, TypeScript\";\nconsole.log(message);\nПосле компиляции (tsc app.ts) получается app.js:var message = \"Hello, TypeScript\";\nconsole.log(message);\nТипы исчезают — они нужны только на этапе разработки.\nРаннее обнаружение ошибок: многие ошибки находятся ещё до запуска программы.\nЛучшее автодополнение: редакторы (VS Code, WebStorm и др.) предлагают точные подсказки благодаря информации о типах.\nСамодокументируемый код: типы явно описывают, какие данные ожидаются и возвращаются.\nПоддержка крупных проектов: упрощает рефакторинг и чтение чужого кода.\nTypeScript особенно полезен в командной разработке и при создании сложных приложений, где важно минимизировать количество неожиданных ошибок.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Статическая и динамическая типизация","level":2,"id":"Статическая_и_динамическая_типизация_0"},{"heading":"TypeScript — расширение, а не замена","level":2,"id":"TypeScript_—_расширение,_а_не_замена_0"},{"heading":"Транспиляция в JavaScript","level":2,"id":"Транспиляция_в_JavaScript_0"},{"heading":"Преимущества использования TypeScript","level":2,"id":"Преимущества_использования_TypeScript_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"материалы/подтемы/секция-2.-react/тема-№20/что-такое-typescript.html","pathToRoot":"../../../..","attachments":[],"createdTime":1770187025327,"modifiedTime":1770187381207,"sourceSize":3926,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №20/Что такое TypeScript.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№20/что-такое-typescript.html","showInTree":true,"treeOrder":198,"backlinks":["лекции/секция-2.-react/тема-№20.-основы-typescript.html"],"type":"markdown"},"задания/секция-2.-react/практика-№11.-игра-кликер.html":{"title":"Практика №11. Игра-кликер","icon":"","description":"Разработать одностраничное веб-приложение «Кликер».\nОно обязано быть сделано при помощи React (vite), следовать правильному неймингу и иметь правильную структуру.\nПриложение должно содержать игровое поле с персонажем, систему сбора монет, магазин улучшений и сохранение прогресса между сессиями. Репозиторий на GitHub должен называться: Group_LastName_task-11.<img alt=\"Pasted image 20260207130627.png\" src=\"материалы/файлы/pasted-image-20260207130627.png\" target=\"_self\">Рекомендуется использовать заготовку из ресурсов.Заготовка проекта react-project.\n(Материалы/Заготовки под практики/react-project.zip)\nНа главном экране отображается текущий баланс монет, количество монет за клик по персонажу и пассивный доход в секунду (изначально 1 и 0 соответственно).\nПо центру экрана расположен кликабельный персонаж (например, изображение или стилизованный блок). Каждый клик увеличивает баланс на текущее значение «монет за клик».\nНиже или рядом расположен магазин улучшений, содержащий как минимум 7 уникальных позиций. Каждая позиция имеет: Название,\nОписание эффекта (например, «+3 монета за клик» или «+1 монеты в секунду»),\nЦену в монетах. Улучшение можно приобрести только если баланс пользователя не меньше его цены. После покупки: Баланс уменьшается на стоимость улучшения,\nСоответствующий параметр (монеты за клик или пассивный доход) увеличивается на указанную величину. Прогресс игры (баланс, значения параметров, состояние улучшений) должен автоматически сохраняться и восстанавливаться после перезагрузки страницы.\nДолжна быть кнопка «Сбросить прогресс», полностью удаляющая сохранённые данные и возвращающая игру к начальному состоянию.\nРеализовать визуально привлекательный интерфейс: модальные окна для настроек и магазина, использовать тематическое оформление, анимации реакции на клик, эффекты при покупке улучшений или другие элементы, повышающие игровой опыт. Допускается использование CSS-стилей, SVG или встроенных изображений, но без внешних библиотек.5 практические сессии После сессии 1 дедлайн: 50% от максимального балла После сессии 2: 25% После сессии 3: 10%\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Общее описание","level":2,"id":"Общее_описание_0"},{"heading":"Ресурсы","level":2,"id":"Ресурсы_0"},{"heading":"Техническое задание","level":2,"id":"Техническое_задание_0"},{"heading":"Дополнительная часть","level":2,"id":"Дополнительная_часть_0"},{"heading":"Время на выполнение","level":2,"id":"Время_на_выполнение_0"},{"heading":"Баллы","level":2,"id":"Баллы_0"}],"links":[],"author":"","coverImageURL":".","fullURL":"задания/секция-2.-react/практика-№11.-игра-кликер.html","pathToRoot":"../..","attachments":["материалы/файлы/pasted-image-20260207130627.html"],"createdTime":1770458568411,"modifiedTime":1770459097234,"sourceSize":4204,"sourcePath":"Задания/Секция 2. React/Практика №11. Игра-кликер.md","exportPath":"задания/секция-2.-react/практика-№11.-игра-кликер.html","showInTree":true,"treeOrder":13,"backlinks":[],"type":"markdown"},"материалы/файлы/pasted-image-20260207130627.html":{"title":"Pasted image 20260207130627","icon":"","description":"<img src=\"материалы/файлы/pasted-image-20260207130627.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":".","fullURL":"материалы/файлы/pasted-image-20260207130627.html","pathToRoot":"../..","attachments":["материалы/файлы/pasted-image-20260207130627.html"],"createdTime":1770458787751,"modifiedTime":1770458787752,"sourceSize":296662,"sourcePath":"Материалы/Файлы/Pasted image 20260207130627.png","exportPath":"материалы/файлы/pasted-image-20260207130627.html","showInTree":true,"treeOrder":215,"backlinks":["задания/секция-2.-react/практика-№11.-игра-кликер.html"],"type":"attachment"}},"fileInfo":{"задания/секция-1.-javascript/практика-№1.-простая-веб-страница-с-html.html":{"createdTime":1760434739260,"modifiedTime":1760434739260,"sourceSize":3318,"sourcePath":"Задания/Секция 1. JavaScript/Практика №1. Простая веб-страница с HTML.md","exportPath":"задания/секция-1.-javascript/практика-№1.-простая-веб-страница-с-html.html","showInTree":true,"treeOrder":2,"backlinks":["лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html"],"type":"markdown","data":null},"задания/секция-1.-javascript/практика-№2.-использование-git,-github.html":{"createdTime":1760434713010,"modifiedTime":1760434713010,"sourceSize":1422,"sourcePath":"Задания/Секция 1. JavaScript/Практика №2. Использование git, github.md","exportPath":"задания/секция-1.-javascript/практика-№2.-использование-git,-github.html","showInTree":true,"treeOrder":3,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown","data":null},"задания/секция-1.-javascript/практика-№3.-вывод-информации-о-себе-в-консоль..html":{"createdTime":1760434716277,"modifiedTime":1760434716277,"sourceSize":1588,"sourcePath":"Задания/Секция 1. JavaScript/Практика №3. Вывод информации о себе в консоль..md","exportPath":"задания/секция-1.-javascript/практика-№3.-вывод-информации-о-себе-в-консоль..html","showInTree":true,"treeOrder":4,"backlinks":["лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html"],"type":"markdown","data":null},"задания/секция-1.-javascript/практика-№4.-преобразование-типов.html":{"createdTime":1760434721018,"modifiedTime":1760434721018,"sourceSize":1845,"sourcePath":"Задания/Секция 1. JavaScript/Практика №4. Преобразование типов.md","exportPath":"задания/секция-1.-javascript/практика-№4.-преобразование-типов.html","showInTree":true,"treeOrder":5,"backlinks":["лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html"],"type":"markdown","data":null},"задания/секция-1.-javascript/практика-№5.-использование-ветвления..html":{"createdTime":1760434733614,"modifiedTime":1760434733614,"sourceSize":2824,"sourcePath":"Задания/Секция 1. JavaScript/Практика №5. Использование ветвления..md","exportPath":"задания/секция-1.-javascript/практика-№5.-использование-ветвления..html","showInTree":true,"treeOrder":6,"backlinks":["лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"type":"markdown","data":null},"задания/секция-1.-javascript/практика-№6.-вывод-таблицы-умножения-с-помощью-цикла-for.html":{"createdTime":1760434712687,"modifiedTime":1760434712687,"sourceSize":1416,"sourcePath":"Задания/Секция 1. JavaScript/Практика №6. Вывод таблицы умножения с помощью цикла for.md","exportPath":"задания/секция-1.-javascript/практика-№6.-вывод-таблицы-умножения-с-помощью-цикла-for.html","showInTree":true,"treeOrder":7,"backlinks":["лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html"],"type":"markdown","data":null},"задания/секция-1.-javascript/практика-№7.-функции-для-работы-с-строками.html":{"createdTime":1760434736816,"modifiedTime":1760434736816,"sourceSize":3090,"sourcePath":"Задания/Секция 1. JavaScript/Практика №7. Функции для работы с строками.md","exportPath":"задания/секция-1.-javascript/практика-№7.-функции-для-работы-с-строками.html","showInTree":true,"treeOrder":8,"backlinks":["лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"type":"markdown","data":null},"задания/секция-1.-javascript/практика-№8.-ssr-сервер-с-динамической-генерацией-страниц.html":{"createdTime":1760434757997,"modifiedTime":1760434757997,"sourceSize":6334,"sourcePath":"Задания/Секция 1. JavaScript/Практика №8. SSR-сервер с динамической генерацией страниц.md","exportPath":"задания/секция-1.-javascript/практика-№8.-ssr-сервер-с-динамической-генерацией-страниц.html","showInTree":true,"treeOrder":9,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown","data":null},"лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html":{"createdTime":1760434687739,"modifiedTime":1760434687739,"sourceSize":608,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №1. Как создаются мобильные приложения.md","exportPath":"лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html","showInTree":true,"treeOrder":15,"backlinks":["index.html"],"type":"markdown","data":null},"лекции/секция-1.-javascript/тема-№2.-основы-javascript.html":{"createdTime":1760434708376,"modifiedTime":1760434708376,"sourceSize":1252,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №2. Основы JavaScript.md","exportPath":"лекции/секция-1.-javascript/тема-№2.-основы-javascript.html","showInTree":true,"treeOrder":16,"backlinks":["лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html"],"type":"markdown","data":null},"лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html":{"createdTime":1760434713832,"modifiedTime":1760434713832,"sourceSize":1462,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №3. Использование JavaScript в браузере.md","exportPath":"лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html","showInTree":true,"treeOrder":17,"backlinks":["лекции/секция-1.-javascript/тема-№2.-основы-javascript.html"],"type":"markdown","data":null},"лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html":{"createdTime":1760434713938,"modifiedTime":1760434713938,"sourceSize":1463,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №4. Node.JS, примитивные типы данных JavaScript.md","exportPath":"лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html","showInTree":true,"treeOrder":18,"backlinks":["лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html"],"type":"markdown","data":null},"лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html":{"createdTime":1760434713552,"modifiedTime":1760434713552,"sourceSize":1455,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №5. Операторы и операции в JavaScript.md","exportPath":"лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html","showInTree":true,"treeOrder":19,"backlinks":["лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html"],"type":"markdown","data":null},"лекции/секция-1.-javascript/тема-№6.-git,-github.html":{"createdTime":1760434710137,"modifiedTime":1760434710137,"sourceSize":1299,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №6. Git, GitHub.md","exportPath":"лекции/секция-1.-javascript/тема-№6.-git,-github.html","showInTree":true,"treeOrder":20,"backlinks":["лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html"],"type":"markdown","data":null},"лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html":{"createdTime":1760434701045,"modifiedTime":1760434701046,"sourceSize":980,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №7. Ветвление в JavaScript.md","exportPath":"лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html","showInTree":true,"treeOrder":21,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown","data":null},"лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html":{"createdTime":1760434700925,"modifiedTime":1760434700925,"sourceSize":980,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №8. Циклы в JavaScript.md","exportPath":"лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html","showInTree":true,"treeOrder":22,"backlinks":["лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"type":"markdown","data":null},"лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html":{"createdTime":1760434711017,"modifiedTime":1760434711018,"sourceSize":1353,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №9. Функции в JavaScript.md","exportPath":"лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html","showInTree":true,"treeOrder":23,"backlinks":["лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html"],"type":"markdown","data":null},"лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html":{"createdTime":1760434710315,"modifiedTime":1760434710315,"sourceSize":1316,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №10. Область видимости в JavaScript.md","exportPath":"лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html","showInTree":true,"treeOrder":24,"backlinks":["лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"type":"markdown","data":null},"лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html":{"createdTime":1760434705877,"modifiedTime":1760434705877,"sourceSize":1181,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №11. Массивы и объекты в JavaScript.md","exportPath":"лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html","showInTree":true,"treeOrder":25,"backlinks":["лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html"],"type":"markdown","data":null},"лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html":{"createdTime":1760434712315,"modifiedTime":1760434712315,"sourceSize":1404,"sourcePath":"Лекции/Секция 1. JavaScript/Тема №12. Создание сервера NodeJS. WEB 1.0 и WEB 2.0.md","exportPath":"лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html","showInTree":true,"treeOrder":26,"backlinks":["лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html"],"type":"markdown","data":null},"материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html":{"createdTime":1760434689807,"modifiedTime":1760434689807,"sourceSize":667,"sourcePath":"Материалы/Как сделать/Как создавать файлы с определённым расширением.md","exportPath":"материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html","showInTree":true,"treeOrder":35,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№3/создание-своей-html-страницы.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№1/основные-платформы-мобильных-приложений.html":{"createdTime":1760434780410,"modifiedTime":1760434780411,"sourceSize":16719,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №1/Основные платформы мобильных приложений.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№1/основные-платформы-мобильных-приложений.html","showInTree":true,"treeOrder":39,"backlinks":["лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№1/основные-технологии-для-разработки-мобильных-приложений.html":{"createdTime":1760434776958,"modifiedTime":1760434776958,"sourceSize":15238,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №1/Основные технологии для разработки мобильных приложений.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№1/основные-технологии-для-разработки-мобильных-приложений.html","showInTree":true,"treeOrder":40,"backlinks":["лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№1/основные-типы-мобильных-приложений.html":{"createdTime":1760434777027,"modifiedTime":1760434777027,"sourceSize":15196,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №1/Основные типы мобильных приложений.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№1/основные-типы-мобильных-приложений.html","showInTree":true,"treeOrder":41,"backlinks":["лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№2/базовое-понимание-синтаксиса-javascript.html":{"createdTime":1760434740966,"modifiedTime":1760434740967,"sourceSize":3470,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №2/Базовое понимание синтаксиса JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№2/базовое-понимание-синтаксиса-javascript.html","showInTree":true,"treeOrder":43,"backlinks":["лекции/секция-1.-javascript/тема-№2.-основы-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№2/переменные-в-javascript.html":{"createdTime":1760434776005,"modifiedTime":1760434776005,"sourceSize":13815,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №2/Переменные в JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№2/переменные-в-javascript.html","showInTree":true,"treeOrder":44,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№2/базовое-понимание-синтаксиса-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№2/правила-наименования-переменных-в-javascript.html":{"createdTime":1760434748478,"modifiedTime":1760434748478,"sourceSize":4650,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №2/Правила наименования переменных в JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№2/правила-наименования-переменных-в-javascript.html","showInTree":true,"treeOrder":45,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№2/переменные-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№2/что-такое-javascript,-история-появления.html":{"createdTime":1760434765319,"modifiedTime":1760434765319,"sourceSize":7899,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №2/Что такое JavaScript, история появления.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№2/что-такое-javascript,-история-появления.html","showInTree":true,"treeOrder":46,"backlinks":["лекции/секция-1.-javascript/тема-№2.-основы-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№3/базовая-работа-с-элементами-веб-страницы-через-javascript.html":{"createdTime":1760434748641,"modifiedTime":1760434748641,"sourceSize":4668,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №3/Базовая работа с элементами веб страницы через JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№3/базовая-работа-с-элементами-веб-страницы-через-javascript.html","showInTree":true,"treeOrder":48,"backlinks":["лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№3/основные-понятия-веб-страницы.html":{"createdTime":1760434777630,"modifiedTime":1760434777630,"sourceSize":15642,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №3/Основные понятия веб страницы.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№3/основные-понятия-веб-страницы.html","showInTree":true,"treeOrder":49,"backlinks":["лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№3/самое-простое-использование-javascript.html":{"createdTime":1760434736544,"modifiedTime":1760434736544,"sourceSize":3060,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №3/Самое простое использование JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№3/самое-простое-использование-javascript.html","showInTree":true,"treeOrder":50,"backlinks":["лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№3/создание-своей-html-страницы.html":{"createdTime":1760434776506,"modifiedTime":1760434776506,"sourceSize":15024,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №3/Создание своей HTML страницы.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№3/создание-своей-html-страницы.html","showInTree":true,"treeOrder":51,"backlinks":["лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№4/примитивные-типы-данных-javascript.html":{"createdTime":1760434782744,"modifiedTime":1760434782744,"sourceSize":18935,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №4/Примитивные типы данных JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№4/примитивные-типы-данных-javascript.html","showInTree":true,"treeOrder":53,"backlinks":["лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№4/установка-и-базовое-использование-node.js.html":{"createdTime":1760434745086,"modifiedTime":1760434745086,"sourceSize":4135,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №4/Установка и базовое использование Node.js.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№4/установка-и-базовое-использование-node.js.html","showInTree":true,"treeOrder":54,"backlinks":["лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№4/что-такое-node.js.html":{"createdTime":1760434752807,"modifiedTime":1760434752807,"sourceSize":5177,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №4/Что такое Node.js.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№4/что-такое-node.js.html","showInTree":true,"treeOrder":55,"backlinks":["лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№5/арифметические-операторы-javascript.html":{"createdTime":1760434747295,"modifiedTime":1760434747296,"sourceSize":4417,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Арифметические операторы JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№5/арифметические-операторы-javascript.html","showInTree":true,"treeOrder":57,"backlinks":["лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№5/логические-операторы-javascript.html":{"createdTime":1760434757030,"modifiedTime":1760434757030,"sourceSize":6159,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Логические операторы JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№5/логические-операторы-javascript.html","showInTree":true,"treeOrder":58,"backlinks":["лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-присваивания-javascript.html":{"createdTime":1760434758508,"modifiedTime":1760434758508,"sourceSize":6443,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Операторы присваивания JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-присваивания-javascript.html","showInTree":true,"treeOrder":59,"backlinks":["лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-работы-с-битами.html":{"createdTime":1760434762065,"modifiedTime":1760434762065,"sourceSize":7214,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Операторы работы с битами.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-работы-с-битами.html","showInTree":true,"treeOrder":60,"backlinks":["лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-сравнения-javascript.html":{"createdTime":1760434751830,"modifiedTime":1760434751830,"sourceSize":5077,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Операторы сравнения JavaScript.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-сравнения-javascript.html","showInTree":true,"treeOrder":61,"backlinks":["лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№5/определение-оператора-и-операнда.html":{"createdTime":1760434703091,"modifiedTime":1760434703091,"sourceSize":1060,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Определение оператора и операнда.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№5/определение-оператора-и-операнда.html","showInTree":true,"treeOrder":62,"backlinks":["лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№5/приоритет-операторов-и-ассоциативность.html":{"createdTime":1760434764759,"modifiedTime":1760434764759,"sourceSize":7759,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Приоритет операторов и ассоциативность.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№5/приоритет-операторов-и-ассоциативность.html","showInTree":true,"treeOrder":63,"backlinks":["лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№6/базовые-команды-git.html":{"createdTime":1760434753269,"modifiedTime":1760434753269,"sourceSize":5306,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Базовые команды Git.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№6/базовые-команды-git.html","showInTree":true,"treeOrder":65,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№6/основные-понятия-git.html":{"createdTime":1760434755536,"modifiedTime":1760434755537,"sourceSize":5771,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Основные понятия Git.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№6/основные-понятия-git.html","showInTree":true,"treeOrder":66,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-ветками-git.html":{"createdTime":1760434745652,"modifiedTime":1760434745652,"sourceSize":4169,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Работа с ветками Git.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-ветками-git.html","showInTree":true,"treeOrder":67,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-удалёнными-репозиториями.html":{"createdTime":1760434743184,"modifiedTime":1760434743185,"sourceSize":3863,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Работа с удалёнными репозиториями.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-удалёнными-репозиториями.html","showInTree":true,"treeOrder":68,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№6/рекомендации-по-использованию-git.html":{"createdTime":1760434747844,"modifiedTime":1760434747845,"sourceSize":4475,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Рекомендации по использованию Git.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№6/рекомендации-по-использованию-git.html","showInTree":true,"treeOrder":69,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№6/файл-.gitignore.html":{"createdTime":1760434727226,"modifiedTime":1760434727226,"sourceSize":2311,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Файл .gitignore.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№6/файл-.gitignore.html","showInTree":true,"treeOrder":70,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-git.html":{"createdTime":1760434740441,"modifiedTime":1760434740441,"sourceSize":3437,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Что такое Git.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-git.html","showInTree":true,"treeOrder":71,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-github.html":{"createdTime":1760434726131,"modifiedTime":1760434726132,"sourceSize":2258,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Что такое GitHub.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-github.html","showInTree":true,"treeOrder":72,"backlinks":["лекции/секция-1.-javascript/тема-№6.-git,-github.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`else`.html":{"createdTime":1760434715774,"modifiedTime":1760434715774,"sourceSize":1560,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Оператор `else`.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`else`.html","showInTree":true,"treeOrder":74,"backlinks":["лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`if`.html":{"createdTime":1760434727715,"modifiedTime":1760434727715,"sourceSize":2337,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Оператор `if`.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`if`.html","showInTree":true,"treeOrder":75,"backlinks":["лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`switch`.html":{"createdTime":1760434753830,"modifiedTime":1760434753831,"sourceSize":5411,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Оператор `switch`.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`switch`.html","showInTree":true,"treeOrder":76,"backlinks":["лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№7/сравнение-`if`-и-`switch`.html":{"createdTime":1760434750014,"modifiedTime":1760434750015,"sourceSize":4764,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Сравнение `if` и `switch`.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№7/сравнение-`if`-и-`switch`.html","showInTree":true,"treeOrder":77,"backlinks":["лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№7/тернарный-оператор.html":{"createdTime":1760434741484,"modifiedTime":1760434741484,"sourceSize":3584,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Тернарный оператор.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№7/тернарный-оператор.html","showInTree":true,"treeOrder":78,"backlinks":["лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№7/цепочки-`else-if`.html":{"createdTime":1760434744529,"modifiedTime":1760434744529,"sourceSize":4028,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Цепочки `else if`.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№7/цепочки-`else-if`.html","showInTree":true,"treeOrder":79,"backlinks":["лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№7/что-такое-ветвление.html":{"createdTime":1760434716362,"modifiedTime":1760434716362,"sourceSize":1588,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Что такое ветвление.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№7/что-такое-ветвление.html","showInTree":true,"treeOrder":80,"backlinks":["лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№8/прерывание-и-пропуск-итераций.html":{"createdTime":1760434741342,"modifiedTime":1760434741343,"sourceSize":3500,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Прерывание и пропуск итераций.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№8/прерывание-и-пропуск-итераций.html","showInTree":true,"treeOrder":82,"backlinks":["лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`do...while`.html":{"createdTime":1760434724559,"modifiedTime":1760434724559,"sourceSize":1988,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Цикл `do...while`.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`do...while`.html","showInTree":true,"treeOrder":83,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№8/цикл-while.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...in`-—-перебор-ключей-объекта.html":{"createdTime":1760434731580,"modifiedTime":1760434731581,"sourceSize":2652,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Цикл `for...in` — перебор ключей объекта.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...in`-—-перебор-ключей-объекта.html","showInTree":true,"treeOrder":84,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№8/цикл-for.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...of`-—-перебор-значений-итерируемых-объектов.html":{"createdTime":1760434732374,"modifiedTime":1760434732374,"sourceSize":2690,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Цикл `for...of` — перебор значений итерируемых объектов.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...of`-—-перебор-значений-итерируемых-объектов.html","showInTree":true,"treeOrder":85,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№8/цикл-for.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-for.html":{"createdTime":1760434722689,"modifiedTime":1760434722690,"sourceSize":1893,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Цикл for.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-for.html","showInTree":true,"treeOrder":86,"backlinks":["лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-while.html":{"createdTime":1760434734881,"modifiedTime":1760434734881,"sourceSize":2911,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Цикл while.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-while.html","showInTree":true,"treeOrder":87,"backlinks":["лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№8/циклы-и-производительность.html":{"createdTime":1760434742486,"modifiedTime":1760434742486,"sourceSize":3755,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Циклы и производительность.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№8/циклы-и-производительность.html","showInTree":true,"treeOrder":88,"backlinks":["лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№8/что-такое-цикл.html":{"createdTime":1760434715405,"modifiedTime":1760434715405,"sourceSize":1531,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Что такое цикл.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№8/что-такое-цикл.html","showInTree":true,"treeOrder":89,"backlinks":["лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№9/возвращаемое-значение.html":{"createdTime":1760434734012,"modifiedTime":1760434734012,"sourceSize":2834,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Возвращаемое значение.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№9/возвращаемое-значение.html","showInTree":true,"treeOrder":91,"backlinks":["лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№9/объявление-функции-(function-declaration).html":{"createdTime":1760434720553,"modifiedTime":1760434720553,"sourceSize":1835,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Объявление функции (Function Declaration).md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№9/объявление-функции-(function-declaration).html","showInTree":true,"treeOrder":92,"backlinks":["лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№9/параметры-и-аргументы.html":{"createdTime":1760434729637,"modifiedTime":1760434729637,"sourceSize":2518,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Параметры и аргументы.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№9/параметры-и-аргументы.html","showInTree":true,"treeOrder":93,"backlinks":["лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№9/рекурсия.html":{"createdTime":1760434738554,"modifiedTime":1760434738554,"sourceSize":3223,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Рекурсия.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№9/рекурсия.html","showInTree":true,"treeOrder":94,"backlinks":["лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№9/стрелочные-функции-(arrow-function).html":{"createdTime":1760434733101,"modifiedTime":1760434733101,"sourceSize":2757,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Стрелочные функции (Arrow Function).md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№9/стрелочные-функции-(arrow-function).html","showInTree":true,"treeOrder":95,"backlinks":["лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№9/функциональное-выражение-(function-expression).html":{"createdTime":1760434730237,"modifiedTime":1760434730237,"sourceSize":2563,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Функциональное выражение (Function Expression).md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№9/функциональное-выражение-(function-expression).html","showInTree":true,"treeOrder":96,"backlinks":["лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№9/что-такое-функция.html":{"createdTime":1760434724385,"modifiedTime":1760434724385,"sourceSize":1943,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Что такое функция.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№9/что-такое-функция.html","showInTree":true,"treeOrder":97,"backlinks":["лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№10/блочная-область-видимости.html":{"createdTime":1760434731297,"modifiedTime":1760434731297,"sourceSize":2597,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Блочная область видимости.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№10/блочная-область-видимости.html","showInTree":true,"treeOrder":99,"backlinks":["лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№10/вложенность-областей-видимости.html":{"createdTime":1760434731950,"modifiedTime":1760434731950,"sourceSize":2681,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Вложенность областей видимости.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№10/вложенность-областей-видимости.html","showInTree":true,"treeOrder":100,"backlinks":["лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№10/глобальная-область-видимости.html":{"createdTime":1760434732846,"modifiedTime":1760434732846,"sourceSize":2716,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Глобальная область видимости.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№10/глобальная-область-видимости.html","showInTree":true,"treeOrder":101,"backlinks":["лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№10/замыкания.html":{"createdTime":1760434751008,"modifiedTime":1760434751008,"sourceSize":4932,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Замыкания.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№10/замыкания.html","showInTree":true,"treeOrder":102,"backlinks":["лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№10/каррированные-функции.html":{"createdTime":1760434736718,"modifiedTime":1760434736718,"sourceSize":3085,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Каррированные функции.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№10/каррированные-функции.html","showInTree":true,"treeOrder":103,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№10/замыкания.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№10/практические-последствия-(var).html":{"createdTime":1760434742256,"modifiedTime":1760434742256,"sourceSize":3746,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Практические последствия (var).md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№10/практические-последствия-(var).html","showInTree":true,"treeOrder":104,"backlinks":["лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№10/функциональная-область-видимости.html":{"createdTime":1760434731775,"modifiedTime":1760434731776,"sourceSize":2668,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Функциональная область видимости.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№10/функциональная-область-видимости.html","showInTree":true,"treeOrder":105,"backlinks":["лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№10/что-такое-область-видимости.html":{"createdTime":1760434715240,"modifiedTime":1760434715240,"sourceSize":1526,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Что такое область видимости.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№10/что-такое-область-видимости.html","showInTree":true,"treeOrder":106,"backlinks":["лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№11/вложенные-структуры.html":{"createdTime":1760434742873,"modifiedTime":1760434742873,"sourceSize":3848,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Вложенные структуры.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№11/вложенные-структуры.html","showInTree":true,"treeOrder":108,"backlinks":["лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№11/конструктор-массива-array.html":{"createdTime":1760434734237,"modifiedTime":1760434734238,"sourceSize":2836,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Конструктор массива Array.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№11/конструктор-массива-array.html","showInTree":true,"treeOrder":109,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№11/массивы.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№11/массивы.html":{"createdTime":1760434760719,"modifiedTime":1760434760719,"sourceSize":6898,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Массивы.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№11/массивы.html","showInTree":true,"treeOrder":110,"backlinks":["лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№11/объекты.html":{"createdTime":1760434752388,"modifiedTime":1760434752388,"sourceSize":5144,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Объекты.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№11/объекты.html","showInTree":true,"treeOrder":111,"backlinks":["лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№11/оператор-rest.html":{"createdTime":1760434741906,"modifiedTime":1760434741906,"sourceSize":3651,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Оператор rest.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№11/оператор-rest.html","showInTree":true,"treeOrder":112,"backlinks":["лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№11/практические-рекомендации-по-массивам-и-объектам.html":{"createdTime":1760434748426,"modifiedTime":1760434748426,"sourceSize":4642,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Практические рекомендации по массивам и объектам.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№11/практические-рекомендации-по-массивам-и-объектам.html","showInTree":true,"treeOrder":113,"backlinks":["лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№11/преобразование-типов-(массивы-и-объекты)-через-json.html":{"createdTime":1760434740957,"modifiedTime":1760434740957,"sourceSize":3471,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Преобразование типов (Массивы и Объекты) через JSON.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№11/преобразование-типов-(массивы-и-объекты)-через-json.html","showInTree":true,"treeOrder":114,"backlinks":["лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№11/распаковка-(spread).html":{"createdTime":1760434740257,"modifiedTime":1760434740258,"sourceSize":3417,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Распаковка (spread).md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№11/распаковка-(spread).html","showInTree":true,"treeOrder":115,"backlinks":["лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№12/вкратце-о-rest.html":{"createdTime":1760434721248,"modifiedTime":1760434721248,"sourceSize":1853,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №12/Вкратце о REST.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№12/вкратце-о-rest.html","showInTree":true,"treeOrder":117,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№12/гидратация.html":{"createdTime":1760434758840,"modifiedTime":1760434758840,"sourceSize":6493,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №12/Гидратация.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№12/гидратация.html","showInTree":true,"treeOrder":118,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№12/разница-между-web-1.0-и-web-2.0-в-контексте-nodejs.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№12/маршрутизация-в-nodejs.html":{"createdTime":1760434744151,"modifiedTime":1760434744151,"sourceSize":4010,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №12/Маршрутизация в NodeJS.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№12/маршрутизация-в-nodejs.html","showInTree":true,"treeOrder":119,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№12/основы-сервера-на-nodejs.html":{"createdTime":1760434741145,"modifiedTime":1760434741145,"sourceSize":3491,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №12/Основы сервера на NodeJS.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№12/основы-сервера-на-nodejs.html","showInTree":true,"treeOrder":120,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№12/отправка-файлов-с-сервера.html":{"createdTime":1760434749989,"modifiedTime":1760434749989,"sourceSize":4796,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №12/Отправка файлов с сервера.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№12/отправка-файлов-с-сервера.html","showInTree":true,"treeOrder":121,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№12/разница-между-web-1.0-и-web-2.0-в-контексте-nodejs.html":{"createdTime":1760434753997,"modifiedTime":1760434753997,"sourceSize":5447,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №12/Разница между WEB 1.0 и WEB 2.0 в контексте NodeJS.md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№12/разница-между-web-1.0-и-web-2.0-в-контексте-nodejs.html","showInTree":true,"treeOrder":122,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№12/web-1.0-(статический-веб).html":{"createdTime":1760434727396,"modifiedTime":1760434727396,"sourceSize":2316,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №12/WEB 1.0 (статический веб).md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№12/web-1.0-(статический-веб).html","showInTree":true,"treeOrder":123,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown","data":null},"материалы/подтемы/секция-1.-javascript/тема-№12/web-2.0-(интерактивный-веб).html":{"createdTime":1760434737773,"modifiedTime":1760434737773,"sourceSize":3161,"sourcePath":"Материалы/Подтемы/Секция 1. JavaScript/Тема №12/WEB 2.0 (интерактивный веб).md","exportPath":"материалы/подтемы/секция-1.-javascript/тема-№12/web-2.0-(интерактивный-веб).html","showInTree":true,"treeOrder":124,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown","data":null},"материалы/файлы/pasted-image-20240923235323.png":{"createdTime":1760434978750,"modifiedTime":1760434978792,"sourceSize":400632,"sourcePath":"Материалы/Файлы/Pasted image 20240923235323.png","exportPath":"материалы/файлы/pasted-image-20240923235323.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"материалы/файлы/pasted-image-20240923235323.html":{"createdTime":1760434978750,"modifiedTime":1760434978792,"sourceSize":400632,"sourcePath":"Материалы/Файлы/Pasted image 20240923235323.png","exportPath":"материалы/файлы/pasted-image-20240923235323.html","showInTree":true,"treeOrder":155,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№4/примитивные-типы-данных-javascript.html"],"type":"attachment","data":null},"материалы/файлы/pasted-image-20240928221620.png":{"createdTime":1760434786268,"modifiedTime":1760434786283,"sourceSize":24101,"sourcePath":"Материалы/Файлы/Pasted image 20240928221620.png","exportPath":"материалы/файлы/pasted-image-20240928221620.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"материалы/файлы/pasted-image-20240928221620.html":{"createdTime":1760434786268,"modifiedTime":1760434786283,"sourceSize":24101,"sourcePath":"Материалы/Файлы/Pasted image 20240928221620.png","exportPath":"материалы/файлы/pasted-image-20240928221620.html","showInTree":true,"treeOrder":156,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№4/установка-и-базовое-использование-node.js.html"],"type":"attachment","data":null},"материалы/файлы/pasted-image-20240928222139.png":{"createdTime":1760434810167,"modifiedTime":1760434810186,"sourceSize":78566,"sourcePath":"Материалы/Файлы/Pasted image 20240928222139.png","exportPath":"материалы/файлы/pasted-image-20240928222139.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"материалы/файлы/pasted-image-20240928222139.html":{"createdTime":1760434810167,"modifiedTime":1760434810186,"sourceSize":78566,"sourcePath":"Материалы/Файлы/Pasted image 20240928222139.png","exportPath":"материалы/файлы/pasted-image-20240928222139.html","showInTree":true,"treeOrder":157,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№4/установка-и-базовое-использование-node.js.html"],"type":"attachment","data":null},"материалы/файлы/pasted-image-20240928222237.png":{"createdTime":1760434687819,"modifiedTime":1760434687832,"sourceSize":621,"sourcePath":"Материалы/Файлы/Pasted image 20240928222237.png","exportPath":"материалы/файлы/pasted-image-20240928222237.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"материалы/файлы/pasted-image-20240928222237.html":{"createdTime":1760434687819,"modifiedTime":1760434687832,"sourceSize":621,"sourcePath":"Материалы/Файлы/Pasted image 20240928222237.png","exportPath":"материалы/файлы/pasted-image-20240928222237.html","showInTree":true,"treeOrder":158,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№4/установка-и-базовое-использование-node.js.html"],"type":"attachment","data":null},"материалы/файлы/pasted-image-20250912205946.png":{"createdTime":1760434817865,"modifiedTime":1760434817874,"sourceSize":102416,"sourcePath":"Материалы/Файлы/Pasted image 20250912205946.png","exportPath":"материалы/файлы/pasted-image-20250912205946.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"материалы/файлы/pasted-image-20250912205946.html":{"createdTime":1760434817865,"modifiedTime":1760434817874,"sourceSize":102416,"sourcePath":"Материалы/Файлы/Pasted image 20250912205946.png","exportPath":"материалы/файлы/pasted-image-20250912205946.html","showInTree":true,"treeOrder":159,"backlinks":["index.html"],"type":"attachment","data":null},"материалы/файлы/pasted-image-20250912212732.png":{"createdTime":1760434818431,"modifiedTime":1760434818438,"sourceSize":105027,"sourcePath":"Материалы/Файлы/Pasted image 20250912212732.png","exportPath":"материалы/файлы/pasted-image-20250912212732.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"материалы/файлы/pasted-image-20250912212732.html":{"createdTime":1760434818431,"modifiedTime":1760434818438,"sourceSize":105027,"sourcePath":"Материалы/Файлы/Pasted image 20250912212732.png","exportPath":"материалы/файлы/pasted-image-20250912212732.html","showInTree":true,"treeOrder":160,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№3/самое-простое-использование-javascript.html"],"type":"attachment","data":null},"материалы/файлы/pasted-image-20250912212810.png":{"createdTime":1760434746634,"modifiedTime":1760434746634,"sourceSize":4324,"sourcePath":"Материалы/Файлы/Pasted image 20250912212810.png","exportPath":"материалы/файлы/pasted-image-20250912212810.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"материалы/файлы/pasted-image-20250912212810.html":{"createdTime":1760434746634,"modifiedTime":1760434746634,"sourceSize":4324,"sourcePath":"Материалы/Файлы/Pasted image 20250912212810.png","exportPath":"материалы/файлы/pasted-image-20250912212810.html","showInTree":true,"treeOrder":161,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№3/самое-простое-использование-javascript.html"],"type":"attachment","data":null},"материалы/файлы/pasted-image-20250912212840.png":{"createdTime":1760434770458,"modifiedTime":1760434770458,"sourceSize":11213,"sourcePath":"Материалы/Файлы/Pasted image 20250912212840.png","exportPath":"материалы/файлы/pasted-image-20250912212840.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"материалы/файлы/pasted-image-20250912212840.html":{"createdTime":1760434770458,"modifiedTime":1760434770458,"sourceSize":11213,"sourcePath":"Материалы/Файлы/Pasted image 20250912212840.png","exportPath":"материалы/файлы/pasted-image-20250912212840.html","showInTree":true,"treeOrder":162,"backlinks":["материалы/подтемы/секция-1.-javascript/тема-№3/самое-простое-использование-javascript.html"],"type":"attachment","data":null},"материалы/файлы/pasted-image-20250912214611.png":{"createdTime":1760434785185,"modifiedTime":1760434785185,"sourceSize":21467,"sourcePath":"Материалы/Файлы/Pasted image 20250912214611.png","exportPath":"материалы/файлы/pasted-image-20250912214611.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"материалы/файлы/pasted-image-20250912214611.html":{"createdTime":1760434785185,"modifiedTime":1760434785185,"sourceSize":21467,"sourcePath":"Материалы/Файлы/Pasted image 20250912214611.png","exportPath":"материалы/файлы/pasted-image-20250912214611.html","showInTree":true,"treeOrder":163,"backlinks":["материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html"],"type":"attachment","data":null},"материалы/файлы/pasted-image-20250912214624.png":{"createdTime":1760434798143,"modifiedTime":1760434798145,"sourceSize":46166,"sourcePath":"Материалы/Файлы/Pasted image 20250912214624.png","exportPath":"материалы/файлы/pasted-image-20250912214624.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"материалы/файлы/pasted-image-20250912214624.html":{"createdTime":1760434798143,"modifiedTime":1760434798145,"sourceSize":46166,"sourcePath":"Материалы/Файлы/Pasted image 20250912214624.png","exportPath":"материалы/файлы/pasted-image-20250912214624.html","showInTree":true,"treeOrder":164,"backlinks":["материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html"],"type":"attachment","data":null},"материалы/файлы/pasted-image-20250912214643.png":{"createdTime":1760434789622,"modifiedTime":1760434789624,"sourceSize":29457,"sourcePath":"Материалы/Файлы/Pasted image 20250912214643.png","exportPath":"материалы/файлы/pasted-image-20250912214643.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"материалы/файлы/pasted-image-20250912214643.html":{"createdTime":1760434789622,"modifiedTime":1760434789624,"sourceSize":29457,"sourcePath":"Материалы/Файлы/Pasted image 20250912214643.png","exportPath":"материалы/файлы/pasted-image-20250912214643.html","showInTree":true,"treeOrder":165,"backlinks":["материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html"],"type":"attachment","data":null},"материалы/файлы/pasted-image-20250912214649.png":{"createdTime":1760434746608,"modifiedTime":1760434746609,"sourceSize":4311,"sourcePath":"Материалы/Файлы/Pasted image 20250912214649.png","exportPath":"материалы/файлы/pasted-image-20250912214649.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"материалы/файлы/pasted-image-20250912214649.html":{"createdTime":1760434746608,"modifiedTime":1760434746609,"sourceSize":4311,"sourcePath":"Материалы/Файлы/Pasted image 20250912214649.png","exportPath":"материалы/файлы/pasted-image-20250912214649.html","showInTree":true,"treeOrder":166,"backlinks":["материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html"],"type":"attachment","data":null},"материалы/файлы/pasted-image-20250912214653.png":{"createdTime":1760434742670,"modifiedTime":1760434742671,"sourceSize":3794,"sourcePath":"Материалы/Файлы/Pasted image 20250912214653.png","exportPath":"материалы/файлы/pasted-image-20250912214653.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"материалы/файлы/pasted-image-20250912214653.html":{"createdTime":1760434742670,"modifiedTime":1760434742671,"sourceSize":3794,"sourcePath":"Материалы/Файлы/Pasted image 20250912214653.png","exportPath":"материалы/файлы/pasted-image-20250912214653.html","showInTree":true,"treeOrder":167,"backlinks":["материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html"],"type":"attachment","data":null},"материалы/файлы/pasted-image-20250917202240.png":{"createdTime":1760434786268,"modifiedTime":1760434786289,"sourceSize":24101,"sourcePath":"Материалы/Файлы/Pasted image 20250917202240.png","exportPath":"материалы/файлы/pasted-image-20250917202240.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"материалы/файлы/pasted-image-20250917202240.html":{"createdTime":1760434786268,"modifiedTime":1760434786289,"sourceSize":24101,"sourcePath":"Материалы/Файлы/Pasted image 20250917202240.png","exportPath":"материалы/файлы/pasted-image-20250917202240.html","showInTree":true,"treeOrder":168,"backlinks":[],"type":"attachment","data":null},"материалы/файлы/qrcod_72k5.png":{"createdTime":1760434791609,"modifiedTime":1760434791609,"sourceSize":34656,"sourcePath":"Материалы/Файлы/qrcod_72k5.png","exportPath":"материалы/файлы/qrcod_72k5.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"материалы/файлы/qrcod_72k5.html":{"createdTime":1760434791609,"modifiedTime":1760434791609,"sourceSize":34656,"sourcePath":"Материалы/Файлы/qrcod_72k5.png","exportPath":"материалы/файлы/qrcod_72k5.html","showInTree":true,"treeOrder":169,"backlinks":["index.html"],"type":"attachment","data":null},"index.html":{"createdTime":1760434673798,"modifiedTime":1760434673798,"sourceSize":361,"sourcePath":"index.md","exportPath":"index.html","showInTree":true,"treeOrder":170,"backlinks":[],"type":"markdown","data":null},"site-lib/scripts/graph-wasm.wasm":{"createdTime":1760702323817,"modifiedTime":1760435605334.3296,"sourceSize":23655,"sourcePath":"","exportPath":"site-lib/scripts/graph-wasm.wasm","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"site-lib/fonts/70cc7ff27245e82ad414.ttf":{"createdTime":1770459144318,"modifiedTime":1770459144318,"sourceSize":192740,"sourcePath":"","exportPath":"site-lib/fonts/70cc7ff27245e82ad414.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/454577c22304619db035.ttf":{"createdTime":1770459144322,"modifiedTime":1770459144322,"sourceSize":161376,"sourcePath":"","exportPath":"site-lib/fonts/454577c22304619db035.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/52ac8f3034507f1d9e53.ttf":{"createdTime":1770459144317,"modifiedTime":1770459144317,"sourceSize":191568,"sourcePath":"","exportPath":"site-lib/fonts/52ac8f3034507f1d9e53.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/05b618077343fbbd92b7.ttf":{"createdTime":1770459144323,"modifiedTime":1770459144323,"sourceSize":155288,"sourcePath":"","exportPath":"site-lib/fonts/05b618077343fbbd92b7.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2":{"createdTime":1770459144304,"modifiedTime":1770459144304,"sourceSize":7876,"sourcePath":"","exportPath":"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/media/6155340132a851f6089e.svg":{"createdTime":1770459144305,"modifiedTime":1770459144305,"sourceSize":315,"sourcePath":"","exportPath":"site-lib/media/6155340132a851f6089e.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/2308ab1944a6bfa5c5b8.svg":{"createdTime":1770459144306,"modifiedTime":1770459144306,"sourceSize":278,"sourcePath":"","exportPath":"site-lib/media/2308ab1944a6bfa5c5b8.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/html/file-tree-content.html":{"createdTime":1770459145715,"modifiedTime":1770459145715,"sourceSize":103325,"sourcePath":"","exportPath":"site-lib/html/file-tree-content.html","showInTree":false,"treeOrder":0,"backlinks":[],"type":"html","data":null},"site-lib/scripts/webpage.js":{"createdTime":1770183776125,"modifiedTime":1770183776125,"sourceSize":110729,"sourcePath":"","exportPath":"site-lib/scripts/webpage.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/scripts/graph-wasm.js":{"createdTime":1770183776125,"modifiedTime":1770183776125,"sourceSize":12885,"sourcePath":"","exportPath":"site-lib/scripts/graph-wasm.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/scripts/graph-render-worker.js":{"createdTime":1770183776125,"modifiedTime":1770183776125,"sourceSize":5681,"sourcePath":"","exportPath":"site-lib/scripts/graph-render-worker.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/media/favicon.png":{"createdTime":1770459144177,"modifiedTime":1770459144177,"sourceSize":1105,"sourcePath":"","exportPath":"site-lib/media/favicon.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/styles/obsidian.css":{"createdTime":1770459144414,"modifiedTime":1770459144414,"sourceSize":213476,"sourcePath":"","exportPath":"site-lib/styles/obsidian.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/global-variable-styles.css":{"createdTime":1770459144278,"modifiedTime":1770459144278,"sourceSize":305,"sourcePath":"","exportPath":"site-lib/styles/global-variable-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/main-styles.css":{"createdTime":1770183776155,"modifiedTime":1770183776155,"sourceSize":19521,"sourcePath":"","exportPath":"site-lib/styles/main-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/rss.xml":{"createdTime":1770459146181,"modifiedTime":1770459146181,"sourceSize":557924,"sourcePath":"","exportPath":"site-lib/rss.xml","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"задания/секция-1.-javascript/практика-№9.-csr-с-гидратацией.-интерактивный-счётчик.html":{"createdTime":1760434765167,"modifiedTime":1760434765167,"sourceSize":7896,"sourcePath":"Задания/Секция 1. JavaScript/Практика №9. CSR с гидратацией. Интерактивный счётчик.md","exportPath":"задания/секция-1.-javascript/практика-№9.-csr-с-гидратацией.-интерактивный-счётчик.html","showInTree":true,"treeOrder":10,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown","data":null},"задания/секция-2.-react/практика-№10.-интерактивный-счётчик-с-изменением-темы.html":{"createdTime":1760713615782,"modifiedTime":1760725367842,"sourceSize":4635,"sourcePath":"Задания/Секция 2. React/Практика №10. Интерактивный счётчик с изменением темы.md","exportPath":"задания/секция-2.-react/практика-№10.-интерактивный-счётчик-с-изменением-темы.html","showInTree":true,"treeOrder":12,"backlinks":["лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html"],"type":"markdown","data":null},"лекции/секция-2.-react/тема-№13.-основы-react.html":{"createdTime":1760704333534,"modifiedTime":1760715448464,"sourceSize":958,"sourcePath":"Лекции/Секция 2. React/Тема №13. Основы React.md","exportPath":"лекции/секция-2.-react/тема-№13.-основы-react.html","showInTree":true,"treeOrder":28,"backlinks":["лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html"],"type":"markdown","data":null},"лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html":{"createdTime":1760715494814,"modifiedTime":1760717797893,"sourceSize":1298,"sourcePath":"Лекции/Секция 2. React/Тема №14. Работа со стилями, изображениями и файлами в React.md","exportPath":"лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html","showInTree":true,"treeOrder":29,"backlinks":["лекции/секция-2.-react/тема-№13.-основы-react.html"],"type":"markdown","data":null},"лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html":{"createdTime":1760711594461,"modifiedTime":1768934440848,"sourceSize":1062,"sourcePath":"Лекции/Секция 2. React/Тема №15. Хранение и передача данных в React.md","exportPath":"лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html","showInTree":true,"treeOrder":30,"backlinks":["лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html"],"type":"markdown","data":null},"материалы/заготовки-под-практики/react-project.zip":{"createdTime":1760724056771,"modifiedTime":1760724056811,"sourceSize":19577597,"sourcePath":"Материалы/Заготовки под практики/react-project.zip","exportPath":"материалы/заготовки-под-практики/react-project.zip","showInTree":true,"treeOrder":0,"backlinks":[],"type":"other","data":null},"материалы/подтемы/секция-2.-react/тема-№13/компоненты.html":{"createdTime":1760709835652,"modifiedTime":1760709880963,"sourceSize":2649,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №13/Компоненты.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№13/компоненты.html","showInTree":true,"treeOrder":127,"backlinks":["лекции/секция-2.-react/тема-№13.-основы-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№13/создание-и-запуск-react-проекта.html":{"createdTime":1760709853189,"modifiedTime":1760709983253,"sourceSize":2023,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №13/Создание и запуск React-проекта.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№13/создание-и-запуск-react-проекта.html","showInTree":true,"treeOrder":128,"backlinks":["лекции/секция-2.-react/тема-№13.-основы-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№13/типичная-структура-react-приложения.html":{"createdTime":1760710242056,"modifiedTime":1760710659795,"sourceSize":6373,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №13/Типичная структура React-приложения.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№13/типичная-структура-react-приложения.html","showInTree":true,"treeOrder":129,"backlinks":["лекции/секция-2.-react/тема-№13.-основы-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№13/что-такое-react.html":{"createdTime":1760709726219,"modifiedTime":1760709729183,"sourceSize":3178,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №13/Что такое React.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№13/что-такое-react.html","showInTree":true,"treeOrder":130,"backlinks":["лекции/секция-2.-react/тема-№13.-основы-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№13/create-react-app-(cra).html":{"createdTime":1760710031446,"modifiedTime":1760710032642,"sourceSize":2231,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №13/Create React App (CRA).md","exportPath":"материалы/подтемы/секция-2.-react/тема-№13/create-react-app-(cra).html","showInTree":true,"treeOrder":131,"backlinks":["материалы/подтемы/секция-2.-react/тема-№13/создание-и-запуск-react-проекта.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№13/jsx.html":{"createdTime":1760709818801,"modifiedTime":1760709869931,"sourceSize":2631,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №13/JSX.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№13/jsx.html","showInTree":true,"treeOrder":132,"backlinks":["лекции/секция-2.-react/тема-№13.-основы-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№13/vite.html":{"createdTime":1760710094613,"modifiedTime":1760710197285,"sourceSize":2723,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №13/Vite.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№13/vite.html","showInTree":true,"treeOrder":133,"backlinks":["материалы/подтемы/секция-2.-react/тема-№13/создание-и-запуск-react-проекта.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№14/аудио-и-видео.html":{"createdTime":1760716726228,"modifiedTime":1760716773156,"sourceSize":3273,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/Аудио и видео.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/аудио-и-видео.html","showInTree":true,"treeOrder":135,"backlinks":["материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№14/изображения.html":{"createdTime":1760716226766,"modifiedTime":1760716271183,"sourceSize":2289,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/Изображения.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/изображения.html","showInTree":true,"treeOrder":136,"backlinks":["материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№14/импорт-функций-и-переменных-js.html":{"createdTime":1760717693350,"modifiedTime":1760717699334,"sourceSize":3355,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/Импорт функций и переменных JS.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/импорт-функций-и-переменных-js.html","showInTree":true,"treeOrder":137,"backlinks":["лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№14/как-react-обрабатывает-импорт-файлов.html":{"createdTime":1760715942964,"modifiedTime":1760716077806,"sourceSize":4605,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/Как React обрабатывает импорт файлов.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/как-react-обрабатывает-импорт-файлов.html","showInTree":true,"treeOrder":138,"backlinks":["лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html":{"createdTime":1760716156418,"modifiedTime":1760716956296,"sourceSize":1674,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/Какие файлы можно импортировать.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html","showInTree":true,"treeOrder":139,"backlinks":["лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№14/практические-ошибки-и-как-их-избежать.html":{"createdTime":1760717715087,"modifiedTime":1760717761341,"sourceSize":4213,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/Практические ошибки и как их избежать.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/практические-ошибки-и-как-их-избежать.html","showInTree":true,"treeOrder":140,"backlinks":["лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№14/работа-со-стилями-и-файлами.html":{"createdTime":1760717389952,"modifiedTime":1760717432074,"sourceSize":3594,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/Работа со стилями и файлами.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/работа-со-стилями-и-файлами.html","showInTree":true,"treeOrder":141,"backlinks":["лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№14/что-делать-с-файлами-в-папке-public.html":{"createdTime":1760717254105,"modifiedTime":1760717310892,"sourceSize":3122,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/Что делать с файлами в папке public.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/что-делать-с-файлами-в-папке-public.html","showInTree":true,"treeOrder":142,"backlinks":["лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№14/шрифты.html":{"createdTime":1760716484736,"modifiedTime":1760716590288,"sourceSize":3588,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/Шрифты.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/шрифты.html","showInTree":true,"treeOrder":143,"backlinks":["материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№14/env-файлы.html":{"createdTime":1760716959344,"modifiedTime":1760717173411,"sourceSize":3941,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/env-файлы.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/env-файлы.html","showInTree":true,"treeOrder":144,"backlinks":["материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№14/json-файлы.html":{"createdTime":1760716799753,"modifiedTime":1760716873170,"sourceSize":3373,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/JSON-файлы.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/json-файлы.html","showInTree":true,"treeOrder":145,"backlinks":["материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№14/svg.html":{"createdTime":1760716272890,"modifiedTime":1760716440205,"sourceSize":3914,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №14/SVG.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№14/svg.html","showInTree":true,"treeOrder":146,"backlinks":["материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№15/передача-данных-через-props.html":{"createdTime":1760711801410,"modifiedTime":1760712208973,"sourceSize":5424,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №15/Передача данных через props.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№15/передача-данных-через-props.html","showInTree":true,"treeOrder":148,"backlinks":["лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№15/передача-функций-как-props.html":{"createdTime":1760712091580,"modifiedTime":1760712094340,"sourceSize":3260,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №15/Передача функций как props.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№15/передача-функций-как-props.html","showInTree":true,"treeOrder":149,"backlinks":["материалы/подтемы/секция-2.-react/тема-№15/передача-данных-через-props.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№15/состояние-и-хук-usestate.html":{"createdTime":1760711686137,"modifiedTime":1760711690530,"sourceSize":4112,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №15/Состояние и хук useState.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№15/состояние-и-хук-usestate.html","showInTree":true,"treeOrder":150,"backlinks":["лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№15/хранение-данных-между-сессиями.html":{"createdTime":1760712229057,"modifiedTime":1760712502248,"sourceSize":1552,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №15/Хранение данных между сессиями.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№15/хранение-данных-между-сессиями.html","showInTree":true,"treeOrder":151,"backlinks":["лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№15/cookies-в-react-приложениях.html":{"createdTime":1760712863307,"modifiedTime":1760713114388,"sourceSize":5053,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №15/Cookies в React-приложениях.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№15/cookies-в-react-приложениях.html","showInTree":true,"treeOrder":152,"backlinks":["материалы/подтемы/секция-2.-react/тема-№15/хранение-данных-между-сессиями.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№15/localstorage-и-sessionstorage.html":{"createdTime":1760712584579,"modifiedTime":1760712594311,"sourceSize":3333,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №15/localStorage и sessionStorage.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№15/localstorage-и-sessionstorage.html","showInTree":true,"treeOrder":153,"backlinks":["материалы/подтемы/секция-2.-react/тема-№15/хранение-данных-между-сессиями.html"],"type":"markdown","data":null},"лекции/секция-2.-react/тема-№16.-события-и-ref-в-react.html":{"createdTime":1768641559295,"modifiedTime":1768934439265,"sourceSize":1070,"sourcePath":"Лекции/Секция 2. React/Тема №16. События и Ref в React.md","exportPath":"лекции/секция-2.-react/тема-№16.-события-и-ref-в-react.html","showInTree":true,"treeOrder":31,"backlinks":["лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html"],"type":"markdown","data":null},"лекции/секция-2.-react/тема-№17.-hooks-в-react.html":{"createdTime":1768643061201,"modifiedTime":1768931668144,"sourceSize":1060,"sourcePath":"Лекции/Секция 2. React/Тема №17. Hooks в React.md","exportPath":"лекции/секция-2.-react/тема-№17.-hooks-в-react.html","showInTree":true,"treeOrder":32,"backlinks":["лекции/секция-2.-react/тема-№16.-события-и-ref-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-хранения-значений.html":{"createdTime":1768642309999,"modifiedTime":1768642383557,"sourceSize":3738,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/Использование useRef для хранения значений.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-хранения-значений.html","showInTree":true,"treeOrder":157,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/что-такое-ref.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-dom-элементов.html":{"createdTime":1768642266128,"modifiedTime":1768642291997,"sourceSize":2955,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/Использование useRef для DOM-элементов.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-dom-элементов.html","showInTree":true,"treeOrder":158,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/что-такое-ref.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№16/когда-использовать-ref,-а-когда-—-state.html":{"createdTime":1768642774584,"modifiedTime":1768642811286,"sourceSize":3456,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/Когда использовать Ref, а когда — State.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/когда-использовать-ref,-а-когда-—-state.html","showInTree":true,"treeOrder":159,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/работа-с-формами.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№16/контролируемые-компоненты.html":{"createdTime":1768642706169,"modifiedTime":1768642708856,"sourceSize":3444,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/Контролируемые компоненты.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/контролируемые-компоненты.html","showInTree":true,"treeOrder":160,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/работа-с-формами.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№16/неконтролируемые-компоненты.html":{"createdTime":1768642714348,"modifiedTime":1768642768274,"sourceSize":4087,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/Неконтролируемые компоненты.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/неконтролируемые-компоненты.html","showInTree":true,"treeOrder":161,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/работа-с-формами.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№16/обработка-событий-в-react.html":{"createdTime":1768641742296,"modifiedTime":1768641889311,"sourceSize":3456,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/Обработка событий в React.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/обработка-событий-в-react.html","showInTree":true,"treeOrder":162,"backlinks":["лекции/секция-2.-react/тема-№16.-события-и-ref-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№16/ограничения-и-рекомендации.html":{"createdTime":1768642392326,"modifiedTime":1768642483908,"sourceSize":3795,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/Ограничения и рекомендации.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/ограничения-и-рекомендации.html","showInTree":true,"treeOrder":163,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/что-такое-ref.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№16/работа-с-формами.html":{"createdTime":1768642492729,"modifiedTime":1768642666241,"sourceSize":4250,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/Работа с формами.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/работа-с-формами.html","showInTree":true,"treeOrder":164,"backlinks":["лекции/секция-2.-react/тема-№16.-события-и-ref-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№16/что-такое-ref.html":{"createdTime":1768642202141,"modifiedTime":1768642257320,"sourceSize":2741,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/Что такое Ref.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/что-такое-ref.html","showInTree":true,"treeOrder":165,"backlinks":["лекции/секция-2.-react/тема-№16.-события-и-ref-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№16/onchange.html":{"createdTime":1768641987412,"modifiedTime":1768642016812,"sourceSize":2598,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/onChange.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/onchange.html","showInTree":true,"treeOrder":166,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/обработка-событий-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№16/onclick.html":{"createdTime":1768641956899,"modifiedTime":1768641981200,"sourceSize":2320,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/onClick.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/onclick.html","showInTree":true,"treeOrder":167,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/обработка-событий-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№16/onfocus-и-onblur.html":{"createdTime":1768642092377,"modifiedTime":1768642122257,"sourceSize":3312,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/onFocus и onBlur.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/onfocus-и-onblur.html","showInTree":true,"treeOrder":168,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/обработка-событий-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№16/onsubmit.html":{"createdTime":1768642063823,"modifiedTime":1768642091116,"sourceSize":2819,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №16/onSubmit.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№16/onsubmit.html","showInTree":true,"treeOrder":169,"backlinks":["материалы/подтемы/секция-2.-react/тема-№16/обработка-событий-в-react.html"],"type":"markdown","data":null},"лекции/секция-2.-react/тема-№18.-routers-в-react.html":{"createdTime":1768932838850,"modifiedTime":1768934149800,"sourceSize":1123,"sourcePath":"Лекции/Секция 2. React/Тема №18. Routers в React.md","exportPath":"лекции/секция-2.-react/тема-№18.-routers-в-react.html","showInTree":true,"treeOrder":33,"backlinks":["лекции/секция-2.-react/тема-№17.-hooks-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№17/пользовательские-hooks.html":{"createdTime":1768932498094,"modifiedTime":1768932627884,"sourceSize":4334,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №17/Пользовательские Hooks.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№17/пользовательские-hooks.html","showInTree":true,"treeOrder":172,"backlinks":["лекции/секция-2.-react/тема-№17.-hooks-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№17/правила-использования-hooks.html":{"createdTime":1768931877336,"modifiedTime":1768931917065,"sourceSize":2610,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №17/Правила использования Hooks.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№17/правила-использования-hooks.html","showInTree":true,"treeOrder":173,"backlinks":["лекции/секция-2.-react/тема-№17.-hooks-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№17/что-такое-hooks.html":{"createdTime":1768931668391,"modifiedTime":1768931833339,"sourceSize":2232,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №17/Что такое Hooks.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№17/что-такое-hooks.html","showInTree":true,"treeOrder":174,"backlinks":["лекции/секция-2.-react/тема-№17.-hooks-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№17/usecontext.html":{"createdTime":1768932306861,"modifiedTime":1768932382688,"sourceSize":4318,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №17/useContext.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№17/usecontext.html","showInTree":true,"treeOrder":175,"backlinks":["лекции/секция-2.-react/тема-№17.-hooks-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№17/useeffect.html":{"createdTime":1768932056147,"modifiedTime":1768932222025,"sourceSize":4232,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №17/useEffect.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№17/useeffect.html","showInTree":true,"treeOrder":176,"backlinks":["лекции/секция-2.-react/тема-№17.-hooks-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№18/вложенные-маршруты.html":{"createdTime":1768933576108,"modifiedTime":1768933795466,"sourceSize":3594,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №18/Вложенные маршруты.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№18/вложенные-маршруты.html","showInTree":true,"treeOrder":178,"backlinks":["лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№18/загрузка-данных-в-маршрутах.html":{"createdTime":1768934023918,"modifiedTime":1768934105541,"sourceSize":3955,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №18/Загрузка данных в маршрутах.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№18/загрузка-данных-в-маршрутах.html","showInTree":true,"treeOrder":179,"backlinks":["лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№18/обработка-несуществующих-маршрутов.html":{"createdTime":1768933956907,"modifiedTime":1768934021084,"sourceSize":2875,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №18/Обработка несуществующих маршрутов.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№18/обработка-несуществующих-маршрутов.html","showInTree":true,"treeOrder":180,"backlinks":["лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№18/основные-компоненты-react-router.html":{"createdTime":1768933314810,"modifiedTime":1768933449202,"sourceSize":3881,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №18/Основные компоненты React Router.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№18/основные-компоненты-react-router.html","showInTree":true,"treeOrder":181,"backlinks":["лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№18/параметры-маршрута.html":{"createdTime":1768933476262,"modifiedTime":1768933531259,"sourceSize":2860,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №18/Параметры маршрута.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№18/параметры-маршрута.html","showInTree":true,"treeOrder":182,"backlinks":["лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№18/программная-навигация.html":{"createdTime":1768933810314,"modifiedTime":1768933843278,"sourceSize":3238,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №18/Программная навигация.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№18/программная-навигация.html","showInTree":true,"treeOrder":183,"backlinks":["лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№18/что-такое-маршрутизация.html":{"createdTime":1768932909635,"modifiedTime":1768933004357,"sourceSize":2786,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №18/Что такое маршрутизация.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№18/что-такое-маршрутизация.html","showInTree":true,"treeOrder":184,"backlinks":["лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№18/react-router-—-основная-библиотека.html":{"createdTime":1768933056845,"modifiedTime":1768933288916,"sourceSize":2002,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №18/React Router — основная библиотека.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№18/react-router-—-основная-библиотека.html","showInTree":true,"treeOrder":185,"backlinks":["лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"type":"markdown","data":null},"site-lib/fonts/c504db5c06caaf7cdfba.woff2":{"createdTime":1770459144334,"modifiedTime":1770459144334,"sourceSize":352240,"sourcePath":"","exportPath":"site-lib/fonts/c504db5c06caaf7cdfba.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/01dcbad1bac635f9c9cd.woff2":{"createdTime":1770459144334,"modifiedTime":1770459144334,"sourceSize":387976,"sourcePath":"","exportPath":"site-lib/fonts/01dcbad1bac635f9c9cd.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html":{"createdTime":1770183889581,"modifiedTime":1770185338647,"sourceSize":1168,"sourcePath":"Лекции/Секция 2. React/Тема №19. Асинхронность в JavaScript.md","exportPath":"лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html","showInTree":true,"treeOrder":34,"backlinks":["лекции/секция-2.-react/тема-№18.-routers-в-react.html"],"type":"markdown","data":null},"лекции/секция-2.-react/тема-№20.-основы-typescript.html":{"createdTime":1770185322208,"modifiedTime":1770187494694,"sourceSize":956,"sourcePath":"Лекции/Секция 2. React/Тема №20. Основы TypeScript.md","exportPath":"лекции/секция-2.-react/тема-№20.-основы-typescript.html","showInTree":true,"treeOrder":35,"backlinks":["лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№19/асинхронность-и-react.html":{"createdTime":1770185252130,"modifiedTime":1770185308280,"sourceSize":4532,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №19/Асинхронность и React.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№19/асинхронность-и-react.html","showInTree":true,"treeOrder":189,"backlinks":["лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№19/коллбэки.html":{"createdTime":1770184096190,"modifiedTime":1770184157255,"sourceSize":3111,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №19/Коллбэки.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№19/коллбэки.html","showInTree":true,"treeOrder":190,"backlinks":["лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№19/промисы-(promise).html":{"createdTime":1770184294102,"modifiedTime":1770184443324,"sourceSize":4561,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №19/Промисы (Promise).md","exportPath":"материалы/подтемы/секция-2.-react/тема-№19/промисы-(promise).html","showInTree":true,"treeOrder":191,"backlinks":["лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№19/разница-между-await-и-then().html":{"createdTime":1770184978257,"modifiedTime":1770185010168,"sourceSize":3825,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №19/Разница между await и then().md","exportPath":"материалы/подтемы/секция-2.-react/тема-№19/разница-между-await-и-then().html","showInTree":true,"treeOrder":192,"backlinks":["лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№19/что-такое-асинхронность.html":{"createdTime":1770183949864,"modifiedTime":1770184027402,"sourceSize":2986,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №19/Что такое асинхронность.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№19/что-такое-асинхронность.html","showInTree":true,"treeOrder":193,"backlinks":["лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№19/async-и-await.html":{"createdTime":1770184677448,"modifiedTime":1770184729992,"sourceSize":4264,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №19/Async и await.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№19/async-и-await.html","showInTree":true,"treeOrder":194,"backlinks":["лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№20/базовые-типы-в-typescript.html":{"createdTime":1770187183900,"modifiedTime":1770187186558,"sourceSize":4761,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №20/Базовые типы в TypeScript.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№20/базовые-типы-в-typescript.html","showInTree":true,"treeOrder":196,"backlinks":["лекции/секция-2.-react/тема-№20.-основы-typescript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№20/настройка-проекта-с-typescript.html":{"createdTime":1770187166243,"modifiedTime":1770187168992,"sourceSize":3012,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №20/Настройка проекта с TypeScript.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№20/настройка-проекта-с-typescript.html","showInTree":true,"treeOrder":197,"backlinks":["лекции/секция-2.-react/тема-№20.-основы-typescript.html"],"type":"markdown","data":null},"материалы/подтемы/секция-2.-react/тема-№20/что-такое-typescript.html":{"createdTime":1770187025327,"modifiedTime":1770187381207,"sourceSize":3926,"sourcePath":"Материалы/Подтемы/Секция 2. React/Тема №20/Что такое TypeScript.md","exportPath":"материалы/подтемы/секция-2.-react/тема-№20/что-такое-typescript.html","showInTree":true,"treeOrder":198,"backlinks":["лекции/секция-2.-react/тема-№20.-основы-typescript.html"],"type":"markdown","data":null},"задания/секция-2.-react/практика-№11.-игра-кликер.html":{"createdTime":1770458568411,"modifiedTime":1770459097234,"sourceSize":4204,"sourcePath":"Задания/Секция 2. React/Практика №11. Игра-кликер.md","exportPath":"задания/секция-2.-react/практика-№11.-игра-кликер.html","showInTree":true,"treeOrder":13,"backlinks":[],"type":"markdown","data":null},"материалы/файлы/pasted-image-20260207130627.png":{"createdTime":1770458787751,"modifiedTime":1770458787752,"sourceSize":296662,"sourcePath":"Материалы/Файлы/Pasted image 20260207130627.png","exportPath":"материалы/файлы/pasted-image-20260207130627.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"материалы/файлы/pasted-image-20260207130627.html":{"createdTime":1770458787751,"modifiedTime":1770458787752,"sourceSize":296662,"sourcePath":"Материалы/Файлы/Pasted image 20260207130627.png","exportPath":"материалы/файлы/pasted-image-20260207130627.html","showInTree":true,"treeOrder":215,"backlinks":["задания/секция-2.-react/практика-№11.-игра-кликер.html"],"type":"attachment","data":null}},"sourceToTarget":{"Задания/Секция 1. JavaScript/Практика №1. Простая веб-страница с HTML.md":"задания/секция-1.-javascript/практика-№1.-простая-веб-страница-с-html.html","Задания/Секция 1. JavaScript/Практика №2. Использование git, github.md":"задания/секция-1.-javascript/практика-№2.-использование-git,-github.html","Задания/Секция 1. JavaScript/Практика №3. Вывод информации о себе в консоль..md":"задания/секция-1.-javascript/практика-№3.-вывод-информации-о-себе-в-консоль..html","Задания/Секция 1. JavaScript/Практика №4. Преобразование типов.md":"задания/секция-1.-javascript/практика-№4.-преобразование-типов.html","Задания/Секция 1. JavaScript/Практика №5. Использование ветвления..md":"задания/секция-1.-javascript/практика-№5.-использование-ветвления..html","Задания/Секция 1. JavaScript/Практика №6. Вывод таблицы умножения с помощью цикла for.md":"задания/секция-1.-javascript/практика-№6.-вывод-таблицы-умножения-с-помощью-цикла-for.html","Задания/Секция 1. JavaScript/Практика №7. Функции для работы с строками.md":"задания/секция-1.-javascript/практика-№7.-функции-для-работы-с-строками.html","Задания/Секция 1. JavaScript/Практика №8. SSR-сервер с динамической генерацией страниц.md":"задания/секция-1.-javascript/практика-№8.-ssr-сервер-с-динамической-генерацией-страниц.html","Лекции/Секция 1. JavaScript/Тема №1. Как создаются мобильные приложения.md":"лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html","Лекции/Секция 1. JavaScript/Тема №2. Основы JavaScript.md":"лекции/секция-1.-javascript/тема-№2.-основы-javascript.html","Лекции/Секция 1. JavaScript/Тема №3. Использование JavaScript в браузере.md":"лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html","Лекции/Секция 1. JavaScript/Тема №4. Node.JS, примитивные типы данных JavaScript.md":"лекции/секция-1.-javascript/тема-№4.-node.js,-примитивные-типы-данных-javascript.html","Лекции/Секция 1. JavaScript/Тема №5. Операторы и операции в JavaScript.md":"лекции/секция-1.-javascript/тема-№5.-операторы-и-операции-в-javascript.html","Лекции/Секция 1. JavaScript/Тема №6. Git, GitHub.md":"лекции/секция-1.-javascript/тема-№6.-git,-github.html","Лекции/Секция 1. JavaScript/Тема №7. Ветвление в JavaScript.md":"лекции/секция-1.-javascript/тема-№7.-ветвление-в-javascript.html","Лекции/Секция 1. JavaScript/Тема №8. Циклы в JavaScript.md":"лекции/секция-1.-javascript/тема-№8.-циклы-в-javascript.html","Лекции/Секция 1. JavaScript/Тема №9. Функции в JavaScript.md":"лекции/секция-1.-javascript/тема-№9.-функции-в-javascript.html","Лекции/Секция 1. JavaScript/Тема №10. Область видимости в JavaScript.md":"лекции/секция-1.-javascript/тема-№10.-область-видимости-в-javascript.html","Лекции/Секция 1. JavaScript/Тема №11. Массивы и объекты в JavaScript.md":"лекции/секция-1.-javascript/тема-№11.-массивы-и-объекты-в-javascript.html","Лекции/Секция 1. JavaScript/Тема №12. Создание сервера NodeJS. WEB 1.0 и WEB 2.0.md":"лекции/секция-1.-javascript/тема-№12.-создание-сервера-nodejs.-web-1.0-и-web-2.0.html","Материалы/Как сделать/Как создавать файлы с определённым расширением.md":"материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №1/Основные платформы мобильных приложений.md":"материалы/подтемы/секция-1.-javascript/тема-№1/основные-платформы-мобильных-приложений.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №1/Основные технологии для разработки мобильных приложений.md":"материалы/подтемы/секция-1.-javascript/тема-№1/основные-технологии-для-разработки-мобильных-приложений.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №1/Основные типы мобильных приложений.md":"материалы/подтемы/секция-1.-javascript/тема-№1/основные-типы-мобильных-приложений.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №2/Базовое понимание синтаксиса JavaScript.md":"материалы/подтемы/секция-1.-javascript/тема-№2/базовое-понимание-синтаксиса-javascript.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №2/Переменные в JavaScript.md":"материалы/подтемы/секция-1.-javascript/тема-№2/переменные-в-javascript.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №2/Правила наименования переменных в JavaScript.md":"материалы/подтемы/секция-1.-javascript/тема-№2/правила-наименования-переменных-в-javascript.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №2/Что такое JavaScript, история появления.md":"материалы/подтемы/секция-1.-javascript/тема-№2/что-такое-javascript,-история-появления.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №3/Базовая работа с элементами веб страницы через JavaScript.md":"материалы/подтемы/секция-1.-javascript/тема-№3/базовая-работа-с-элементами-веб-страницы-через-javascript.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №3/Основные понятия веб страницы.md":"материалы/подтемы/секция-1.-javascript/тема-№3/основные-понятия-веб-страницы.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №3/Самое простое использование JavaScript.md":"материалы/подтемы/секция-1.-javascript/тема-№3/самое-простое-использование-javascript.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №3/Создание своей HTML страницы.md":"материалы/подтемы/секция-1.-javascript/тема-№3/создание-своей-html-страницы.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №4/Примитивные типы данных JavaScript.md":"материалы/подтемы/секция-1.-javascript/тема-№4/примитивные-типы-данных-javascript.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №4/Установка и базовое использование Node.js.md":"материалы/подтемы/секция-1.-javascript/тема-№4/установка-и-базовое-использование-node.js.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №4/Что такое Node.js.md":"материалы/подтемы/секция-1.-javascript/тема-№4/что-такое-node.js.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Арифметические операторы JavaScript.md":"материалы/подтемы/секция-1.-javascript/тема-№5/арифметические-операторы-javascript.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Логические операторы JavaScript.md":"материалы/подтемы/секция-1.-javascript/тема-№5/логические-операторы-javascript.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Операторы присваивания JavaScript.md":"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-присваивания-javascript.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Операторы работы с битами.md":"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-работы-с-битами.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Операторы сравнения JavaScript.md":"материалы/подтемы/секция-1.-javascript/тема-№5/операторы-сравнения-javascript.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Определение оператора и операнда.md":"материалы/подтемы/секция-1.-javascript/тема-№5/определение-оператора-и-операнда.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №5/Приоритет операторов и ассоциативность.md":"материалы/подтемы/секция-1.-javascript/тема-№5/приоритет-операторов-и-ассоциативность.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Базовые команды Git.md":"материалы/подтемы/секция-1.-javascript/тема-№6/базовые-команды-git.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Основные понятия Git.md":"материалы/подтемы/секция-1.-javascript/тема-№6/основные-понятия-git.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Работа с ветками Git.md":"материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-ветками-git.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Работа с удалёнными репозиториями.md":"материалы/подтемы/секция-1.-javascript/тема-№6/работа-с-удалёнными-репозиториями.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Рекомендации по использованию Git.md":"материалы/подтемы/секция-1.-javascript/тема-№6/рекомендации-по-использованию-git.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Файл .gitignore.md":"материалы/подтемы/секция-1.-javascript/тема-№6/файл-.gitignore.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Что такое Git.md":"материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-git.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №6/Что такое GitHub.md":"материалы/подтемы/секция-1.-javascript/тема-№6/что-такое-github.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Оператор `else`.md":"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`else`.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Оператор `if`.md":"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`if`.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Оператор `switch`.md":"материалы/подтемы/секция-1.-javascript/тема-№7/оператор-`switch`.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Сравнение `if` и `switch`.md":"материалы/подтемы/секция-1.-javascript/тема-№7/сравнение-`if`-и-`switch`.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Тернарный оператор.md":"материалы/подтемы/секция-1.-javascript/тема-№7/тернарный-оператор.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Цепочки `else if`.md":"материалы/подтемы/секция-1.-javascript/тема-№7/цепочки-`else-if`.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №7/Что такое ветвление.md":"материалы/подтемы/секция-1.-javascript/тема-№7/что-такое-ветвление.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Прерывание и пропуск итераций.md":"материалы/подтемы/секция-1.-javascript/тема-№8/прерывание-и-пропуск-итераций.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Цикл `do...while`.md":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`do...while`.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Цикл `for...in` — перебор ключей объекта.md":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...in`-—-перебор-ключей-объекта.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Цикл `for...of` — перебор значений итерируемых объектов.md":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-`for...of`-—-перебор-значений-итерируемых-объектов.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Цикл for.md":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-for.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Цикл while.md":"материалы/подтемы/секция-1.-javascript/тема-№8/цикл-while.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Циклы и производительность.md":"материалы/подтемы/секция-1.-javascript/тема-№8/циклы-и-производительность.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №8/Что такое цикл.md":"материалы/подтемы/секция-1.-javascript/тема-№8/что-такое-цикл.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Возвращаемое значение.md":"материалы/подтемы/секция-1.-javascript/тема-№9/возвращаемое-значение.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Объявление функции (Function Declaration).md":"материалы/подтемы/секция-1.-javascript/тема-№9/объявление-функции-(function-declaration).html","Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Параметры и аргументы.md":"материалы/подтемы/секция-1.-javascript/тема-№9/параметры-и-аргументы.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Рекурсия.md":"материалы/подтемы/секция-1.-javascript/тема-№9/рекурсия.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Стрелочные функции (Arrow Function).md":"материалы/подтемы/секция-1.-javascript/тема-№9/стрелочные-функции-(arrow-function).html","Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Функциональное выражение (Function Expression).md":"материалы/подтемы/секция-1.-javascript/тема-№9/функциональное-выражение-(function-expression).html","Материалы/Подтемы/Секция 1. JavaScript/Тема №9/Что такое функция.md":"материалы/подтемы/секция-1.-javascript/тема-№9/что-такое-функция.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Блочная область видимости.md":"материалы/подтемы/секция-1.-javascript/тема-№10/блочная-область-видимости.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Вложенность областей видимости.md":"материалы/подтемы/секция-1.-javascript/тема-№10/вложенность-областей-видимости.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Глобальная область видимости.md":"материалы/подтемы/секция-1.-javascript/тема-№10/глобальная-область-видимости.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Замыкания.md":"материалы/подтемы/секция-1.-javascript/тема-№10/замыкания.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Каррированные функции.md":"материалы/подтемы/секция-1.-javascript/тема-№10/каррированные-функции.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Практические последствия (var).md":"материалы/подтемы/секция-1.-javascript/тема-№10/практические-последствия-(var).html","Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Функциональная область видимости.md":"материалы/подтемы/секция-1.-javascript/тема-№10/функциональная-область-видимости.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №10/Что такое область видимости.md":"материалы/подтемы/секция-1.-javascript/тема-№10/что-такое-область-видимости.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Вложенные структуры.md":"материалы/подтемы/секция-1.-javascript/тема-№11/вложенные-структуры.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Конструктор массива Array.md":"материалы/подтемы/секция-1.-javascript/тема-№11/конструктор-массива-array.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Массивы.md":"материалы/подтемы/секция-1.-javascript/тема-№11/массивы.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Объекты.md":"материалы/подтемы/секция-1.-javascript/тема-№11/объекты.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Оператор rest.md":"материалы/подтемы/секция-1.-javascript/тема-№11/оператор-rest.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Практические рекомендации по массивам и объектам.md":"материалы/подтемы/секция-1.-javascript/тема-№11/практические-рекомендации-по-массивам-и-объектам.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Преобразование типов (Массивы и Объекты) через JSON.md":"материалы/подтемы/секция-1.-javascript/тема-№11/преобразование-типов-(массивы-и-объекты)-через-json.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №11/Распаковка (spread).md":"материалы/подтемы/секция-1.-javascript/тема-№11/распаковка-(spread).html","Материалы/Подтемы/Секция 1. JavaScript/Тема №12/Вкратце о REST.md":"материалы/подтемы/секция-1.-javascript/тема-№12/вкратце-о-rest.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №12/Гидратация.md":"материалы/подтемы/секция-1.-javascript/тема-№12/гидратация.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №12/Маршрутизация в NodeJS.md":"материалы/подтемы/секция-1.-javascript/тема-№12/маршрутизация-в-nodejs.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №12/Основы сервера на NodeJS.md":"материалы/подтемы/секция-1.-javascript/тема-№12/основы-сервера-на-nodejs.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №12/Отправка файлов с сервера.md":"материалы/подтемы/секция-1.-javascript/тема-№12/отправка-файлов-с-сервера.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №12/Разница между WEB 1.0 и WEB 2.0 в контексте NodeJS.md":"материалы/подтемы/секция-1.-javascript/тема-№12/разница-между-web-1.0-и-web-2.0-в-контексте-nodejs.html","Материалы/Подтемы/Секция 1. JavaScript/Тема №12/WEB 1.0 (статический веб).md":"материалы/подтемы/секция-1.-javascript/тема-№12/web-1.0-(статический-веб).html","Материалы/Подтемы/Секция 1. JavaScript/Тема №12/WEB 2.0 (интерактивный веб).md":"материалы/подтемы/секция-1.-javascript/тема-№12/web-2.0-(интерактивный-веб).html","Материалы/Файлы/Pasted image 20240923235323.png":"материалы/файлы/pasted-image-20240923235323.html","Материалы/Файлы/Pasted image 20240928221620.png":"материалы/файлы/pasted-image-20240928221620.html","Материалы/Файлы/Pasted image 20240928222139.png":"материалы/файлы/pasted-image-20240928222139.html","Материалы/Файлы/Pasted image 20240928222237.png":"материалы/файлы/pasted-image-20240928222237.html","Материалы/Файлы/Pasted image 20250912205946.png":"материалы/файлы/pasted-image-20250912205946.html","Материалы/Файлы/Pasted image 20250912212732.png":"материалы/файлы/pasted-image-20250912212732.html","Материалы/Файлы/Pasted image 20250912212810.png":"материалы/файлы/pasted-image-20250912212810.html","Материалы/Файлы/Pasted image 20250912212840.png":"материалы/файлы/pasted-image-20250912212840.html","Материалы/Файлы/Pasted image 20250912214611.png":"материалы/файлы/pasted-image-20250912214611.html","Материалы/Файлы/Pasted image 20250912214624.png":"материалы/файлы/pasted-image-20250912214624.html","Материалы/Файлы/Pasted image 20250912214643.png":"материалы/файлы/pasted-image-20250912214643.html","Материалы/Файлы/Pasted image 20250912214649.png":"материалы/файлы/pasted-image-20250912214649.html","Материалы/Файлы/Pasted image 20250912214653.png":"материалы/файлы/pasted-image-20250912214653.html","Материалы/Файлы/Pasted image 20250917202240.png":"материалы/файлы/pasted-image-20250917202240.html","Материалы/Файлы/qrcod_72k5.png":"материалы/файлы/qrcod_72k5.html","index.md":"index.html","":"site-lib/rss.xml","Задания/Секция 1. JavaScript/Практика №9. CSR с гидратацией. Интерактивный счётчик.md":"задания/секция-1.-javascript/практика-№9.-csr-с-гидратацией.-интерактивный-счётчик.html","Задания/Секция 2. React/Практика №10. Интерактивный счётчик с изменением темы.md":"задания/секция-2.-react/практика-№10.-интерактивный-счётчик-с-изменением-темы.html","Лекции/Секция 2. React/Тема №13. Основы React.md":"лекции/секция-2.-react/тема-№13.-основы-react.html","Лекции/Секция 2. React/Тема №14. Работа со стилями, изображениями и файлами в React.md":"лекции/секция-2.-react/тема-№14.-работа-со-стилями,-изображениями-и-файлами-в-react.html","Лекции/Секция 2. React/Тема №15. Хранение и передача данных в React.md":"лекции/секция-2.-react/тема-№15.-хранение-и-передача-данных-в-react.html","Материалы/Заготовки под практики/react-project.zip":"материалы/заготовки-под-практики/react-project.zip","Материалы/Подтемы/Секция 2. React/Тема №13/Компоненты.md":"материалы/подтемы/секция-2.-react/тема-№13/компоненты.html","Материалы/Подтемы/Секция 2. React/Тема №13/Создание и запуск React-проекта.md":"материалы/подтемы/секция-2.-react/тема-№13/создание-и-запуск-react-проекта.html","Материалы/Подтемы/Секция 2. React/Тема №13/Типичная структура React-приложения.md":"материалы/подтемы/секция-2.-react/тема-№13/типичная-структура-react-приложения.html","Материалы/Подтемы/Секция 2. React/Тема №13/Что такое React.md":"материалы/подтемы/секция-2.-react/тема-№13/что-такое-react.html","Материалы/Подтемы/Секция 2. React/Тема №13/Create React App (CRA).md":"материалы/подтемы/секция-2.-react/тема-№13/create-react-app-(cra).html","Материалы/Подтемы/Секция 2. React/Тема №13/JSX.md":"материалы/подтемы/секция-2.-react/тема-№13/jsx.html","Материалы/Подтемы/Секция 2. React/Тема №13/Vite.md":"материалы/подтемы/секция-2.-react/тема-№13/vite.html","Материалы/Подтемы/Секция 2. React/Тема №14/Аудио и видео.md":"материалы/подтемы/секция-2.-react/тема-№14/аудио-и-видео.html","Материалы/Подтемы/Секция 2. React/Тема №14/Изображения.md":"материалы/подтемы/секция-2.-react/тема-№14/изображения.html","Материалы/Подтемы/Секция 2. React/Тема №14/Импорт функций и переменных JS.md":"материалы/подтемы/секция-2.-react/тема-№14/импорт-функций-и-переменных-js.html","Материалы/Подтемы/Секция 2. React/Тема №14/Как React обрабатывает импорт файлов.md":"материалы/подтемы/секция-2.-react/тема-№14/как-react-обрабатывает-импорт-файлов.html","Материалы/Подтемы/Секция 2. React/Тема №14/Какие файлы можно импортировать.md":"материалы/подтемы/секция-2.-react/тема-№14/какие-файлы-можно-импортировать.html","Материалы/Подтемы/Секция 2. React/Тема №14/Практические ошибки и как их избежать.md":"материалы/подтемы/секция-2.-react/тема-№14/практические-ошибки-и-как-их-избежать.html","Материалы/Подтемы/Секция 2. React/Тема №14/Работа со стилями и файлами.md":"материалы/подтемы/секция-2.-react/тема-№14/работа-со-стилями-и-файлами.html","Материалы/Подтемы/Секция 2. React/Тема №14/Что делать с файлами в папке public.md":"материалы/подтемы/секция-2.-react/тема-№14/что-делать-с-файлами-в-папке-public.html","Материалы/Подтемы/Секция 2. React/Тема №14/Шрифты.md":"материалы/подтемы/секция-2.-react/тема-№14/шрифты.html","Материалы/Подтемы/Секция 2. React/Тема №14/env-файлы.md":"материалы/подтемы/секция-2.-react/тема-№14/env-файлы.html","Материалы/Подтемы/Секция 2. React/Тема №14/JSON-файлы.md":"материалы/подтемы/секция-2.-react/тема-№14/json-файлы.html","Материалы/Подтемы/Секция 2. React/Тема №14/SVG.md":"материалы/подтемы/секция-2.-react/тема-№14/svg.html","Материалы/Подтемы/Секция 2. React/Тема №15/Передача данных через props.md":"материалы/подтемы/секция-2.-react/тема-№15/передача-данных-через-props.html","Материалы/Подтемы/Секция 2. React/Тема №15/Передача функций как props.md":"материалы/подтемы/секция-2.-react/тема-№15/передача-функций-как-props.html","Материалы/Подтемы/Секция 2. React/Тема №15/Состояние и хук useState.md":"материалы/подтемы/секция-2.-react/тема-№15/состояние-и-хук-usestate.html","Материалы/Подтемы/Секция 2. React/Тема №15/Хранение данных между сессиями.md":"материалы/подтемы/секция-2.-react/тема-№15/хранение-данных-между-сессиями.html","Материалы/Подтемы/Секция 2. React/Тема №15/Cookies в React-приложениях.md":"материалы/подтемы/секция-2.-react/тема-№15/cookies-в-react-приложениях.html","Материалы/Подтемы/Секция 2. React/Тема №15/localStorage и sessionStorage.md":"материалы/подтемы/секция-2.-react/тема-№15/localstorage-и-sessionstorage.html","Лекции/Секция 2. React/Тема №16. События и Ref в React.md":"лекции/секция-2.-react/тема-№16.-события-и-ref-в-react.html","Лекции/Секция 2. React/Тема №17. Hooks в React.md":"лекции/секция-2.-react/тема-№17.-hooks-в-react.html","Материалы/Подтемы/Секция 2. React/Тема №16/Использование useRef для хранения значений.md":"материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-хранения-значений.html","Материалы/Подтемы/Секция 2. React/Тема №16/Использование useRef для DOM-элементов.md":"материалы/подтемы/секция-2.-react/тема-№16/использование-useref-для-dom-элементов.html","Материалы/Подтемы/Секция 2. React/Тема №16/Когда использовать Ref, а когда — State.md":"материалы/подтемы/секция-2.-react/тема-№16/когда-использовать-ref,-а-когда-—-state.html","Материалы/Подтемы/Секция 2. React/Тема №16/Контролируемые компоненты.md":"материалы/подтемы/секция-2.-react/тема-№16/контролируемые-компоненты.html","Материалы/Подтемы/Секция 2. React/Тема №16/Неконтролируемые компоненты.md":"материалы/подтемы/секция-2.-react/тема-№16/неконтролируемые-компоненты.html","Материалы/Подтемы/Секция 2. React/Тема №16/Обработка событий в React.md":"материалы/подтемы/секция-2.-react/тема-№16/обработка-событий-в-react.html","Материалы/Подтемы/Секция 2. React/Тема №16/Ограничения и рекомендации.md":"материалы/подтемы/секция-2.-react/тема-№16/ограничения-и-рекомендации.html","Материалы/Подтемы/Секция 2. React/Тема №16/Работа с формами.md":"материалы/подтемы/секция-2.-react/тема-№16/работа-с-формами.html","Материалы/Подтемы/Секция 2. React/Тема №16/Что такое Ref.md":"материалы/подтемы/секция-2.-react/тема-№16/что-такое-ref.html","Материалы/Подтемы/Секция 2. React/Тема №16/onChange.md":"материалы/подтемы/секция-2.-react/тема-№16/onchange.html","Материалы/Подтемы/Секция 2. React/Тема №16/onClick.md":"материалы/подтемы/секция-2.-react/тема-№16/onclick.html","Материалы/Подтемы/Секция 2. React/Тема №16/onFocus и onBlur.md":"материалы/подтемы/секция-2.-react/тема-№16/onfocus-и-onblur.html","Материалы/Подтемы/Секция 2. React/Тема №16/onSubmit.md":"материалы/подтемы/секция-2.-react/тема-№16/onsubmit.html","Лекции/Секция 2. React/Тема №18. Routers в React.md":"лекции/секция-2.-react/тема-№18.-routers-в-react.html","Материалы/Подтемы/Секция 2. React/Тема №17/Пользовательские Hooks.md":"материалы/подтемы/секция-2.-react/тема-№17/пользовательские-hooks.html","Материалы/Подтемы/Секция 2. React/Тема №17/Правила использования Hooks.md":"материалы/подтемы/секция-2.-react/тема-№17/правила-использования-hooks.html","Материалы/Подтемы/Секция 2. React/Тема №17/Что такое Hooks.md":"материалы/подтемы/секция-2.-react/тема-№17/что-такое-hooks.html","Материалы/Подтемы/Секция 2. React/Тема №17/useContext.md":"материалы/подтемы/секция-2.-react/тема-№17/usecontext.html","Материалы/Подтемы/Секция 2. React/Тема №17/useEffect.md":"материалы/подтемы/секция-2.-react/тема-№17/useeffect.html","Материалы/Подтемы/Секция 2. React/Тема №18/Вложенные маршруты.md":"материалы/подтемы/секция-2.-react/тема-№18/вложенные-маршруты.html","Материалы/Подтемы/Секция 2. React/Тема №18/Загрузка данных в маршрутах.md":"материалы/подтемы/секция-2.-react/тема-№18/загрузка-данных-в-маршрутах.html","Материалы/Подтемы/Секция 2. React/Тема №18/Обработка несуществующих маршрутов.md":"материалы/подтемы/секция-2.-react/тема-№18/обработка-несуществующих-маршрутов.html","Материалы/Подтемы/Секция 2. React/Тема №18/Основные компоненты React Router.md":"материалы/подтемы/секция-2.-react/тема-№18/основные-компоненты-react-router.html","Материалы/Подтемы/Секция 2. React/Тема №18/Параметры маршрута.md":"материалы/подтемы/секция-2.-react/тема-№18/параметры-маршрута.html","Материалы/Подтемы/Секция 2. React/Тема №18/Программная навигация.md":"материалы/подтемы/секция-2.-react/тема-№18/программная-навигация.html","Материалы/Подтемы/Секция 2. React/Тема №18/Что такое маршрутизация.md":"материалы/подтемы/секция-2.-react/тема-№18/что-такое-маршрутизация.html","Материалы/Подтемы/Секция 2. React/Тема №18/React Router — основная библиотека.md":"материалы/подтемы/секция-2.-react/тема-№18/react-router-—-основная-библиотека.html","Лекции/Секция 2. React/Тема №19. Асинхронность в JavaScript.md":"лекции/секция-2.-react/тема-№19.-асинхронность-в-javascript.html","Лекции/Секция 2. React/Тема №20. Основы TypeScript.md":"лекции/секция-2.-react/тема-№20.-основы-typescript.html","Материалы/Подтемы/Секция 2. React/Тема №19/Асинхронность и React.md":"материалы/подтемы/секция-2.-react/тема-№19/асинхронность-и-react.html","Материалы/Подтемы/Секция 2. React/Тема №19/Коллбэки.md":"материалы/подтемы/секция-2.-react/тема-№19/коллбэки.html","Материалы/Подтемы/Секция 2. React/Тема №19/Промисы (Promise).md":"материалы/подтемы/секция-2.-react/тема-№19/промисы-(promise).html","Материалы/Подтемы/Секция 2. React/Тема №19/Разница между await и then().md":"материалы/подтемы/секция-2.-react/тема-№19/разница-между-await-и-then().html","Материалы/Подтемы/Секция 2. React/Тема №19/Что такое асинхронность.md":"материалы/подтемы/секция-2.-react/тема-№19/что-такое-асинхронность.html","Материалы/Подтемы/Секция 2. React/Тема №19/Async и await.md":"материалы/подтемы/секция-2.-react/тема-№19/async-и-await.html","Материалы/Подтемы/Секция 2. React/Тема №20/Базовые типы в TypeScript.md":"материалы/подтемы/секция-2.-react/тема-№20/базовые-типы-в-typescript.html","Материалы/Подтемы/Секция 2. React/Тема №20/Настройка проекта с TypeScript.md":"материалы/подтемы/секция-2.-react/тема-№20/настройка-проекта-с-typescript.html","Материалы/Подтемы/Секция 2. React/Тема №20/Что такое TypeScript.md":"материалы/подтемы/секция-2.-react/тема-№20/что-такое-typescript.html","Задания/Секция 2. React/Практика №11. Игра-кликер.md":"задания/секция-2.-react/практика-№11.-игра-кликер.html","Материалы/Файлы/Pasted image 20260207130627.png":"материалы/файлы/pasted-image-20260207130627.html"},"featureOptions":{"backlinks":{"featureId":"backlinks","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".footer","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Backlinks","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"tags":{"featureId":"tags","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header .data-bar","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"showInlineTags":true,"showFrontmatterTags":true,"info_showInlineTags":{"show":true,"name":"","description":"Show tags defined inside the document at the top of the page.","placeholder":""},"info_showFrontmatterTags":{"show":true,"name":"","description":"Show tags defined in the frontmatter of the document at the top of the page.","placeholder":""}},"alias":{"featureId":"aliases","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header .data-bar","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Aliases","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"properties":{"featureId":"properties","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Properties","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_hideProperties":{"show":true,"name":"","description":"A list of properties to hide from the properties view","placeholder":""}},"fileNavigation":{"featureId":"file-navigation","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"showCustomIcons":false,"showDefaultFolderIcons":false,"showDefaultFileIcons":false,"defaultFolderIcon":"lucide//folder","defaultFileIcon":"lucide//file","defaultMediaIcon":"lucide//file-image","exposeStartingPath":true,"info_showCustomIcons":{"show":true,"name":"","description":"Show custom icons for files and folders","placeholder":""},"info_showDefaultFolderIcons":{"show":true,"name":"","description":"Show a default icon of a folder for every folder in the tree","placeholder":""},"info_showDefaultFileIcons":{"show":true,"name":"","description":"Show a default icon of a file for every file in the tree","placeholder":""},"info_defaultFolderIcon":{"show":true,"name":"","description":"The icon to use for folders. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultFileIcon":{"show":true,"name":"","description":"The icon to use for files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultMediaIcon":{"show":true,"name":"","description":"The icon to use for media files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_exposeStartingPath":{"show":true,"name":"","description":"Whether or not to show the current file in the file tree when the page is first loaded","placeholder":""},"includePath":"site-lib/html/file-tree.html"},"search":{"featureId":"search","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Search...","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"outline":{"featureId":"outline","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Outline","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"startCollapsed":false,"minCollapseDepth":0,"info_startCollapsed":{"show":true,"name":"","description":"Should the outline start collapsed?","placeholder":""},"info_minCollapseDepth":{"show":true,"name":"","description":"Only allow outline items to be collapsed if they are at least this many levels deep in the tree.","placeholder":"","dropdownOptions":{"1":1,"2":2,"No Collapse":100}}},"themeToggle":{"featureId":"theme-toggle","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"graphView":{"featureId":"graph-view","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Graph View","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"showOrphanNodes":true,"showAttachments":false,"allowGlobalGraph":true,"allowExpand":true,"attractionForce":1,"linkLength":15,"repulsionForce":80,"centralForce":2,"edgePruning":100,"minNodeRadius":3,"maxNodeRadius":7,"info_showOrphanNodes":{"show":true,"name":"","description":"Show nodes that are not connected to any other nodes.","placeholder":""},"info_showAttachments":{"show":true,"name":"","description":"Show attachments like images and PDFs as nodes in the graph.","placeholder":""},"info_allowGlobalGraph":{"show":true,"name":"","description":"Allow the user to view the global graph of all nodes.","placeholder":""},"info_allowExpand":{"show":true,"name":"","description":"Allow the user to pop-out the graph view to take up the whole screen","placeholder":""},"info_attractionForce":{"show":true,"name":"","description":"How much should linked nodes attract each other? This will make the graph appear more clustered.","placeholder":""},"info_linkLength":{"show":true,"name":"","description":"How long should the links between nodes be? The shorter the links the more connected nodes will cluster together.","placeholder":""},"info_repulsionForce":{"show":true,"name":"","description":"How much should nodes repel each other? This will make disconnected parts more spread out.","placeholder":""},"info_centralForce":{"show":true,"name":"","description":"How much should nodes be attracted to the center? This will make the graph appear more dense and circular.","placeholder":""},"info_edgePruning":{"show":true,"name":"","description":"Edges with a length above this threshold will not be rendered, however they will still contribute to the simulation. This can help large tangled graphs look more organised. Hovering over a node will still display these links.","placeholder":""},"info_minNodeRadius":{"show":true,"name":"","description":"How small should the smallest nodes be? The smaller a node is the less it will attract other nodes.","placeholder":""},"info_maxNodeRadius":{"show":true,"name":"","description":"How large should the largest nodes be? Nodes are sized by how many links they have. The larger a node is the more it will attract other nodes. This can be used to create a good grouping around the most important nodes.","placeholder":""}},"sidebar":{"featureId":"sidebar","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"allowResizing":true,"allowCollapsing":true,"rightDefaultWidth":"20em","leftDefaultWidth":"20em","info_allowResizing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be resized","placeholder":""},"info_allowCollapsing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be collapsed","placeholder":""},"info_rightDefaultWidth":{"show":true,"name":"","description":"The default width of the right sidebar","placeholder":""},"info_leftDefaultWidth":{"show":true,"name":"","description":"The default width of the left sidebar","placeholder":""}},"customHead":{"featureId":"custom-head","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"head","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"sourcePath":"","info_sourcePath":{"show":true,"name":"","description":"The local path to the source .html file which will be included.","placeholder":"","fileInputOptions":{"makeRelativeToVault":true,"browseButton":true}},"includePath":"site-lib/html/custom-head.html"},"document":{"featureId":"obsidian-document","enabled":true,"unavailable":false,"alwaysEnabled":true,"hideSettingsButton":false,"allowFoldingLists":true,"allowFoldingHeadings":true,"documentWidth":"40em","info_allowFoldingLists":{"show":true,"name":"","description":"Whether or not to allow lists to be folded","placeholder":""},"info_allowFoldingHeadings":{"show":true,"name":"","description":"Whether or not to allow headings to be folded","placeholder":""},"info_documentWidth":{"show":true,"name":"","description":"The width of the document","placeholder":""}},"rss":{"featureId":"rss","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"siteUrl":"","authorName":"","info_siteUrl":{"show":true,"name":"","description":"The url that this site will be hosted at","placeholder":"https://example.com/mysite"},"info_authorName":{"show":true,"name":"","description":"The name of the author of the site","placeholder":""}},"linkPreview":{"featureId":"link-preview","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":true}},"modifiedTime":1770459144433,"siteName":"MobileDevTisbi","vaultName":"MobileDevTisbi","exportRoot":"","baseURL":"","pluginVersion":"1.9.2","themeName":"","bodyClasses":"publish css-settings-manager styled-scrollbars show-inline-title show-ribbon is-focused","hasFavicon":false}