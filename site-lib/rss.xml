<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[MobileDevTisbi]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>MobileDevTisbi</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 12 Sep 2025 19:11:25 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 12 Sep 2025 19:11:21 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Практика №1. Простая веб-страница с HTML]]></title><description><![CDATA[В рамках этого задания вам необходимо добавить логику при нажатиях на кнопку к существующей веб-странице.Задания обязано быть сделано в собственной директории используя изначальный шаблон html файла из ресурсов index.html (может быть модернизирован) и внешний js файл в той же папке (создается самостоятельно).index.html&lt;!DOCTYPE html&gt;
&lt;html lang="ru"&gt;
&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Изучаем JS в рамках html страницы&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt; Эта страница содержит JS код который выполняется на стороне клиента. &lt;br/&gt; &lt;button id="button-1"&gt; Эта кнопка выводит сообщение в консоль &lt;/button&gt; &lt;button id="button-2"&gt; Эта кнопка выводит опощение в браузере &lt;/button&gt; &lt;br/&gt; &lt;button id="button-3"&gt; Эта кнопка меняет цвет фона на красный &lt;/button&gt; &lt;button id="button-4"&gt; Эта кнопка меняет цвет фона на белый &lt;/button&gt; &lt;br/&gt; &lt;textarea id="text-1"&gt; &lt;/textarea&gt; &lt;br/&gt; &lt;button id="button-5"&gt; Сложить число выше с числом 6 &lt;/button&gt; &lt;div id="answer"&gt; ТУТ БУДЕТ ОТВЕТ &lt;/div&gt; &lt;/body&gt;
&lt;/html&gt;
Необходимо добавить логику для кнопок:
Первые две кнопки должны выводить информацию в консоль и в качестве оповещения в браузере.
Кнопки 3-4 должны менять цвет фона в соответствии с текстом кнопки
Кнопка 5 должна получить текст из текстового поля text-1, получить число из строки при помощи функции parseFloat, и проверить на NaN при помощи функции isNaN. Если это число - сложить с числом 6 и записать ответ в div с id answer.
Вам необходимо добавить дополнительное поле ввода для 5 кнопки.
В итоге пользователь должен вписать два числа в два поля и в итоге получить ответ сложениях этих двух чисел.На выполнение выделяется 1 практическая пара.
Градация баллов после дедлайна:
1 пара: 50%
2 пара: 0%
]]></description><link>задания/секция-1.-javascript/практика-№1.-простая-веб-страница-с-html.html</link><guid isPermaLink="false">Задания/Секция 1. JavaScript/Практика №1. Простая веб-страница с HTML.md</guid><pubDate>Fri, 12 Sep 2025 19:10:46 GMT</pubDate></item><item><title><![CDATA[Тема №3. Использование JavaScript в браузере]]></title><description><![CDATA[В этой теме вы познакомитесь с практическим применением JavaScript в контексте веб-страниц: научитесь использовать консоль разработчика для тестирования кода, поймёте структуру HTML и роль DOM, освоите базовые способы взаимодействия с элементами страницы через JavaScript — получение, изменение содержимого и стилей. Вы создадите первую HTML-страницу с подключённым JavaScript, изучите корректные способы интеграции скриптов и назначения обработчиков событий, избегая устаревших практик.
<a data-href="Самое простое использование JavaScript" href="материалы/подтемы/секция-1.-javascript/самое-простое-использование-javascript.html" class="internal-link" target="_self" rel="noopener nofollow">Самое простое использование JavaScript</a>
<br><a data-href="Основные понятия веб страницы" href="материалы/подтемы/секция-1.-javascript/основные-понятия-веб-страницы.html" class="internal-link" target="_self" rel="noopener nofollow">Основные понятия веб страницы</a>
<br><a data-href="Базовая работа с элементами веб страницы через JavaScript" href="материалы/подтемы/секция-1.-javascript/базовая-работа-с-элементами-веб-страницы-через-javascript.html" class="internal-link" target="_self" rel="noopener nofollow">Базовая работа с элементами веб страницы через JavaScript</a>
<br><a data-href="Создание своей HTML страницы" href="материалы/подтемы/секция-1.-javascript/создание-своей-html-страницы.html" class="internal-link" target="_self" rel="noopener nofollow">Создание своей HTML страницы</a> <br><a data-href="Практика №1. Простая веб-страница с HTML" href="задания/секция-1.-javascript/практика-№1.-простая-веб-страница-с-html.html" class="internal-link" target="_self" rel="noopener nofollow">Практика №1. Простая веб-страница с HTML</a>
<br><a data-href="Тема №4. Node.JS, примитивные типы данных JavaScript" href=".html" class="internal-link" target="_self" rel="noopener nofollow">Тема №4. Node.JS, примитивные типы данных JavaScript</a>]]></description><link>лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html</link><guid isPermaLink="false">Лекции/Секция 1. JavaScript/Тема №3. Использование JavaScript в браузере.md</guid><pubDate>Fri, 12 Sep 2025 18:54:56 GMT</pubDate></item><item><title><![CDATA[Создание своей HTML страницы]]></title><description><![CDATA[Чтобы создать HTML-страницу, достаточно использовать любой текстовый редактор — даже Блокнот. Однако для эффективной разработки рекомендуется использовать современный редактор кода, такой как Visual Studio Code (VS Code).HTML-страница — это текстовый файл с расширением .html. Минимальная структура HTML-документа выглядит так:&lt;!DOCTYPE html&gt;
&lt;html lang="ru"&gt;
&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Моя первая страница&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt; &lt;h1&gt;Привет, мир!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
Сохраните этот код в файл с именем, например, index.html. Откройте его в браузере — вы увидите заголовок «Привет, мир!». Это и есть ваша первая веб-страница.<a data-href="Как создавать файлы с определённым расширением" href="материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html" class="internal-link" target="_self" rel="noopener nofollow">Как создавать файлы с определённым расширением</a>JavaScript можно подключать к HTML-странице двумя основными способами: встроенно (внутри HTML-файла) или через внешний файл. Второй способ — единственно правильный для профессиональной разработки.JavaScript можно вставить прямо внутрь HTML-документа с помощью тега &lt;script&gt;:&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt; &lt;title&gt;Страница с встроенным JS&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt; &lt;h1&gt;Привет!&lt;/h1&gt; &lt;script&gt; alert("Это встроенный JavaScript!"); document.write("&lt;p&gt;Текст добавлен скриптом.&lt;/p&gt;"); &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
Почему это не рекомендуется:
Нарушает принцип разделения ответственности: структура (HTML), стиль (CSS) и логика (JS) должны быть разделены.
Сложно поддерживать и масштабировать код — особенно при росте проекта.
Затрудняется повторное использование кода между страницами.
Ухудшается читаемость и тестирование.
Может замедлять загрузку страницы, если скрипт большой.
Используйте этот способ только для быстрых экспериментов, демонстраций или очень простых примеров.Правильный и стандартный способ — создать отдельный файл с расширением .js и подключить его к HTML:
Создайте файл script.js в той же папке, что и index.html.
Напишите в нём JavaScript-код:
// script.js
alert("Это внешний JavaScript-файл!");
document.querySelector('h1').style.color = 'blue'; Подключите его в HTML перед закрывающим тегом &lt;/body&gt;:
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt; &lt;title&gt;Страница с внешним JS&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt; &lt;h1&gt;Привет!&lt;/h1&gt; &lt;script src="script.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
Преимущества:
Чистый, организованный код.
Возможность переиспользования одного файла на нескольких страницах.
Упрощённая отладка и версионный контроль (Git).
Лучшая производительность — браузер может кэшировать внешние скрипты.
JavaScript следует подключать в самом конце тела HTML-документа, перед закрывающим тегом &lt;/body&gt;.Когда браузер встречает тег &lt;script&gt; во время парсинга HTML, он приостанавливает загрузку и разбор DOM-дерева, чтобы загрузить и выполнить скрипт. Если скрипт подключен в &lt;head&gt; или в начале &lt;body&gt;, а он пытается взаимодействовать с элементами, которые ещё не загружены — возникнет ошибка:&lt;head&gt; &lt;script src="script.js"&gt;&lt;/script&gt; &lt;!-- ❌ Опасно! --&gt;
&lt;/head&gt;
&lt;body&gt; &lt;button id="myButton"&gt;Нажми меня&lt;/button&gt;
&lt;/body&gt;
Если в script.js написано:document.getElementById('myButton').addEventListener('click', () =&gt; { alert('Клик!');
});
— то скрипт выполнится до того, как кнопка появится в DOM, и getElementById вернёт null. Результат — ошибка в консоли.&lt;body&gt; &lt;button id="myButton"&gt;Нажми меня&lt;/button&gt; &lt;script src="script.js"&gt;&lt;/script&gt; &lt;!-- ✅ Безопасно: DOM уже построен --&gt;
&lt;/body&gt;
Теперь браузер сначала полностью загрузит и отрисует все элементы страницы, а только потом выполнит скрипт — и все запросы к DOM будут успешными.
Быстрая отрисовка контента: пользователь видит страницу быстрее, без задержек из-за загрузки скриптов.
Предсказуемое поведение: код работает только тогда, когда всё, к чему он обращается, уже существует.
Совместимость с современными практиками: так делают все крупные фреймворки и библиотеки. Если скрипт не зависит от DOM (например, модуль аналитики, который запускается сразу при загрузке страницы), его можно размещать в &lt;head&gt;.
Использование атрибута defer (в &lt;head&gt;) позволяет отложить выполнение скрипта до завершения парсинга HTML — это альтернатива размещению в конце, но требует понимания нюансов.
&lt;head&gt; &lt;script src="script.js" defer&gt;&lt;/script&gt; &lt;!-- ✅ Альтернатива, если нужно в head --&gt;
&lt;/head&gt; ✅ Рекомендация: Всегда подключайте JavaScript-файлы перед закрывающим тегом &lt;/body&gt;, если только вы точно не знаете, что делаете и почему используете defer или async. Это — базовое правило надёжной и предсказуемой работы JavaScript на веб-странице.
Чтобы реагировать на действия пользователя (например, нажатие кнопки), можно назначить обработчик события двумя способами: через атрибуты HTML или через JavaScript. Второй способ — единственный корректный для профессиональной разработки.Можно напрямую вписать JavaScript-код в атрибут onclick элемента:&lt;button onclick="alert('Кнопка нажата!')"&gt;Нажми меня&lt;/button&gt;
Или вызвать функцию:&lt;script&gt;
function handleClick() { alert('Функция вызвана через атрибут!');
}
&lt;/script&gt; &lt;button onclick="handleClick()"&gt;Нажми меня&lt;/button&gt;
Почему это не рекомендуется:
Смешивание ответственности: логика (JS) и структура (HTML) сливаются — нарушает принцип разделения.
Сложность поддержки: сложно отлаживать, тестировать и рефакторить код, особенно при росте проекта.
Уязвимость к ошибкам: если имя функции опечатано — ошибка не будет заметна до момента клика.
Не масштабируемо: невозможно динамически добавлять/удалять обработчики, работать с несколькими элементами, использовать замыкания.
Проблемы с безопасностью: в некоторых контекстах (CSP) использование onclick может быть заблокировано. ⚠️ Используйте этот способ только для быстрых экспериментов или учебных примеров — никогда в продакшене.
Правильный и стандартный способ — назначать обработчики событий из JavaScript, после того как DOM загружен:&lt;button id="myButton"&gt;Нажми меня&lt;/button&gt; &lt;script src="script.js"&gt;&lt;/script&gt;
// script.js
const button = document.getElementById('myButton'); button.addEventListener('click', function() { alert('Кнопка нажата через addEventListener!');
});
Преимущества:
Полное разделение логики и разметки.
Возможность назначать несколько обработчиков на один элемент.
Легко удалять обработчики через removeEventListener.
Поддержка современных возможностей JS: стрелочные функции, async/await, замыкания.
Удобно работать с динамически создаваемыми элементами.
Совместимость с системами сборки, тестирования и фреймворками.
Дополнительно — лучшая практика:document.addEventListener('DOMContentLoaded', () =&gt; { const button = document.getElementById('myButton'); if (button) { button.addEventListener('click', () =&gt; { console.log('Клик обработан надёжно'); }); }
});
Это гарантирует, что скрипт выполнится только после полной загрузки DOM, даже если он подключён в &lt;head&gt;.Представим, что у нас есть кнопка в HTML:&lt;button id="myButton"&gt;Нажми меня&lt;/button&gt;
Мы хотим, чтобы при нажатии на неё в консоль браузера выводилось сообщение: "Кнопка была нажата!"
Убедитесь, что у вас есть файл script.js, и он подключен в конце &lt;body&gt;:&lt;body&gt; &lt;button id="myButton"&gt;Нажми меня&lt;/button&gt; &lt;script src="script.js"&gt;&lt;/script&gt;
&lt;/body&gt;
В script.js напишите:const button = document.getElementById('myButton');
Эта строка говорит браузеру:
👉 «Найди элемент на странице, у которого атрибут id="myButton"» — и сохрани его в переменную button.Теперь добавьте эту строку:button.addEventListener('click', () =&gt; { console.log('Кнопка была нажата!');
});
Что здесь происходит (без функций):
addEventListener — это встроенная команда, которая привязывает действие к элементу.
'click' — это тип события, которое мы хотим отслеживать (нажатие).
() — это просто способ сказать: «здесь будет код, который выполнится при событии».
console.log(...) — это команда, которая выводит текст в окно разработчика (не на экран). ✅ Всё, что внутри { } — это просто набор команд, которые должны сработать, когда пользователь кликнет.
Когда пользователь кликает по кнопке — в консоли браузера появляется сообщение: Кнопка была нажата!
Этот шаблон — основа всего дальнейшего взаимодействия с пользователем. Его нужно запомнить как фиксированную формулу:
элемент.addEventListener('событие', () =&gt; { ... });
И заменять:
элемент — на нужный вам (button, input, div и т.д.)
'событие' — на нужное (click, mouseover, keydown и т.д.)
{ ... } — на то, что вы хотите сделать (вывести сообщение, изменить цвет, отправить данные)
]]></description><link>материалы/подтемы/секция-1.-javascript/создание-своей-html-страницы.html</link><guid isPermaLink="false">Материалы/Подтемы/Секция 1. JavaScript/Создание своей HTML страницы.md</guid><pubDate>Fri, 12 Sep 2025 18:54:37 GMT</pubDate></item><item><title><![CDATA[Как создавать файлы с определённым расширением]]></title><description><![CDATA[Самый простой способ - создать файл через "проводник".
<img alt="Pasted image 20250912214611.png" src="материалы/файлы/pasted-image-20250912214611.png" target="_self">
Но для этого нужно сначала включить опцию чтобы мы могли видеть расширение файлов (по умолчанию оно скрыто, особенно на компьютерах колледжа).<br>
<img alt="Pasted image 20250912214624.png" src="материалы/файлы/pasted-image-20250912214624.png" target="_self">
Ну а дальше уже все просто, например нам нужно создать js файл&nbsp;example.js<br>
<img alt="Pasted image 20250912214643.png" src="материалы/файлы/pasted-image-20250912214643.png" target="_self"><br>
<img alt="Pasted image 20250912214649.png" src="материалы/файлы/pasted-image-20250912214649.png" target="_self"><img alt="Pasted image 20250912214653.png" src="материалы/файлы/pasted-image-20250912214653.png" target="_self">]]></description><link>материалы/как-сделать/как-создавать-файлы-с-определённым-расширением.html</link><guid isPermaLink="false">Материалы/Как сделать/Как создавать файлы с определённым расширением.md</guid><pubDate>Fri, 12 Sep 2025 18:46:55 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250912214653]]></title><description><![CDATA[<img src="материалы/файлы/pasted-image-20250912214653.png" target="_self">]]></description><link>материалы/файлы/pasted-image-20250912214653.html</link><guid isPermaLink="false">Материалы/Файлы/Pasted image 20250912214653.png</guid><pubDate>Fri, 12 Sep 2025 18:46:53 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250912214649]]></title><description><![CDATA[<img src="материалы/файлы/pasted-image-20250912214649.png" target="_self">]]></description><link>материалы/файлы/pasted-image-20250912214649.html</link><guid isPermaLink="false">Материалы/Файлы/Pasted image 20250912214649.png</guid><pubDate>Fri, 12 Sep 2025 18:46:49 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250912214643]]></title><description><![CDATA[<img src="материалы/файлы/pasted-image-20250912214643.png" target="_self">]]></description><link>материалы/файлы/pasted-image-20250912214643.html</link><guid isPermaLink="false">Материалы/Файлы/Pasted image 20250912214643.png</guid><pubDate>Fri, 12 Sep 2025 18:46:43 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250912214624]]></title><description><![CDATA[<img src="материалы/файлы/pasted-image-20250912214624.png" target="_self">]]></description><link>материалы/файлы/pasted-image-20250912214624.html</link><guid isPermaLink="false">Материалы/Файлы/Pasted image 20250912214624.png</guid><pubDate>Fri, 12 Sep 2025 18:46:24 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250912214611]]></title><description><![CDATA[<img src="материалы/файлы/pasted-image-20250912214611.png" target="_self">]]></description><link>материалы/файлы/pasted-image-20250912214611.html</link><guid isPermaLink="false">Материалы/Файлы/Pasted image 20250912214611.png</guid><pubDate>Fri, 12 Sep 2025 18:46:11 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Базовая работа с элементами веб страницы через JavaScript]]></title><description><![CDATA[В JavaScript для взаимодействия с HTML-элементами используются методы работы с DOM (Document Object Model). Основные способы получения элементов: document.getElementById(id) — возвращает элемент по уникальному атрибуту id.
Пример: const button = document.getElementById('submit-btn'); document.querySelector(selector) — возвращает первый элемент, соответствующий CSS-селектору.
Пример: const title = document.querySelector('h1'); или const item = document.querySelector('.item.active'); document.querySelectorAll(selector) — возвращает NodeList (массивоподобный объект) всех элементов, соответствующих селектору.
Пример: const buttons = document.querySelectorAll('button'); document.getElementsByTagName(name) — возвращает HTMLCollection элементов по тегу.
Пример: const paragraphs = document.getElementsByTagName('p'); document.getElementsByClassName(name) — возвращает HTMLCollection элементов по классу.
Пример: const items = document.getElementsByClassName('list-item'); ⚠️ Методы, возвращающие коллекции (HTMLCollection, NodeList), не являются настоящими массивами и не имеют методов массивов (например, .map(), .filter()). Для их использования можно преобразовать в массив через [...collection] или Array.from(collection).
После получения элемента можно изменять его атрибуты и содержимое: element.textContent — устанавливает или возвращает текстовое содержимое элемента (без HTML-разметки).
Пример: paragraph.textContent = 'Новый текст'; element.innerHTML — устанавливает или возвращает HTML-содержимое элемента (включая разметку).
Пример: div.innerHTML = '&lt;strong&gt;Жирный текст&lt;/strong&gt;'; element.setAttribute(name, value) — задаёт значение атрибута.
Пример: button.setAttribute('disabled', 'true'); element.getAttribute(name) — получает значение атрибута.
Пример: const type = input.getAttribute('type'); element.removeAttribute(name) — удаляет атрибут.
Пример: button.removeAttribute('disabled'); 💡 Используйте textContent для изменения текста — он безопаснее innerHTML, так как не выполняет HTML-код и защищает от XSS-атак.
Стили элемента можно менять напрямую через свойство style — оно представляет собой объект, содержащий все CSS-свойства в формате camelCase:
element.style.propertyName = 'value';
Примеры:
element.style.color = 'red';
element.style.fontSize = '20px';
element.style.backgroundColor = '#f0f0f0';
element.style.marginTop = '10px'; 🔍 Важно: CSS-свойства с дефисом (например, background-color) в JavaScript записываются в camelCase (backgroundColor).
Ограничения:
Стили, заданные через style, имеют приоритет над внешними CSS-правилами.
Нельзя установить несколько стилей одновременно — только по одному свойству.
Для сложных стилевых изменений рекомендуется использовать классы (classList):
element.classList.add('highlight');
element.classList.remove('hidden');
element.classList.toggle('active'); ✅ Использование classList предпочтительнее прямого изменения style — это позволяет отделять логику от стилей и поддерживать чистоту кода.
]]></description><link>материалы/подтемы/секция-1.-javascript/базовая-работа-с-элементами-веб-страницы-через-javascript.html</link><guid isPermaLink="false">Материалы/Подтемы/Секция 1. JavaScript/Базовая работа с элементами веб страницы через JavaScript.md</guid><pubDate>Fri, 12 Sep 2025 18:40:45 GMT</pubDate></item><item><title><![CDATA[Основные понятия веб страницы]]></title><description><![CDATA[Основные понятия веб-страницыВеб-страница — это документ, отображаемый в браузере, который состоит из трёх взаимосвязанных технологий: HTML, CSS и JavaScript. Каждая из них выполняет свою уникальную роль, и только их совместное использование позволяет создавать полноценные, интерактивные и визуально привлекательные приложения.HTML (HyperText Markup Language) — это язык гипертекстовой разметки, созданный для описания структуры веб-документов. Он не выполняет вычислений, не обрабатывает логику и не управляет поведением — его задача: обозначить смысл содержимого. Каждый элемент HTML — это маркер, который говорит браузеру: «Это заголовок», «Это абзац», «Это ссылка», «Это изображение».HTML работает на основе тегов — специальных ключевых слов, заключённых в угловые скобки: &lt;tag&gt;. Теги могут быть:
Парными — имеют открывающий и закрывающий тег: &lt;p&gt;Это параграф&lt;/p&gt; Самозакрывающимися — не содержат содержимого и закрываются сразу: &lt;img src="image.jpg" alt="Описание изображения" /&gt;
&lt;br /&gt; Каждый тег может иметь атрибуты — дополнительные параметры, уточняющие поведение или свойства элемента. Например:&lt;a href="https://example.com" target="_blank"&gt;Перейти&lt;/a&gt;
Здесь href указывает адрес ссылки, а target="_blank" — открывать её в новой вкладке.HTML5 — современная версия стандарта — ввела семантические теги, которые не только описывают внешний вид, но и передают значение контента:
&lt;header&gt; — шапка страницы или раздела
&lt;nav&gt; — навигационное меню
&lt;main&gt; — основное содержимое страницы
&lt;section&gt; — логический блок тематически связанного контента
&lt;article&gt; — самостоятельная сущность (например, статья, пост)
&lt;footer&gt; — подвал
Использование семантики улучшает:
Доступность — для пользователей с ограниченными возможностями (экранная речь корректно интерпретирует структуру),
SEO — поисковые системы лучше понимают и ранжируют содержимое,
Поддержку кода — разработчики быстрее ориентируются в структуре.
CSS (Cascading Style Sheets) — это язык, предназначенный для оформления HTML-документов. Он отвечает за то, как выглядит страница: цвета, размеры, расположение элементов, анимации, адаптивность под разные устройства.CSS работает через селекторы — правила, определяющие, к каким элементам применяются стили. Пример:h1 { color: #2c3e50; font-size: 2rem; text-align: center;
}
Здесь h1 — селектор, { ... } — набор свойств и их значений.CSS обладает ключевыми особенностями:
Каскадность (Cascading) — стили могут переопределяться. Если два правила влияют на один элемент, приоритет определяется по специфичности селектора, порядку объявления и использованию !important.
Наследование — некоторые свойства (например, font-family, color) автоматически передаются дочерним элементам.
Медиа-запросы — позволяют применять стили в зависимости от характеристик устройства: ширины экрана, ориентации, разрешения. Это основа адаптивного дизайна:
@media (max-width: 768px) { body { font-size: 14px; }
} CSS можно подключать тремя способами:
Внутренний стиль — внутри &lt;style&gt; в &lt;head&gt; (не рекомендуется для больших проектов).
Внешний файл — через &lt;link rel="stylesheet" href="styles.css"&gt; — лучшая практика.
Встроенный стиль — атрибут style внутри тега (&lt;p style="color:red;"&gt;) — используется крайне редко, только для экстренных случаев.
Важно: HTML отвечает за что — CSS — за как выглядит. Их разделение — фундаментальный принцип веб-разработки. Это позволяет:
Менять дизайн без трогания структуры,
Одинаковый HTML отображать по-разному на разных устройствах,
Ускорять загрузку за счёт кэширования CSS-файлов,
Облегчать командную разработку (дизайнеры работают с CSS, разработчики — с HTML и JS). В рамках дисциплины мы не будем изучать свойства CSS, поэтому они остаются на самообучение
Каждый валидный HTML-документ должен начинаться с DOCTYPE, чтобы браузер знал, какой стандарт использовать. Без него он может перейти в режим "quirks mode", где поведение становится непредсказуемым.&lt;!DOCTYPE html&gt;
— единственное объявление, необходимое для HTML5. Не требует закрывающего тега.Корневой элемент. Атрибут lang обязателен для доступности и SEO:&lt;html lang="ru"&gt;
Указывает язык содержимого — помогает экранной речи, переводчикам и поисковикам.Не отображается на странице, но содержит метаданные, необходимые для работы браузера и поисковых систем:
&lt;meta charset="UTF-8"&gt; — задаёт кодировку символов. UTF-8 поддерживает все языки мира — обязательный элемент.
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; — критически важен для мобильных устройств. Без него страница будет масштабироваться как на десктопе, что делает её нечитаемой на телефоне.
&lt;title&gt; — название вкладки браузера и заголовок в результатах поиска. Должен быть уникальным и описательным.
&lt;link&gt; — подключение внешних ресурсов: CSS, favicon, шрифтов.
&lt;script&gt; — подключение JavaScript (может находиться и в &lt;head&gt;, и в &lt;body&gt;, но это отдельная тема).
Пример полного &lt;head&gt;:&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Моя первая страница&lt;/title&gt; &lt;link rel="stylesheet" href="styles.css"&gt; &lt;link rel="icon" href="favicon.ico" type="image/x-icon"&gt;
&lt;/head&gt;
Содержит всё, что видит пользователь. Внутри могут быть любые элементы, включая:
Заголовки: &lt;h1&gt; до &lt;h6&gt; — иерархия важности. &lt;h1&gt; — главный заголовок страницы, только один.
Параграфы: &lt;p&gt; — для текстовых блоков.
Списки: &lt;ul&gt; — неупорядоченный (с точками),
&lt;ol&gt; — упорядоченный (с номерами),
&lt;li&gt; — элемент списка. Изображения: &lt;img src="..." alt="..."&gt; — alt обязателен для доступности и SEO.
Ссылки: &lt;a href="..."&gt;текст&lt;/a&gt; — href — адрес перехода.
Кнопки: &lt;button&gt;...&lt;/button&gt; — для взаимодействия.
Формы: &lt;form&gt;, &lt;input&gt;, &lt;label&gt; — для сбора данных.
Пример минимальной, но корректной структуры &lt;body&gt;:&lt;body&gt; &lt;header&gt; &lt;h1&gt;Добро пожаловать!&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;Это основной текст страницы.&lt;/p&gt; &lt;button id="myButton"&gt;Нажми меня&lt;/button&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;&amp;copy; 2025 Моя компания&lt;/p&gt; &lt;/footer&gt;
&lt;/body&gt;
HTML — дерево. Элементы должны быть правильно вложены:
✅ Правильно:&lt;p&gt;&lt;strong&gt;Жирный текст&lt;/strong&gt; внутри параграфа&lt;/p&gt;
❌ Неправильно:&lt;p&gt;&lt;strong&gt;Жирный текст&lt;/p&gt;&lt;/strong&gt; &lt;!-- Нарушена вложенность --&gt;
Браузеры пытаются исправить ошибки, но это приводит к непредсказуемому поведению, особенно в сложных случаях.
Используйте семантические теги вместо &lt;div&gt; там, где это возможно.
Не используйте &lt;h1&gt;–&lt;h6&gt; исключительно для изменения размера шрифта — используйте CSS.
Все изображения должны иметь alt — даже если пустой (alt=""), если они декоративные.
Для кнопок и ссылок используйте правильные теги: &lt;button&gt; — для действий, &lt;a&gt; — для переходов.
Поддерживайте чистую и читаемую структуру: отступы, переносы, комментарии (если нужно).
Всегда проверяйте валидность кода через <a data-tooltip-position="top" aria-label="https://validator.w3.org/" rel="noopener nofollow" class="external-link is-unresolved" href="https://validator.w3.org/" target="_self">validator.w3.org</a>.
DOM (Document Object Model — Модель объектов документа) — это программное представление веб-документа (обычно HTML или XML), созданное браузером в виде иерархического дерева объектов, где каждый элемент документа — это объект, доступный для манипуляций через JavaScript.DOM не является частью самого HTML-файла. Он динамически генерируется браузером при загрузке страницы: парсер читает HTML-код и превращает его в структуру из узлов (nodes), которые можно изменять, добавлять, удалять или запрашивать с помощью JavaScript.Каждый элемент HTML становится узлом (node) в DOM-дереве:
Элементные узлы — теги (&lt;div&gt;, &lt;p&gt;, &lt;button&gt; и т.д.)
Текстовые узлы — текст внутри тегов
Атрибутные узлы — атрибуты элементов (id, class, href)
Корневой узел — &lt;html&gt;
Дочерние и родительские узлы — элементы связаны отношениями «родитель–ребёнок»
Пример HTML:&lt;div id="container"&gt; &lt;h1&gt;Привет, мир!&lt;/h1&gt; &lt;p&gt;Это параграф.&lt;/p&gt;
&lt;/div&gt;
Соответствующее DOM-дерево:html
└── body └── div#container ├── h1 │ └── #text: "Привет, мир!" └── p └── #text: "Это параграф."
Каждый узел имеет свойства и методы, позволяющие взаимодействовать с ним. Например:
element.tagName — имя тега,
element.textContent — содержимое текста,
element.id, element.className — значения атрибутов,
element.appendChild(), element.removeChild() — управление дочерними узлами.
JavaScript не может напрямую работать с HTML-кодом файла. Он работает только с DOM-представлением, которое браузер создал в памяти. Это позволяет:
Динамически изменять содержимое страницы без перезагрузки (например, обновлять список задач, менять текст кнопки),
Реагировать на действия пользователя — клики, ввод текста, скроллинг,
Изменять стили элементов — через element.style,
Добавлять и удалять элементы — например, создавать новые карточки товаров по запросу,
Получать информацию о состоянии страницы — размер окна, положение элементов, состояние форм.
Без DOM JavaScript был бы бесполезен на веб-странице — он просто не имел бы «точки входа» в контент.]]></description><link>материалы/подтемы/секция-1.-javascript/основные-понятия-веб-страницы.html</link><guid isPermaLink="false">Материалы/Подтемы/Секция 1. JavaScript/Основные понятия веб страницы.md</guid><pubDate>Fri, 12 Sep 2025 18:38:42 GMT</pubDate></item><item><title><![CDATA[Самое простое использование JavaScript]]></title><description><![CDATA[Для быстрого тестирования и экспериментов с JavaScript можно использовать консоль разработчика — встроенную инструментальную панель в любом современном браузере (Chrome, Firefox, Edge, Safari). Открыть её можно сочетанием клавиш F12 или Ctrl+Shift+I (на macOS — Cmd+Option+I), затем перейти на вкладку Console.Консоль позволяет выполнять JavaScript-код прямо в браузере без создания HTML-файлов. Это идеальное место для проверки синтаксиса, отладки простых выражений и изучения поведения языка в реальном времени.
<img alt="Pasted image 20250912212732.png" src="материалы/файлы/pasted-image-20250912212732.png" target="_self">Для вывода информации в консоль используется функция console.log():console.log("Привет, мир!");
console.log(42);
console.log(true);
<br><img alt="Pasted image 20250912212810.png" src="материалы/файлы/pasted-image-20250912212810.png" target="_self">Эта команда — основной инструмент отладки на начальных этапах. Она выводит переданные значения в консоль, помогая увидеть, что происходит в коде. Можно передавать несколько аргументов:console.log("Значение переменной:", variableName);
Также доступны другие методы:
console.error() — для ошибок (выводится красным),
console.warn() — для предупреждений (жёлтый цвет),
console.table() — для удобного отображения массивов и объектов в виде таблицы.
Для показа пользователю простого сообщения используется функция alert():alert("Это сообщение от JavaScript!");
<br><img alt="Pasted image 20250912212840.png" src="материалы/файлы/pasted-image-20250912212840.png" target="_self">Она выводит модальное окно с текстом, которое блокирует взаимодействие с страницей до нажатия кнопки «ОК». Используется исключительно для учебных целей и быстрой обратной связи — в реальных приложениях alert() не применяется из-за плохого пользовательского опыта.
⚠️ Не используйте alert() в продакшене — он нарушает поток работы пользователя и не поддерживает стилизацию.
]]></description><link>материалы/подтемы/секция-1.-javascript/самое-простое-использование-javascript.html</link><guid isPermaLink="false">Материалы/Подтемы/Секция 1. JavaScript/Самое простое использование JavaScript.md</guid><pubDate>Fri, 12 Sep 2025 18:28:41 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250912212840]]></title><description><![CDATA[<img src="материалы/файлы/pasted-image-20250912212840.png" target="_self">]]></description><link>материалы/файлы/pasted-image-20250912212840.html</link><guid isPermaLink="false">Материалы/Файлы/Pasted image 20250912212840.png</guid><pubDate>Fri, 12 Sep 2025 18:28:40 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250912212810]]></title><description><![CDATA[<img src="материалы/файлы/pasted-image-20250912212810.png" target="_self">]]></description><link>материалы/файлы/pasted-image-20250912212810.html</link><guid isPermaLink="false">Материалы/Файлы/Pasted image 20250912212810.png</guid><pubDate>Fri, 12 Sep 2025 18:28:10 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250912212732]]></title><description><![CDATA[<img src="материалы/файлы/pasted-image-20250912212732.png" target="_self">]]></description><link>материалы/файлы/pasted-image-20250912212732.html</link><guid isPermaLink="false">Материалы/Файлы/Pasted image 20250912212732.png</guid><pubDate>Fri, 12 Sep 2025 18:27:32 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[index]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://t.me/+3RqHSkYzaXUyMTUy" target="_self">https://t.me/+3RqHSkYzaXUyMTUy</a><br><img alt="Pasted image 20250912205946.png" src="материалы/файлы/pasted-image-20250912205946.png" target="_self"><br><img alt="qrcod_72k5.png" src="материалы/файлы/qrcod_72k5.png" target="_self"><br><a data-href="Тема №1. Как создаются мобильные приложения" href="лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html" class="internal-link" target="_self" rel="noopener nofollow">Тема №1. Как создаются мобильные приложения</a>]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Fri, 12 Sep 2025 18:01:42 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[qrcod_72k5]]></title><description><![CDATA[<img src="материалы/файлы/qrcod_72k5.png" target="_self">]]></description><link>материалы/файлы/qrcod_72k5.html</link><guid isPermaLink="false">Материалы/Файлы/qrcod_72k5.png</guid><pubDate>Fri, 12 Sep 2025 18:00:53 GMT</pubDate><enclosure url="материалы/файлы/qrcod_72k5.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="материалы/файлы/qrcod_72k5.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250912205946]]></title><description><![CDATA[<img src="материалы/файлы/pasted-image-20250912205946.png" target="_self">]]></description><link>материалы/файлы/pasted-image-20250912205946.html</link><guid isPermaLink="false">Материалы/Файлы/Pasted image 20250912205946.png</guid><pubDate>Fri, 12 Sep 2025 17:59:46 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Переменные в JavaScript]]></title><description><![CDATA[Переменная в JavaScript — это именованный контейнер для хранения данных, который позволяет обращаться к значению по его имени в процессе выполнения программы.Каждая переменная ассоциирована с определённым значением (число, строка, объект, функция и т.д.), которое может меняться во время работы приложения. Переменные позволяют сохранять промежуточные результаты, пользовательские данные, состояния интерфейса — всё, что требуется для динамического поведения приложения.let age = 25;
let userName = "Алексей";
let isActive = true;
Здесь:
age, userName, isActive — имена переменных.
25, "Алексей", true — значения, которые они хранят. Динамическая типизация — тип значения определяется автоматически при присваивании, и переменная может хранить значения разных типов в разное время.
let x = 10; // число
x = "привет"; // теперь строка — допустимо
x = [1, 2, 3]; // теперь массив — тоже допустимо Объявление и использование — переменную нужно объявить перед использованием (кроме случаев с var в нестрогом режиме, но это устаревшая практика).
Область видимости — определяет, где переменная доступна (блок, функция, глобально), зависит от ключевого слова (let, const, var).
Подробнее про эти особенности мы прочтём в следующих лекциях.При создании и использовании переменных необходимо следовать <a data-tooltip-position="top" aria-label="Правила наименования переменных в JavaScript" data-href="Правила наименования переменных в JavaScript" href="материалы/подтемы/секция-1.-javascript/правила-наименования-переменных-в-javascript.html" class="internal-link" target="_self" rel="noopener nofollow">правилам наименования переменных</a>.Работа с переменными включает три ключевых действия: объявление, инициализация и присваивание. Эти понятия тесно связаны, но не тождественны — их различие критически важно для понимания поведения кода.Объявление переменной — это создание её имени в области видимости. Оно сообщает интерпретатору: «Я хочу использовать эту метку для хранения значения».В JavaScript есть три ключевых слова для объявления:Примеры:var x; // объявление через var
let y; // объявление через let
const z; // Ошибка: const требует инициализации при объявлении
Ключевое отличие: const обязывает сразу присвоить значение — без этого возникает синтаксическая ошибка.
💡 Рекомендация: Всегда используйте const по умолчанию. Если знаете, что значение будет меняться — замените на let. Никогда не используйте var в современных проектах — он вносит путаницу из-за hoisting и функциональной области видимости.
Инициализация — это первое присваивание значения переменной в момент её создания. Это когда переменная получает своё начальное значение и становится доступной для использования.
Инициализация может совпадать с объявлением.
Она обязательна для const, опциональна для let и var.
Примеры:let age; // объявление — без инициализации (значение undefined)
age = 25; // присваивание — теперь переменная проинициализирована let score = 100; // объявление + инициализация в одной строке
const name = "Алекс"; // объявление + инициализация (обязательно!)
Инициализация = объявление + первое присваивание в одном действии.Присваивание — это операция изменения значения уже существующей переменной. Оно происходит после объявления (и, если нужно, после инициализации).
Для let — можно присваивать сколько угодно раз.
Для const — присваивание разрешено только один раз (при инициализации); любое последующее присваивание вызовет ошибку.
Присваивание не обязательно должно происходить сразу после объявления.
Примеры:let count;
count = 0; // первое присваивание (и одновременно инициализация)
count = count + 1; // второе присваивание — изменение значения
count = null; // присваивание — можно менять const PI = 3.14;
PI = 3.14159; // Ошибка: присваивание const после инициализации запрещено // Но! Если значение — объект или массив:
const user = { name: "Иван" };
user.name = "Петр"; // Разрешено — меняется содержимое объекта, а не ссылка
user = {}; // Ошибка — попытка изменить ссылку
Важно: const защищает ссылку, а не содержимое. Для объектов и массивов можно менять свойства — это не нарушает константность.В JavaScript, как и в любом языке программирования, читаемость и поддерживаемость кода важнее минимального количества строк. Создание дополнительной переменной для хранения промежуточного результата — это не расточительство, а практика, повышающая ясность кода.
Упрощает чтение: имя переменной может объяснять смысл действия, вместо того чтобы оставлять сложное выражение без контекста.
Облегчает отладку: можно легко поставить точку останова на конкретной переменной и увидеть её значение.
Снижает когнитивную нагрузку: другие разработчики (и вы сами через неделю) быстрее поймут логику.
Повышает переиспользуемость: если значение используется несколько раз — нет нужды повторять вычисление.
Без лишней переменной (менее читаемо):if (user.age &gt;= 18 &amp;&amp; user.status === 'active' &amp;&amp; user.country !== 'restricted') { enableAccess();
}
С лишней переменной (более понятно):const isAdult = user.age &gt;= 18;
const isActive = user.status === 'active';
const isAllowedCountry = user.country !== 'restricted'; if (isAdult &amp;&amp; isActive &amp;&amp; isAllowedCountry) { enableAccess();
}
Здесь имена переменных выполняют роль документации — они сразу говорят, что проверяется, а не как.Не стоит создавать переменные ради создания — только если они действительно улучшают понимание. Не нужно оборачивать простые литералы или очевидные значения, например:const five = 5; // Избыточно
return x + five; // Лучше:
return x + 5;
Но если значение получено в результате вычисления, преобразования или запроса — лучше сохранить его с осмысленным именем.Переменные используются для хранения данных, которые могут изменяться во время выполнения программы. Они позволяют:
Сохранять результаты вычислений;
Передавать данные между частями кода;
Управлять состоянием приложения (например, флаги, счётчики, пользовательские данные). Обращайтесь к переменной только после её объявления и инициализации. Попытка использовать let или const до объявления вызовет ошибку ReferenceError.
Не используйте переменные с неопределённым значением (undefined) без проверки — это источник багов.
Избегайте глобальных переменных. Всегда ограничивайте область видимости блоками ({}), функциями или модулями.
Используйте переменные для повторяющихся значений — это упрощает изменение параметров в будущем (например, таймауты, цвета, константы конфигурации).
const apiUrl = 'https://api.example.com/data';
const timeoutMs = 5000; fetch(apiUrl, { timeout: timeoutMs }) .then(response =&gt; response.json()) .then(data =&gt; { const processedData = data.map(item =&gt; item.toUpperCase()); displayResults(processedData); });
Здесь каждая переменная имеет чёткую роль:
apiUrl — централизованное управление адресом API;
timeoutMs — легко изменяемый параметр;
processedData — промежуточный результат, понятный по имени. Переиспользование одной переменной для разных целей:
let user = getUserById(123);
user = calculateDiscount(user); // Теперь user — не объект пользователя, а число. Путаница! Использование переменных без инициализации:
let result;
console.log(result + 10); // NaN — непредсказуемое поведение ]]></description><link>материалы/подтемы/секция-1.-javascript/переменные-в-javascript.html</link><guid isPermaLink="false">Материалы/Подтемы/Секция 1. JavaScript/Переменные в JavaScript.md</guid><pubDate>Fri, 12 Sep 2025 17:31:28 GMT</pubDate></item><item><title><![CDATA[Тема №2. Основы JavaScript]]></title><description><![CDATA[В этой теме вы познакомитесь с основами JavaScript — языком, лежащим в основе интерактивности современных веб- и мобильных приложений. Рассмотрите историю появления языка, его ключевые характеристики и области применения. Вы узнаете, как устроен простейший код на JavaScript, изучите базовые элементы синтаксиса, а также детально разберёте переменные — их объявление и правила именования. Всё это — фундамент для дальнейшего изучения разработки мобильных приложений на JavaScript-основах.
<a data-href="Что такое JavaScript, история появления" href="материалы/подтемы/секция-1.-javascript/что-такое-javascript,-история-появления.html" class="internal-link" target="_self" rel="noopener nofollow">Что такое JavaScript, история появления</a>
<br><a data-href="Базовое понимание синтаксиса JavaScript" href="материалы/подтемы/секция-1.-javascript/базовое-понимание-синтаксиса-javascript.html" class="internal-link" target="_self" rel="noopener nofollow">Базовое понимание синтаксиса JavaScript</a>
(Пусто)<br><a data-href="Тема №3. Использование JavaScript в браузере" href="лекции/секция-1.-javascript/тема-№3.-использование-javascript-в-браузере.html" class="internal-link" target="_self" rel="noopener nofollow">Тема №3. Использование JavaScript в браузере</a>]]></description><link>лекции/секция-1.-javascript/тема-№2.-основы-javascript.html</link><guid isPermaLink="false">Лекции/Секция 1. JavaScript/Тема №2. Основы JavaScript.md</guid><pubDate>Fri, 12 Sep 2025 17:28:46 GMT</pubDate></item><item><title><![CDATA[Правила наименования переменных в JavaScript]]></title><description><![CDATA[В JavaScript как и в любом другом языке программирования существуют строгие синтаксические правила для именования переменных: Имя должно начинаться с буквы (a–z, A–Z), символа подчёркивания (_) или знака доллара ($).
✅ Разрешено: name, _count, $element
❌ Запрещено: 2name, -value, 3dModel После первого символа можно использовать буквы, цифры (0–9), _ и $.
✅ Разрешено: userName1, total_price, API_KEY
❌ Запрещено: user-name, email@domain, my variable Имена чувствительны к регистру — name, Name и NAME — это три разные переменные. Нельзя использовать зарезервированные слова языка как имена переменных:
let, const, var, function, if, else, return, class, import, export, null, true, false, this, new, while, for, break, continue, try, catch, finally, throw, switch, case, default, typeof, instanceof, in, of, async, await, yield и другие.
❌ Запрещено: let = 5;, function = "test"; Нельзя использовать ключевые слова будущих версий ECMAScript, даже если они пока не используются (например, package, interface, private, protected, public, static).
❌ Лучше избегать: class, enum, implements, module, namespace, super Хотя JavaScript позволяет многое, следование общепринятым соглашениям делает код понятным, поддерживаемым и профессиональным: Используйте camelCase для имен переменных и функций.
✅ userName, isLoading, getTotalPrice
❌ user_name, User Name, usertotalprice Для констант (которые не меняются) используйте UPPER_SNAKE_CASE.
✅ MAX_USERS, API_URL, DEFAULT_TIMEOUT Выбирайте осмысленные, описательные имена — избегайте аббревиатур и однобуквенных имён, если контекст не очевиден.
✅ numberOfItems, currentUser, isFormValid
❌ n, x, tmp, data1, arr Используйте логические имена для булевых переменных — начинайте с is, has, can, should.
✅ isVisible, hasPermission, canSubmit, isLoading Избегайте двойных отрицаний — лучше isDisabled, чем isNotEnabled. Не используйте $ в начале имени без причины — хотя $ разрешён, он часто используется в библиотеках (например, jQuery) для обозначения объектов DOM. Используйте только если это часть вашей договорённости в проекте (например, const $button = document.querySelector('#btn');). Следуйте единому стилю в команде — согласуйте стиль именования в проекте (через ESLint, Prettier или внутренний гайдлайн). Не пишите имена на кириллице — даже если JavaScript это позволяет, это снижает читаемость для международной команды и может вызвать проблемы с инструментами/редакторами. 💡 Рекомендация: «Не жалейте создавать лишнюю переменную» — лучше сделать код более читаемым через понятные имена, чем экономить на количестве строк. Например: const isEmailValid = validateEmail(userInput); // Читаемо и понятно вместо const v = validateEmail(userInput); // Неясно, что такое v ]]></description><link>материалы/подтемы/секция-1.-javascript/правила-наименования-переменных-в-javascript.html</link><guid isPermaLink="false">Материалы/Подтемы/Секция 1. JavaScript/Правила наименования переменных в JavaScript.md</guid><pubDate>Fri, 12 Sep 2025 17:15:13 GMT</pubDate></item><item><title><![CDATA[Базовое понимание синтаксиса JavaScript]]></title><description><![CDATA[В рамках данной темы рассматриваются только базовые элементы синтаксиса JavaScript, необходимые для начала практической работы. Полный объём синтаксических конструкций — от операторов и структур управления до модулей, классов, асинхронности и деструктуризации — будет изучаться последовательно в последующих разделах курса. Настоящая часть служит фундаментом для понимания структуры кода, а не исчерпывающим руководством по языку.Комментарии не влияют на выполнение кода и предназначены исключительно для повышения читаемости и документирования.JavaScript поддерживает два типа комментариев: Однострочные — начинаются с //. Все, что следует после // до конца строки, игнорируется движком. // Это однострочный комментарий
let x = 5; // Можно писать и в конце строки Многострочные — заключаются между /* и */. Позволяют комментировать несколько строк или блоки кода. /*
Это многострочный комментарий
Используется для описания функций, модулей или временного отключения кода
*/
let y = 10;
JavaScript — язык, чувствительный к регистру. Это означает, что имена переменных, функций, ключевых слов и свойств различаются по написанию букв в верхнем и нижнем регистре.
Примеры: let name = "Анна";
let Name = "Иван"; // Это другая переменная
let NAME = "Олег"; // И ещё одна console.log(name); // "Анна"
console.log(Name); // "Иван"
console.log(NAME); // "Олег"
То же относится к ключевым словам: let — корректно, Let — ошибка (если не является именем переменной).
Также чувствительны к регистру названия свойств объектов: user.name ≠ user.Name.В JavaScript точки с запятой (;) используются для явного завершения инструкций. Хотя язык позволяет опускать их в большинстве случаев благодаря автоматической вставке точек с запятой (ASI — Automatic Semicolon Insertion), рекомендуется всегда использовать точки с запятой для предотвращения неочевидных ошибок. ]]></description><link>материалы/подтемы/секция-1.-javascript/базовое-понимание-синтаксиса-javascript.html</link><guid isPermaLink="false">Материалы/Подтемы/Секция 1. JavaScript/Базовое понимание синтаксиса JavaScript.md</guid><pubDate>Fri, 12 Sep 2025 17:06:48 GMT</pubDate></item><item><title><![CDATA[Что такое JavaScript, история появления]]></title><description><![CDATA[JavaScript — это динамический, интерпретируемый язык программирования, изначально разработанный для добавления интерактивности на веб-страницы. Он является одним из трёх основных технологий веб-разработки (наряду с HTML и CSS) и позволяет управлять поведением веб-приложений: обрабатывать события, изменять содержимое страницы, взаимодействовать с сервером и многое другое. Сегодня JavaScript работает не только в браузерах, но и на стороне сервера, в мобильных приложениях, десктопных программах и даже в устройствах Интернета вещей.Это мультипарадигмальный язык, что означает, он поддерживает несколько стилей (парадигм) программирования, и разработчик может выбирать подход, наиболее подходящий для решения задачи. Основные поддерживаемые парадигмы: Функциональное программирование — функции являются первоклассными объектами, можно передавать их как аргументы, возвращать из других функций, создавать замыкания. Поддерживаются чистые функции, иммутабельность, высшие порядки (map, filter, reduce). Объектно-ориентированное программирование (ООП) — через прототипы и (с ES6) синтаксис классов реализуется инкапсуляция, наследование и полиморфизм. Объекты могут динамически расширяться, свойства и методы добавляются во время выполнения. Процедурное программирование — код может быть написан как последовательность инструкций без явного использования классов или функций высшего порядка, что удобно для простых скриптов. JavaScript обладает следующими ключевыми особенностями: Динамическая типизация — тип переменной определяется во время выполнения. Интерпретируемость — код выполняется без предварительной компиляции. Поддержка функционального и объектно-ориентированного стилей — позволяет писать код разными способами. Асинхронность — через колбэки, промисы и async/await обеспечивает неблокирующее выполнение операций. Кроссплатформенность — работает в браузерах, Node.js, React Native, Flutter (через плагины) и других средах. Пример простого кода на JavaScript: alert("Привет, мир!"); let name = "Анна"; console.log("Здравствуйте, " + name + "!"); Этот код отобразит всплывающее окно с сообщением, сохранит имя в переменную и выведет приветствие в консоль браузера.
Веб-браузеры — интерактивные формы, анимации, динамическая загрузка контента. Фронтенд-фреймворки — React, Vue, Angular. Бэкенд — Node.js для серверной логики. Мобильные приложения — React Native, Ionic, NativeScript. Десктопные приложения — Electron. Игры — с использованием Canvas или WebGL. IoT — управление устройствами через JavaScript-среды (например, Johnny-Five).
В середине 1990-х годов веб был преимущественно статичным: HTML описывал структуру, CSS — оформление, но не было инструментов для взаимодействия с пользователем. Нужен был язык, который позволил бы браузерам выполнять простые действия — проверку форм, анимации, реакцию на клики — без обращения к серверу. Netscape Communications, одна из ведущих компаний того времени, решила создать такой язык.В 1995 году Брендан Эйх, работающий в Netscape, за десять дней разработал язык, первоначально названный Mocha, затем LiveScript, а в конце года — JavaScript. Название было выбрано в маркетинговых целях — чтобы ассоциироваться с популярным Java (несмотря на то, что языки принципиально различны). JavaScript был внедрён в браузер Netscape Navigator 2.0.В 1996 году Netscape передала язык в Ecma International для стандартизации. В 1997 году был принят стандарт ECMAScript 1 (ES1). С тех пор язык развивается под управлением Ecma TC39. Каждые 12 месяцев выпускается новая версия стандарта (ES6/ES2015, ES2020, ES2024 и т.д.), которые добавляют новые возможности: стрелочные функции, модули, классы, промисы, деструктуризацию и другие.Сегодня JavaScript — один из самых популярных языков программирования в мире (по данным Stack Overflow, GitHub и других источников). Его экосистема включает тысячи библиотек и фреймворков. Благодаря Node.js он стал универсальным языком, применяемым как на клиенте, так и на сервере. В мобильной разработке JavaScript используется в таких фреймворках, как React Native, позволяя создавать нативные приложения для iOS и Android на единой кодовой базе. Развитие продолжается: активно внедряются новые API, улучшается производительность движков (V8, SpiderMonkey), растёт поддержка TypeScript как надмножества JavaScript.]]></description><link>материалы/подтемы/секция-1.-javascript/что-такое-javascript,-история-появления.html</link><guid isPermaLink="false">Материалы/Подтемы/Секция 1. JavaScript/Что такое JavaScript, история появления.md</guid><pubDate>Fri, 12 Sep 2025 16:56:13 GMT</pubDate></item><item><title><![CDATA[Основные технологии для разработки мобильных приложений]]></title><description><![CDATA[Нативная разработка предполагает использование официальных языков программирования, сред разработки и фреймворков, предоставляемых производителями платформ — Apple и Google. Приложения компилируются напрямую в машинный код, обеспечивающий максимальную производительность и полный доступ к API устройства.Для разработки приложений под iOS используется Swift — язык, созданный Apple в 2014 году как современная замена Objective-C. Swift отличается чистым синтаксисом, безопасностью типов, поддержкой функционального программирования и высокой скоростью выполнения. Он активно развивается и является стандартом для новых проектов.Вместо него до сих пор встречается Objective-C — унаследованный от NeXTSTEP язык, который использовался в iOS до появления Swift. Он остаётся актуальным при поддержке старых проектов, но новые разработчики начинают с Swift.Инструмент разработки — Xcode, единственный официально поддерживаемый IDE от Apple. Он включает в себя редактор кода, симулятор устройств, инструменты отладки, профилирования производительности и систему управления версиями (Git). Xcode работает только на macOS, что делает разработку под iOS невозможной на Windows или Linux без виртуализации.Фреймворки интерфейса:
UIKit — традиционный фреймворк для создания пользовательских интерфейсов. Работает на основе иерархии представлений (UIView), требует детального описания макетов через код или Interface Builder. Подходит для сложных, детально настраиваемых интерфейсов.
SwiftUI — декларативный фреймворк, представленный в 2019 году. Позволяет описывать интерфейс как функцию состояния приложения — «что должно отображаться при данном состоянии», а не «как его построить». Упрощает разработку, обеспечивает автоматическую адаптацию под все размеры экранов и темы (светлая/тёмная), и полностью интегрирован с Swift. Считается будущим iOS-разработки.
Обе технологии работают с экосистемой Apple: Core Animation, Core Location, ARKit, HealthKit, Face ID, Push Notifications — всё доступно через единые API, документированные и стабильно поддерживающиеся Apple.Основным языком для Android сегодня является Kotlin — язык, разработанный JetBrains и официально объявленный Google предпочтительным для Android-разработки с 2019 года. Kotlin сочетает в себе функциональные и объектно-ориентированные парадигмы, обладает более безопасной системой типов (отсутствие null-pointer исключений по умолчанию), сжатым синтаксисом и полной совместимостью с Java.Java остаётся актуальной благодаря огромной базе legacy-приложений и корпоративных систем. Многие библиотеки, туториалы и инструкции всё ещё написаны на Java, но новые проекты рекомендуют начинать с Kotlin.Среда разработки — Android Studio, основанная на IntelliJ IDEA. Она предоставляет полноценный набор инструментов: эмулятор устройств, профайлер памяти и сети, анализатор производительности, инструменты для тестирования и поддержку Firebase. Работает на Windows, macOS и Linux — обеспечивает большую доступность, чем Xcode.Фреймворки интерфейса:
XML-разметка + View-система — классический подход. Интерфейс описывается в XML-файлах, а логика — в Kotlin/Java-классах. Требует явного связывания элементов UI с кодом (findViewById()), что создаёт больше шаблонного кода и потенциальных ошибок.
Jetpack Compose — современный декларативный фреймворк, аналог SwiftUI. Позволяет описывать интерфейс как функцию состояния, используя только Kotlin. Компоненты (Composables) перерисовываются автоматически при изменении данных. Упрощает создание динамических интерфейсов, снижает количество кода и повышает читаемость. С 2023 года считается основным стандартом для новых проектов.
Android также предлагает богатую экосистему Jetpack — набор библиотек (ViewModel, Room, Navigation, DataStore, WorkManager и др.), которые решают типовые задачи: управление жизненным циклом, работа с базами данных, фоновые задачи, маршрутизация между экранами — всё стандартизировано и поддерживается Google.Кроссплатформенные технологии позволяют писать один код, который компилируется в нативные приложения для iOS и Android. Отличие от гибридных — отсутствие WebView: вместо веб-страницы приложение использует настоящие нативные компоненты или собственные рендереры, что обеспечивает близкую к нативной производительность.Разработан Google и представлен в 2017 году. Основан на языке Dart — объектно-ориентированном языке с быстрой компиляцией и поддержкой JIT/AOT (Just-in-Time / Ahead-of-Time). Flutter компилирует код напрямую в нативный ARM-код, минуя виртуальную машину.Ключевая особенность — декларативная widget-архитектура. Весь интерфейс строится из деревьев виджетов — каждый элемент (кнопка, текст, список) — это виджет, который может быть изменён, вложен или переиспользован. Даже отступы и цвета — это виджеты.Flutter не использует нативные UI-компоненты iOS или Android. Вместо этого он рендерит собственные элементы с помощью графического движка Skia — то же, что используется в Chrome и Android. Это даёт:
Единый дизайн на всех платформах — приложение выглядит одинаково на iPhone и Samsung.
Высокую производительность — 60–120 FPS даже на сложных анимациях.
Гибкость дизайна — можно создавать уникальные интерфейсы, не привязанные к Material Design или Human Interface Guidelines.
Ограничения: больший размер приложения (включает рендер-движок), ограниченная интеграция с некоторыми нативными API без написания плагинов на Swift/Kotlin, менее «родной» UX на iOS, если не следовать гайдлайнам вручную.Flutter идеален для проектов с акцентом на дизайн: продукты с уникальной визуальной идентичностью, маркетплейсы, сервисы с частыми анимациями, MVP-стартапы, где важна скорость выхода на два рынка.Разработан Meta (ранее Facebook) в 2015 году. Основан на JavaScript и TypeScript — языках, уже знакомых миллионам веб-разработчиков. React Native использует принцип React — компонентный подход, где интерфейс строится из повторно используемых компонентов, реагирующих на изменения состояния.Архитектура React Native основана на JS-бриджe: JavaScript-код выполняется в отдельном потоке, а вызовы к нативным компонентам (кнопки, списки, камера) передаются через мост. Это позволяет использовать настоящие нативные UI-элементы, но создаёт задержки при частых взаимодействиях между JS и нативным кодом.Преимущества:
Высокая скорость разработки для команд с опытом в вебе.
Большое сообщество и множество готовых библиотек (npm).
Возможность частичного перехода: можно внедрять React Native-экраны в существующее нативное приложение.
Поддержка горячей перезагрузки (Hot Reload) — изменения видны мгновенно.
Ограничения:
Производительность ниже, чем у Flutter или нативных приложений — особенно при сложной анимации или работе с большим количеством данных.
Зависимость от сторонних библиотек для доступа к API — многие требуют установки и настройки нативных модулей (Native Modules).
Разница в поведении между iOS и Android — некоторые компоненты могут работать по-разному, требуя платформо-специфичного кода.
Сложность отладки: ошибки могут возникать как в JS, так и в нативном коде, затрудняя диагностику.
React Native популярен в компаниях, где есть команда веб-разработчиков, нуждающаяся в выходе на мобильный рынок без полного переобучения. Примеры: Facebook, Instagram, Skype, Walmart, Tesla.Разработан Microsoft, ранее известный как Xamarin Forms. Использует язык C# и фреймворк .NET — популярный в корпоративной разработке. В 2022 году Xamarin был объединён с .NET Multi-platform App UI (.NET MAUI) — современной версией, поддерживающей не только iOS и Android, но и Windows, macOS.Отличие от React Native и Flutter: Xamarin/.NET MAUI не использует мост. Код компилируется напрямую в нативный код через Mono или .NET runtime, что обеспечивает лучшую производительность и меньшие накладные расходы.Плюсы:
Полный доступ к нативным API через привязки (bindings) — почти все функции устройства доступны «из коробки».
Единая кодовая база для мобильных и десктопных приложений.
Интеграция с Visual Studio и Azure — удобна для корпоративных проектов.
Сильная типизация и безопасность C#.
Минусы:
Меньшее сообщество по сравнению с Flutter и React Native.
Более сложная настройка, особенно для новичков.
Менее гибкий UI — интерфейс часто выглядит «по-Windows», если не применять платформо-специфичные стили.
Медленнее развитие экосистемы по сравнению с Google и Meta.
.NET MAUI подходит для enterprise-решений: внутренние корпоративные приложения, ERP-системы, CRM, медицинские терминалы, приложения с интеграцией в облачные сервисы Microsoft (Azure, Office 365).]]></description><link>материалы/подтемы/секция-1.-javascript/основные-технологии-для-разработки-мобильных-приложений.html</link><guid isPermaLink="false">Материалы/Подтемы/Секция 1. JavaScript/Основные технологии для разработки мобильных приложений.md</guid><pubDate>Fri, 12 Sep 2025 16:11:15 GMT</pubDate></item><item><title><![CDATA[Основные типы мобильных приложений]]></title><description><![CDATA[Мобильное приложение — это не просто программа, запущенная на смартфоне. Его тип определяется тем, как оно создано, на чём работает и как взаимодействует с операционной системой и аппаратными компонентами устройства. Выбор типа приложения влияет на производительность, сроки разработки, стоимость поддержки и качество пользовательского опыта. Существует четыре основных типа: нативные, веб-приложения, гибридные и кроссплатформенные.Нативные приложения — это программы, разработанные специально для одной конкретной платформы с использованием официальных языков программирования, SDK и инструментов, предоставленных её создателем.Для iOS приложения пишутся на Swift или Objective-C с использованием фреймворков UIKit и SwiftUI, собираются в Xcode и компилируются напрямую в машинный код для архитектуры ARM процессоров Apple.
Для Android — на Kotlin или Java с использованием Android SDK, сборка происходит через Android Studio в APK или AAB-файлы, которые затем интерпретируются Android Runtime (ART).Преимущества: Максимальная производительность — код выполняется напрямую на устройстве без промежуточных слоёв. Полный доступ ко всем API устройства: камера, GPS, Bluetooth, сенсоры, биометрия, уведомления, фоновые задачи. Соответствие стандартам платформы (Human Interface Guidelines для iOS, Material Design для Android) — обеспечивает интуитивный и «родной» пользовательский опыт. Лучшая стабильность и поддержка обновлений ОС — разработчики получают ранний доступ к новым функциям через beta-версии SDK.
Ограничения: Требуется отдельная команда разработчиков для каждой платформы — удвоение затрат на разработку и тестирование. Дублирование логики и дизайна между версиями — увеличивает время выхода на рынок. Высокая зависимость от экосистемы: обновление API может потребовать переписывания значительной части кода.
Области применения:
Нативные приложения — стандарт для проектов, где важны скорость, надёжность и глубокая интеграция с устройством: банковские и финансовые приложения, игры, AR/VR-решения, медицинские системы, приложения с реальным временем (например, такси, доставка), корпоративные инструменты с высокими требованиями к безопасности.Веб-приложения — это сайты, спроектированные так, чтобы вести себя как мобильные приложения. Они работают в браузере, но могут быть добавлены на домашний экран, работать оффлайн и отправлять уведомления благодаря технологиям PWA.Основаны на стандартных веб-технологиях: HTML5, CSS3, JavaScript, а также Service Workers (для кэширования и работы без интернета), Web App Manifest (для определения иконки, имени, цвета темы) и Push API.Преимущества: Одна кодовая база — работает на всех устройствах с браузером (iOS, Android, даже десктоп). Нет необходимости проходить модерацию в магазинах приложений — публикация мгновенная. Низкие затраты на разработку и обслуживание. Не требует установки — пользователь сразу переходит по ссылке. Автоматическое обновление — изменения видны сразу после релиза.
Ограничения: Ограниченный доступ к аппаратным возможностям устройства: нет прямого доступа к контактам, файловой системе, Bluetooth Low Energy, NFC, гироскопу в некоторых случаях. Невозможность использовать многие нативные UI-компоненты — интерфейс выглядит как сайт, а не как приложение. Зависимость от браузера: производительность и совместимость различаются между Safari, Chrome, Firefox. Отсутствие в App Store и Google Play — потеря видимости, возможности рейтингов, рекомендаций и внутренних покупок через официальные каналы.
Области применения:
PWA подходят для контентных сервисов, информационных сайтов, электронной коммерции с простой логикой, корпоративных порталов, приложений с низким уровнем взаимодействия: онлайн-газеты, каталоги товаров, формы обратной связи, калькуляторы, лендинги. Особенно эффективны там, где важна скорость распространения и минимальные затраты — например, маркетинговые кампании или временные акции.Гибридные приложения — это веб-приложения, обёрнутые в «оболочку» нативного контейнера (WebView), который позволяет им запускаться как обычные мобильные приложения из магазинов. Они используют веб-технологии (HTML/CSS/JS), но имеют доступ к нативным API через плагины.Популярные фреймворки: Apache Cordova (ранее PhoneGap) и Ionic (основан на Angular/React/Vue + Cordova).Преимущества: Одна кодовая база для iOS и Android — снижение затрат на разработку. Возможность публикации в App Store и Google Play — как нативные приложения. Быстрая разработка для команд с опытом в вебе. Поддержка большинства базовых функций: камера, геолокация, уведомления, файловая система — через плагины.
Ограничения: Производительность ниже, чем у нативных — все операции проходят через WebView, что создаёт задержки, особенно при анимациях и сложной графике. Плагины часто устаревают или плохо документированы — могут вызывать баги на новых версиях ОС. UX редко достигает уровня «родного» приложения — интерфейс чувствуется как «веб-страница в обёртке». Ограниченный доступ к современным нативным функциям (например, Face ID, ARKit, Android Jetpack Compose).
Области применения:
Гибридные приложения подходят для прототипирования, MVP-проектов, внутренних корпоративных инструментов, приложений с простой логикой и минимальным взаимодействием с оборудованием: учётные системы, формы регистрации, CRM-клиенты, базовые лояльностные программы. Идеальны, когда бюджет ограничен, а сроки — жёсткие, и требуется быстрый выход на два рынка.Кроссплатформенные приложения — это приложения, написанные на одном языке и фреймворке, которые компилируются в нативный код для разных платформ. Это не обёртки, а генерация нативных компонентов на основе единого исходного кода.Популярные фреймворки: Flutter (Dart, от Google), React Native (JavaScript/TypeScript, от Meta), Xamarin (C#, от Microsoft), Kivy (Python, редко используется в коммерческой разработке).Отличие от гибридных: вместо WebView они используют настоящие нативные UI-компоненты (например, Flutter рисует собственные виджеты, React Native вызывает native UI элементы iOS/Android напрямую).Преимущества: Одна кодовая база — до 80–95% общего кода между iOS и Android. Производительность близка к нативной — особенно в Flutter и React Native с правильной оптимизацией. Доступ к большинству нативных API через библиотеки (например, Firebase, Mapbox, camera plugin). Современный UI — возможность создавать уникальный дизайн, не привязанный к стандартам платформы. Активное сообщество, регулярные обновления, хорошая документация.
Ограничения: Некоторые функции требуют написания нативного кода (Java/Kotlin, Swift/Objective-C) — если нужна глубокая интеграция с OS. Размер приложения больше, чем у чисто нативного (особенно в Flutter — включает движок рендеринга). Возможны баги на границах платформ — поведение одного и того же компонента может отличаться на iOS и Android. Обучение новому языку (Dart, TypeScript) требует времени для команд, привыкших к Java/Kotlin или Swift.
Области применения:
Кроссплатформенные решения — выбор большинства стартапов, компаний с ограниченным бюджетом, но амбициозными целями. Подходят для социальных сетей, мессенджеров, e-commerce, финтех-приложений, образовательных платформ, приложений с частыми обновлениями и необходимостью быстро масштабироваться. Примеры: Facebook, Instagram (частично), Uber Eats, Alibaba, Tencent.]]></description><link>материалы/подтемы/секция-1.-javascript/основные-типы-мобильных-приложений.html</link><guid isPermaLink="false">Материалы/Подтемы/Секция 1. JavaScript/Основные типы мобильных приложений.md</guid><pubDate>Fri, 12 Sep 2025 16:07:07 GMT</pubDate></item><item><title><![CDATA[Основные платформы мобильных приложений]]></title><description><![CDATA[Платформа мобильных приложений — это совокупность программного обеспечения, инструментов, стандартов и правил, которые определяют, как создаются, устанавливаются и работают мобильные приложения на конкретном устройстве. Это не просто операционная система (ОС), а целая экосистема: от ядра ОС и API-интерфейсов до магазинов приложений, систем подписок, политик безопасности и требований к разработчикам. Выбор платформы напрямую влияет на: доступные функции устройства (камера, GPS, биометрия); способы взаимодействия с пользователем; методы тестирования и отладки; стратегию монетизации и распространения; сроки и стоимость разработки. На сегодняшний день подавляющее большинство мобильных приложений создаётся для двух основных платформ — iOS и Android. Их доминирование обусловлено масштабами рынка, зрелостью инструментов и поддержкой со стороны крупнейших технологических компаний.iOS — экосистема Apple, работающая на устройствах iPhone, iPad и iPod touch. Закрытая, строго контролируемая платформа с единым стандартом качества, высокой безопасностью и стабильной производительностью. Основная аудитория — пользователи в развитых странах, с высоким уровнем дохода и лояльностью к бренду.Android — открытая операционная система от Google, используемая сотнями производителей (Samsung, Xiaomi, OnePlus, Motorola и др.). Обладает огромной фрагментацией устройств и версий, но обеспечивает максимальную доступность и гибкость для разработчиков и пользователей. Доминирует в развивающихся рынках и по объёму установленных устройств — более 70% глобального рынка смартфонов.Но, помимо iOS и Android, на протяжении истории мобильных технологий существовали и другие платформы, которые либо имели значительную долю рынка, либо обладали высоким потенциалом, но в итоге уступили место доминирующим системам.Windows Phone (Microsoft) — запущенная в 2010 году платформа, основанная на ядре Windows NT, предлагала уникальный пользовательский интерфейс с динамическими «живыми» плитками. Несмотря на техническую изящность и глубокую интеграцию с экосистемой Microsoft (Outlook, Office, OneDrive), она не смогла привлечь достаточное количество разработчиков. Отсутствие приложений, особенно популярных сервисов вроде Instagram или WhatsApp на ранних этапах, стало фатальным. Microsoft официально прекратила поддержку Windows Phone в 2017 году.BlackBerry OS / BlackBerry 10 — до середины 2000-х годов BlackBerry была синонимом корпоративной мобильности благодаря надёжной безопасности, физической клавиатуре и собственной сети Push Mail. Однако компания не сумела адекватно ответить на рост сенсорных экранов и экосистемы приложений. Попытка перезапуска с BlackBerry 10 в 2013 году, основанной на QNX, оказалась слишком поздней — к тому времени пользователи уже массово перешли на iOS и Android. В 2016 году BlackBerry перестала производить собственные устройства.Symbian — когда-то самая популярная мобильная ОС, особенно в Европе и Азии, Symbian использовалась Nokia, Samsung, Siemens и другими. Она доминировала на рынке до 2007 года, но её архитектура, унаследованная от эпохи кнопочных телефонов, не позволила эффективно адаптироваться к новым требованиям тачскринов и мультимедиа. После выхода iPhone и Android, Nokia в 2011 году перешла на Windows Phone, а Symbian была официально закрыта в 2014 году.WebOS (Palm, затем HP) — оригинальная и продвинутая система с многооконным интерфейсом, предшественник современных концепций многозадачности. Palm выпустила первые устройства на WebOS в 2009 году, а HP попыталась развивать платформу дальше, даже выпустив планшет TouchPad. Но недостаток приложений, маркетинговой поддержки и внутренние конфликты в HP привели к отказу от WebOS в 2011 году. Позже HP передала код проекта LG, который использовал его для своих смарт-телевизоров — но как мобильная ОС WebOS так и не возродилась.HarmonyOS (Huawei) — современный пример платформы, появившейся как ответ на геополитические ограничения. Разработанная Huawei в 2019 году после запрета Google на использование GMS (Google Mobile Services), HarmonyOS изначально позиционировалась как универсальная ОС для IoT-устройств, а позже — как замена Android на смартфонах. Хотя она технически совместима с Android-приложениями через App Pack, её глобальное распространение ограничено из-за отсутствия доступа к ключевым сервисам Google и западным приложениям. На сегодня — это важный региональный игрок (особенно в Китае), но не глобальная альтернатива iOS/Android.iOS и Android — две доминирующие мобильные платформы, отличающиеся не только архитектурой, но и философией разработки, подходом к безопасности, экосистеме и взаимодействию с пользователем. Их сравнение позволяет понять фундаментальные различия, которые влияют на процесс создания мобильных приложений.Языки программирования и инструменты разработки
iOS-приложения разрабатываются преимущественно на языке Swift (с 2014 года), а также на Objective-C — унаследованном от эпохи NeXTSTEP. Интегрированная среда разработки — Xcode, доступная исключительно на macOS. Это накладывает ограничения: разработка под iOS невозможна без устройства Apple или виртуальной машины с macOS.
Android-приложения пишутся на Kotlin (рекомендуемый язык с 2019 года) или Java (традиционный, но постепенно вытесняемый). Среда разработки — Android Studio, основанная на IntelliJ IDEA, работает на Windows, macOS и Linux, что обеспечивает большую доступность для разработчиков.Архитектура и управление ресурсами
iOS использует закрытую, унифицированную архитектуру: ограниченное количество моделей устройств с жёстко контролируемыми характеристиками (память, процессор, экран). Это позволяет оптимизировать приложения под конкретные аппаратные конфигурации, обеспечивая высокую производительность и стабильность.
Android, напротив, работает на тысячах устройств с разными процессорами, объёмами ОЗУ, плотностями пикселей и версиями ОС. Разработчику приходится учитывать фрагментацию — от старых смартфонов с Android 8 до новых с Android 14 — и применять адаптивные интерфейсы, проверять совместимость и использовать библиотеки поддержки (Android Support Library / AndroidX).Магазины приложений и политики распространения
Приложения для iOS распространяются исключительно через App Store — строго централизованный и контролируемый канал. Apple проводит ручную модерацию каждого приложения, требует соблюдения строгих гайдлайнов по дизайну, приватности и функциональности. Это повышает уровень безопасности для пользователей, но замедляет выпуск обновлений и ограничивает возможности монетизации (например, запрещены сторонние магазины и системы внутренних покупок вне App Store).
Android-приложения могут распространяться через Google Play, но также допускается установка из сторонних источников (APK-файлы). Google Play имеет автоматизированную модерацию, менее строгие требования, но более высокий риск распространения вредоносного ПО. Это делает Android более открытой, но требует от разработчика дополнительных мер по защите приложения и информированию пользователей о безопасности.Доля рынка и целевая аудитория
По количеству установленных устройств Android доминирует — около 70–75% глобального рынка смартфонов, особенно в Азии, Африке и Латинской Америке. При этом iOS занимает около 25–30%, но сосредоточена в странах с высоким уровнем дохода — США, Западная Европа, Япония, Австралия.
Это создаёт принципиально разные экономические модели: приложения для iOS чаще генерируют больше дохода на одного пользователя (высокий ARPU — Average Revenue Per User), тогда как Android обеспечивает больший охват аудитории, но с меньшей monetization. Для бизнес-приложений это означает выбор между качеством и количеством.Обновления и жизненный цикл устройств
Apple контролирует полный цикл — от железа до ПО — и обеспечивает массовые обновления ОС для устройств, выпущенных до 5–6 лет назад. Более 90% активных устройств iOS работают на последних двух версиях ОС.
Android-устройства получают обновления неравномерно: производители (Samsung, Xiaomi и др.) сами решают, какие модели поддерживают, а многие бюджетные устройства остаются на устаревших версиях (Android 8–10) годами. Это вынуждает разработчиков поддерживать совместимость с множеством версий API, увеличивая сложность тестирования и развертывания.Безопасность и приватность
iOS позиционируется как более безопасная платформа благодаря изолированной среде выполнения приложений (sandboxing), строгому контролю доступа к данным (персональные файлы, камера, микрофон), шифрованию данных на уровне ОС и обязательному использованию App Transport Security.
Android предоставляет аналогичные механизмы, но их реализация зависит от производителя. Многие OEM-производители добавляют собственные сервисы, фоновые процессы и права, которые могут компрометировать приватность. Кроме того, открытость Android делает его более уязвимым к вредоносным APK-файлам, загружаемым вне Google Play.Интеграция с экосистемой
iOS тесно интегрирован с другими продуктами Apple: iCloud, AirDrop, Handoff, Continuity, Apple Watch, HomeKit. Это позволяет создавать кросс-устройственные приложения с единым пользовательским опытом.
Android интегрируется с сервисами Google: Gmail, Google Maps, Drive, Firebase, Google Assistant, Wear OS. Эти сервисы предоставляют мощные инструменты для разработчиков — особенно для аналитики (Firebase), push-уведомлений, облачного хранения и машинного обучения. Однако интеграция с другими устройствами (TV, часы, авто) менее унифицирована, чем в Apple.]]></description><link>материалы/подтемы/секция-1.-javascript/основные-платформы-мобильных-приложений.html</link><guid isPermaLink="false">Материалы/Подтемы/Секция 1. JavaScript/Основные платформы мобильных приложений.md</guid><pubDate>Fri, 12 Sep 2025 15:58:25 GMT</pubDate></item><item><title><![CDATA[Тема №1. Как создаются мобильные приложения]]></title><description><![CDATA[Вводная тема, посвящённая базовым понятиям разработки мобильных приложений. <a data-href="Основные платформы мобильных приложений" href="материалы/подтемы/секция-1.-javascript/основные-платформы-мобильных-приложений.html" class="internal-link" target="_self" rel="noopener nofollow">Основные платформы мобильных приложений</a>
<br><a data-href="Основные типы мобильных приложений" href="материалы/подтемы/секция-1.-javascript/основные-типы-мобильных-приложений.html" class="internal-link" target="_self" rel="noopener nofollow">Основные типы мобильных приложений</a>
<br><a data-href="Основные технологии для разработки мобильных приложений" href="материалы/подтемы/секция-1.-javascript/основные-технологии-для-разработки-мобильных-приложений.html" class="internal-link" target="_self" rel="noopener nofollow">Основные технологии для разработки мобильных приложений</a>
(Пусто)<br><a data-href="Тема №2. Основы JavaScript" href="лекции/секция-1.-javascript/тема-№2.-основы-javascript.html" class="internal-link" target="_self" rel="noopener nofollow">Тема №2. Основы JavaScript</a>]]></description><link>лекции/секция-1.-javascript/тема-№1.-как-создаются-мобильные-приложения.html</link><guid isPermaLink="false">Лекции/Секция 1. JavaScript/Тема №1. Как создаются мобильные приложения.md</guid><pubDate>Fri, 12 Sep 2025 15:40:20 GMT</pubDate></item><item><title><![CDATA[Pasted image 20250906080710]]></title><description><![CDATA[<img src="pasted-image-20250906080710.png" target="_self">]]></description><link>pasted-image-20250906080710.html</link><guid isPermaLink="false">Pasted image 20250906080710.png</guid><pubDate>Sat, 06 Sep 2025 05:07:10 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>